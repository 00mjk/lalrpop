#![allow(unused_imports)]
#![allow(unused_variables)]
use intern::{intern, InternedString};
use grammar::parse_tree::*;
use grammar::pattern::*;
use std::iter::once;
use tok::{self, Tok};
use util::strip;
extern crate lalrpop_util as __lalrpop_util;
use self::__lalrpop_util::ParseError as __ParseError;
#[allow(non_snake_case)]
pub fn parse_TypeRef<
    'input,
    __TOKEN: __ToTriple<'input, Error=tok::Error>,
    __TOKENS: IntoIterator<Item=__TOKEN>,
>(
    text: &'input str,
    __tokens: __TOKENS,
) -> Result<TypeRef, __ParseError<usize,Tok<'input>,tok::Error>>
{
    let mut __tokens = __tokens.into_iter();
    let mut __tokens = __tokens.map(|t| __ToTriple::to_triple(t));
    let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
    match try!(__parse__TypeRef::__state0(text, None, __lookahead, &mut __tokens)) {
        (_, Some(__lookahead), _) => {
            Err(__ParseError::ExtraToken { token: __lookahead })
        }
        (_, None, __parse__TypeRef::__Nonterminal::____TypeRef(__nt)) => {
            Ok(__nt)
        }
        _ => unreachable!(),
    }
}

mod __parse__TypeRef {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as __lalrpop_util;
    use self::__lalrpop_util::ParseError as __ParseError;
    use super::__ToTriple;

    #[allow(dead_code)]
    pub enum __Nonterminal<'input, > {
        RepeatOp(RepeatOp),
        Algorithm_3f(::std::option::Option<Algorithm>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Path(Path),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        Alternative(Alternative),
        Terminal(TerminalString),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        Lifetime(InternedString),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        NotMacroId(NonterminalString),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        TypeParameter(TypeParameter),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        Symbol_3f(::std::option::Option<Symbol>),
        Grammar(Grammar),
        Nonterminal(GrammarItem),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        CondOp(ConditionOp),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _40R(usize),
        Symbol_2b(::std::vec::Vec<Symbol>),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        Symbol_2a(::std::vec::Vec<Symbol>),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        Alternative_2a(::std::vec::Vec<Alternative>),
        TypeRef_3f(::std::option::Option<TypeRef>),
        ____TypeRef(TypeRef),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        Conversion(Conversion),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        MacroId(NonterminalString),
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        Symbol(Symbol),
        SymbolKind1(SymbolKind),
        _28_22if_22_20_3cCond_3e_29(Condition),
        Alternatives(Vec<Alternative>),
        TypeRef(TypeRef),
        AssociatedType(AssociatedType),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        ____Grammar(Grammar),
        Lifetime_3f(::std::option::Option<InternedString>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        GrammarItem(GrammarItem),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Symbol0(Symbol),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        QuotedTerminal(TerminalString),
        Escape(InternedString),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        ExprSymbol(ExprSymbol),
        GrammarTypeParameters(Vec<TypeParameter>),
        FieldPattern(FieldPattern<TypeRef>),
        Action(ActionKind),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        ____Pattern(Pattern<TypeRef>),
        Use(GrammarItem),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        _40L(usize),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Cond(Condition),
        Algorithm(Algorithm),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        StringLiteral(InternedString),
        Pattern(Pattern<TypeRef>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        Conversion_3f(::std::option::Option<Conversion>),
        GrammarParameters(Vec<Parameter>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Id(InternedString),
        GrammarParameter(Parameter),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        TypeRefOrLifetime(TypeRef),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        Symbol1(Symbol),
        Use_2a(::std::vec::Vec<GrammarItem>),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        ExternToken(GrammarItem),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        Action_3f(::std::option::Option<ActionKind>),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        GrammarParameter_3f(::std::option::Option<Parameter>),
    }

    // State 0
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [EOF]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   __TypeRef = (*) TypeRef [EOF]
    //
    //   "::" -> Shift(S7)
    //   "&" -> Shift(S2)
    //   "(" -> Shift(S3)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "#" -> Shift(S5)
    //
    //   "::"? -> S6
    //   TypeRef -> S4
    //   Path -> S1
    pub fn __state0<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym0 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym0));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym0 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym0));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym0 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym0));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym0 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym0));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state6(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state1(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
    }

    // State 1
    //   TypeRef = Path (*) [EOF]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   EOF -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   "<" -> Shift(S8)
    //   ")" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //
    pub fn __state1<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state8(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            None |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action52(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 2
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [EOF]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "Lifetime" -> Shift(S9)
    //   "MacroId" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "#" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //
    //   Lifetime? -> S11
    //   Lifetime -> S10
    pub fn __state2<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state9(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Mut(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __nt = super::__action97(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state11(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state10(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 3
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [EOF]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "#" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //
    //   Comma<TypeRef> -> S13
    //   (<TypeRef> ",")* -> S12
    pub fn __state3<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action153(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state12(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 4
    //   __TypeRef = TypeRef (*) [EOF]
    //
    //   EOF -> Reduce(__TypeRef = TypeRef => Call(ActionFn(1));)
    //
    pub fn __state4<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action1(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::____TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 5
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [EOF]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol -> S16
    //   @L -> S15
    //   Symbol0 -> S14
    //   Symbol1 -> S17
    pub fn __state5<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 6
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [EOF]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(88));)
    //   "MacroId" -> Reduce((<Id> "::")* =  => Call(ActionFn(88));)
    //
    //   (<Id> "::")* -> S18
    pub fn __state6<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 7
    //   "::"? = "::" (*) ["Id"]
    //   "::"? = "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce("::"? = "::" => Call(ActionFn(91));)
    //   "MacroId" -> Reduce("::"? = "::" => Call(ActionFn(91));)
    //
    pub fn __state7<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action91(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 8
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [EOF]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S20
    //   Comma<TypeRefOrLifetime> -> S19
    pub fn __state8<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action158(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state20(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state19(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 9
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //
    //   "#" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "&" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "(" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   ">" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "::" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "," -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //
    pub fn __state9<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Mut(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action74(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 10
    //   Lifetime? = Lifetime (*) ["#"]
    //   Lifetime? = Lifetime (*) ["&"]
    //   Lifetime? = Lifetime (*) ["("]
    //   Lifetime? = Lifetime (*) ["::"]
    //   Lifetime? = Lifetime (*) ["Id"]
    //   Lifetime? = Lifetime (*) ["MacroId"]
    //   Lifetime? = Lifetime (*) ["mut"]
    //
    //   "#" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "(" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "::" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "&" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "mut" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "Id" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "MacroId" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //
    pub fn __state10<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Mut(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action96(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 11
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [EOF]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [")"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //
    //   "#" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "MacroId" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "mut" -> Shift(S22)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //
    //   "mut"? -> S21
    pub fn __state11<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state22(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action95(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state21(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 12
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["("]
    //   (<TypeRef> ",") = (*) TypeRef "," [")"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")* (*) TypeRef? [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef? = (*) [")"]
    //   TypeRef? = (*) TypeRef [")"]
    //
    //   "::" -> Shift(S7)
    //   "(" -> Shift(S3)
    //   ")" -> Reduce(TypeRef? =  => Call(ActionFn(152));)
    //   "#" -> Shift(S5)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "&" -> Shift(S2)
    //
    //   TypeRef? -> S23
    //   "::"? -> S6
    //   TypeRef -> S25
    //   Path -> S1
    //   (<TypeRef> ",") -> S24
    pub fn __state12<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action152(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRef_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state6(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state25(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state1(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state24(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 13
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [EOF]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S26)
    //
    pub fn __state13<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state26(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 14
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "?" -> Shift(S30)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "Id" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "#" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "(" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "*" -> Shift(S29)
    //   "," -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "Escape" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   ">" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   ")" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "+" -> Shift(S28)
    //   "@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "<" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //
    //   RepeatOp -> S27
    pub fn __state14<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state28(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state27(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 15
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "Escape" -> Shift(S37)
    //   "Id" -> Shift(S42)
    //   "MacroId" -> Shift(S39)
    //   "<" -> Shift(S41)
    //   "(" -> Shift(S36)
    //   "@L" -> Shift(S35)
    //   "StringLiteral" -> Shift(S31)
    //   "@R" -> Shift(S34)
    //
    //   Escape -> S38
    //   MacroId -> S40
    //   StringLiteral -> S43
    //   SymbolKind1 -> S33
    //   QuotedTerminal -> S32
    pub fn __state15<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state42(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state36(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state31(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state33(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 16
    //   TypeRef = "#" Symbol (*) "#" [EOF]
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //
    //   "#" -> Shift(S44)
    //
    pub fn __state16<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 17
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //
    //   "@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "(" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   ">" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "#" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "," -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "<" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   ")" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //
    pub fn __state17<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 18
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [EOF]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //
    //   "Id" -> Shift(S45)
    //   "MacroId" -> Shift(S48)
    //
    //   Id -> S46
    //   (<Id> "::") -> S47
    pub fn __state18<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 19
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [EOF]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S49)
    //
    pub fn __state19<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 20
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* (*) TypeRefOrLifetime? [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   TypeRefOrLifetime? = (*) [">"]
    //   TypeRefOrLifetime? = (*) TypeRefOrLifetime [">"]
    //
    //   "#" -> Shift(S5)
    //   "::" -> Shift(S7)
    //   "Lifetime" -> Shift(S9)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "&" -> Shift(S2)
    //   "(" -> Shift(S3)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   ">" -> Reduce(TypeRefOrLifetime? =  => Call(ActionFn(157));)
    //
    //   TypeRefOrLifetime -> S53
    //   (<TypeRefOrLifetime> ",") -> S50
    //   TypeRef -> S54
    //   TypeRefOrLifetime? -> S52
    //   Path -> S1
    //   Lifetime -> S51
    //   "::"? -> S6
    pub fn __state20<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state9(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRefOrLifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state54(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRefOrLifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state1(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state51(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state6(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 21
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [EOF]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [EOF]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "(" -> Shift(S3)
    //   "#" -> Shift(S5)
    //   "::" -> Shift(S7)
    //   "&" -> Shift(S2)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //
    //   "::"? -> S6
    //   TypeRef -> S55
    //   Path -> S1
    pub fn __state21<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state6(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state55(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state1(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 22
    //   "mut"? = "mut" (*) ["#"]
    //   "mut"? = "mut" (*) ["&"]
    //   "mut"? = "mut" (*) ["("]
    //   "mut"? = "mut" (*) ["::"]
    //   "mut"? = "mut" (*) ["Id"]
    //   "mut"? = "mut" (*) ["MacroId"]
    //
    //   "Id" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "&" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "::" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "MacroId" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "(" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "#" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //
    pub fn __state22<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action94(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 23
    //   Comma<TypeRef> = (<TypeRef> ",")* TypeRef? (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")*, TypeRef? => Call(ActionFn(98));)
    //
    pub fn __state23<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action98(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRef_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 24
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "&" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "Id" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "::" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "(" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   ")" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "#" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //
    pub fn __state24<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action154(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 25
    //   (<TypeRef> ",") = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["("]
    //   (<TypeRef> ",") = TypeRef (*) "," [")"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["MacroId"]
    //   TypeRef? = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(TypeRef? = TypeRef => Call(ActionFn(151));)
    //   "," -> Shift(S56)
    //
    pub fn __state25<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action151(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 26
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [EOF]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //
    pub fn __state26<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action48(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 27
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S57
    pub fn __state27<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 28
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "(" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "<" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "," -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "#" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "Escape" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "Id" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   ">" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   ")" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "MacroId" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //
    pub fn __state28<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action37(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 29
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "Id" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   ">" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   ")" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "<" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "#" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "," -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "Escape" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "(" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "MacroId" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //
    pub fn __state29<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 30
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //
    //   "(" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   ")" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "#" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   ">" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "MacroId" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "Escape" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "," -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "Id" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "<" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //
    pub fn __state30<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 31
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //
    pub fn __state31<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action78(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 32
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //
    pub fn __state32<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 33
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S58
    pub fn __state33<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 34
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //
    //   ">" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "#" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "<" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   ")" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "(" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "," -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //
    pub fn __state34<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action47(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 35
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "(" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "," -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   ")" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "<" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "#" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   ">" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //
    pub fn __state35<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action46(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 36
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //
    //   ExprSymbol -> S60
    //   Symbol* -> S59
    pub fn __state36<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::ExprSymbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 37
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "Id" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "Escape" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "@R" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "<" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "MacroId" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "(" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "#" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "@L" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //
    pub fn __state37<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action73(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 38
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "(" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "," -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "Id" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "<" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "#" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   ">" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   ")" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //
    pub fn __state38<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action44(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 39
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(69));)
    //
    pub fn __state39<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::MacroId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 40
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Shift(S61)
    //
    pub fn __state40<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state61(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 41
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol0 -> S63
    //   @L -> S62
    //   Symbol1 -> S17
    pub fn __state41<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state63(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 42
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "," -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "#" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ")" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "(" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "<" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //
    pub fn __state42<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 43
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "," -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //
    pub fn __state43<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action77(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::QuotedTerminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 44
    //   TypeRef = "#" Symbol "#" (*) [EOF]
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //
    pub fn __state44<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Symbol>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action49(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 45
    //   Id = "Id" (*) [EOF]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   EOF -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //
    pub fn __state45<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            None |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 46
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [EOF]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   EOF -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "::" -> Shift(S64)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //
    pub fn __state46<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            None |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action55(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 47
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(89));)
    //   "Id" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(89));)
    //
    pub fn __state47<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<InternedString>>,
        __sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action89(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 48
    //   Id = "MacroId" (*) [EOF]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //
    //   ")" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   ">" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "::" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "<" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "," -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   EOF -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //
    pub fn __state48<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action72(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 49
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [EOF]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //
    pub fn __state49<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 50
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["MacroId"]
    //
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //
    pub fn __state50<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 51
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(54));)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(54));)
    //
    pub fn __state51<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action54(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 52
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")*, TypeRefOrLifetime? => Call(ActionFn(93));)
    //
    pub fn __state52<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action93(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 53
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["MacroId"]
    //   TypeRefOrLifetime? = TypeRefOrLifetime (*) [">"]
    //
    //   ">" -> Reduce(TypeRefOrLifetime? = TypeRefOrLifetime => Call(ActionFn(156));)
    //   "," -> Shift(S65)
    //
    pub fn __state53<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action156(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 54
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(53));)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(53));)
    //
    pub fn __state54<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action53(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 55
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [EOF]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   ")" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //
    pub fn __state55<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action50(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 56
    //   (<TypeRef> ",") = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["("]
    //   (<TypeRef> ",") = TypeRef "," (*) [")"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "#" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "MacroId" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   ")" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "(" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "::" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "&" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //
    pub fn __state56<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action155(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 57
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //
    pub fn __state57<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 58
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //
    pub fn __state58<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action40(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 59
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol* (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(ExprSymbol = Symbol* => Call(ActionFn(31));)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol0 -> S14
    //   Symbol1 -> S17
    //   @L -> S15
    //   Symbol -> S66
    pub fn __state59<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExprSymbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state66(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 60
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //
    //   ")" -> Shift(S67)
    //
    pub fn __state60<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state67(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 61
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //
    //   (<Symbol> ",")* -> S68
    //   Comma<Symbol> -> S69
    pub fn __state61<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action148(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state68(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cSymbol_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state69(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 62
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S36)
    //   "Escape" -> Shift(S37)
    //   "@L" -> Shift(S35)
    //   "MacroId" -> Shift(S70)
    //   "@R" -> Shift(S34)
    //   "Id" -> Shift(S71)
    //   "StringLiteral" -> Shift(S31)
    //
    //   Escape -> S38
    //   Id -> S72
    //   StringLiteral -> S43
    //   MacroId -> S40
    //   QuotedTerminal -> S32
    //   SymbolKind1 -> S33
    pub fn __state62<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state36(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state71(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state31(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state72(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state33(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 63
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   ">" -> Shift(S73)
    //   "?" -> Shift(S30)
    //   "*" -> Shift(S29)
    //   "+" -> Shift(S28)
    //
    //   RepeatOp -> S27
    pub fn __state63<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state73(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state28(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state27(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 64
    //   (<Id> "::") = Id "::" (*) ["Id"]
    //   (<Id> "::") = Id "::" (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(90));)
    //   "Id" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(90));)
    //
    pub fn __state64<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action90(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 65
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "(" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "#" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //
    pub fn __state65<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action160(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 66
    //   Symbol* = Symbol* Symbol (*) ["("]
    //   Symbol* = Symbol* Symbol (*) [")"]
    //   Symbol* = Symbol* Symbol (*) ["<"]
    //   Symbol* = Symbol* Symbol (*) ["@L"]
    //   Symbol* = Symbol* Symbol (*) ["@R"]
    //   Symbol* = Symbol* Symbol (*) ["Escape"]
    //   Symbol* = Symbol* Symbol (*) ["Id"]
    //   Symbol* = Symbol* Symbol (*) ["MacroId"]
    //   Symbol* = Symbol* Symbol (*) ["StringLiteral"]
    //
    //   "@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "Id" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   ")" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "MacroId" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "StringLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "(" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "Escape" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "<" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //
    pub fn __state66<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 67
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //
    pub fn __state67<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<ExprSymbol>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action45(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 68
    //   (<Symbol> ",") = (*) Symbol "," ["("]
    //   (<Symbol> ",") = (*) Symbol "," ["<"]
    //   (<Symbol> ",") = (*) Symbol "," [">"]
    //   (<Symbol> ",") = (*) Symbol "," ["@L"]
    //   (<Symbol> ",") = (*) Symbol "," ["@R"]
    //   (<Symbol> ",") = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",") = (*) Symbol "," ["Id"]
    //   (<Symbol> ",") = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",") = (*) Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")* (*) Symbol? [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol? = (*) [">"]
    //   Symbol? = (*) Symbol [">"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   ">" -> Reduce(Symbol? =  => Call(ActionFn(147));)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   (<Symbol> ",") -> S75
    //   Symbol1 -> S17
    //   Symbol? -> S74
    //   Symbol -> S76
    //   Symbol0 -> S14
    //   @L -> S15
    pub fn __state68<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state75(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state76(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 69
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //
    //   ">" -> Shift(S77)
    //
    pub fn __state69<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state77(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 70
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(69));)
    //
    pub fn __state70<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action72(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::MacroId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 71
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //
    pub fn __state71<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 72
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //
    //   ":" -> Shift(S78)
    //
    pub fn __state72<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 73
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S79
    pub fn __state73<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state79(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 74
    //   Comma<Symbol> = (<Symbol> ",")* Symbol? (*) [">"]
    //
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")*, Symbol? => Call(ActionFn(99));)
    //
    pub fn __state74<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<::std::option::Option<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cSymbol_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 75
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["StringLiteral"]
    //
    //   "@L" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "(" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "Id" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   ">" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "MacroId" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "<" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "Escape" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "@R" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //
    pub fn __state75<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 76
    //   (<Symbol> ",") = Symbol (*) "," ["("]
    //   (<Symbol> ",") = Symbol (*) "," ["<"]
    //   (<Symbol> ",") = Symbol (*) "," [">"]
    //   (<Symbol> ",") = Symbol (*) "," ["@L"]
    //   (<Symbol> ",") = Symbol (*) "," ["@R"]
    //   (<Symbol> ",") = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",") = Symbol (*) "," ["Id"]
    //   (<Symbol> ",") = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",") = Symbol (*) "," ["StringLiteral"]
    //   Symbol? = Symbol (*) [">"]
    //
    //   ">" -> Reduce(Symbol? = Symbol => Call(ActionFn(146));)
    //   "," -> Shift(S80)
    //
    pub fn __state76<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state80(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action146(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 77
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //
    pub fn __state77<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 78
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol0 -> S81
    //   @L -> S82
    //   Symbol1 -> S17
    pub fn __state78<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state81(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state82(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 79
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //
    pub fn __state79<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action33(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 80
    //   (<Symbol> ",") = Symbol "," (*) ["("]
    //   (<Symbol> ",") = Symbol "," (*) ["<"]
    //   (<Symbol> ",") = Symbol "," (*) [">"]
    //   (<Symbol> ",") = Symbol "," (*) ["@L"]
    //   (<Symbol> ",") = Symbol "," (*) ["@R"]
    //   (<Symbol> ",") = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",") = Symbol "," (*) ["Id"]
    //   (<Symbol> ",") = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",") = Symbol "," (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "(" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   ">" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "Id" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "Escape" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "MacroId" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "@R" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "@L" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "<" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //
    pub fn __state80<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action150(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 81
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   ">" -> Shift(S83)
    //   "*" -> Shift(S29)
    //   "?" -> Shift(S30)
    //   "+" -> Shift(S28)
    //
    //   RepeatOp -> S27
    pub fn __state81<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state83(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state28(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state27(text, __lookbehind, __lookahead, __tokens, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 82
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "@R" -> Shift(S34)
    //   "@L" -> Shift(S35)
    //   "(" -> Shift(S36)
    //   "StringLiteral" -> Shift(S31)
    //   "MacroId" -> Shift(S39)
    //   "Escape" -> Shift(S37)
    //   "Id" -> Shift(S42)
    //
    //   MacroId -> S40
    //   Escape -> S38
    //   SymbolKind1 -> S33
    //   QuotedTerminal -> S32
    //   StringLiteral -> S43
    pub fn __state82<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state36(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state31(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state42(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state33(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 83
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S84
    pub fn __state83<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state84(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 84
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //
    pub fn __state84<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
#[allow(non_snake_case)]
pub fn parse_Grammar<
    'input,
    __TOKEN: __ToTriple<'input, Error=tok::Error>,
    __TOKENS: IntoIterator<Item=__TOKEN>,
>(
    text: &'input str,
    __tokens: __TOKENS,
) -> Result<Grammar, __ParseError<usize,Tok<'input>,tok::Error>>
{
    let mut __tokens = __tokens.into_iter();
    let mut __tokens = __tokens.map(|t| __ToTriple::to_triple(t));
    let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
    match try!(__parse__Grammar::__state0(text, None, __lookahead, &mut __tokens)) {
        (_, Some(__lookahead), _) => {
            Err(__ParseError::ExtraToken { token: __lookahead })
        }
        (_, None, __parse__Grammar::__Nonterminal::____Grammar(__nt)) => {
            Ok(__nt)
        }
        _ => unreachable!(),
    }
}

mod __parse__Grammar {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as __lalrpop_util;
    use self::__lalrpop_util::ParseError as __ParseError;
    use super::__ToTriple;

    #[allow(dead_code)]
    pub enum __Nonterminal<'input, > {
        RepeatOp(RepeatOp),
        Algorithm_3f(::std::option::Option<Algorithm>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Path(Path),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        Alternative(Alternative),
        Terminal(TerminalString),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        Lifetime(InternedString),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        NotMacroId(NonterminalString),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        TypeParameter(TypeParameter),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        Symbol_3f(::std::option::Option<Symbol>),
        Grammar(Grammar),
        Nonterminal(GrammarItem),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        CondOp(ConditionOp),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _40R(usize),
        Symbol_2b(::std::vec::Vec<Symbol>),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        Symbol_2a(::std::vec::Vec<Symbol>),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        Alternative_2a(::std::vec::Vec<Alternative>),
        TypeRef_3f(::std::option::Option<TypeRef>),
        ____TypeRef(TypeRef),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        Conversion(Conversion),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        MacroId(NonterminalString),
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        Symbol(Symbol),
        SymbolKind1(SymbolKind),
        _28_22if_22_20_3cCond_3e_29(Condition),
        Alternatives(Vec<Alternative>),
        TypeRef(TypeRef),
        AssociatedType(AssociatedType),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        ____Grammar(Grammar),
        Lifetime_3f(::std::option::Option<InternedString>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        GrammarItem(GrammarItem),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Symbol0(Symbol),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        QuotedTerminal(TerminalString),
        Escape(InternedString),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        ExprSymbol(ExprSymbol),
        GrammarTypeParameters(Vec<TypeParameter>),
        FieldPattern(FieldPattern<TypeRef>),
        Action(ActionKind),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        ____Pattern(Pattern<TypeRef>),
        Use(GrammarItem),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        _40L(usize),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Cond(Condition),
        Algorithm(Algorithm),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        StringLiteral(InternedString),
        Pattern(Pattern<TypeRef>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        Conversion_3f(::std::option::Option<Conversion>),
        GrammarParameters(Vec<Parameter>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Id(InternedString),
        GrammarParameter(Parameter),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        TypeRefOrLifetime(TypeRef),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        Symbol1(Symbol),
        Use_2a(::std::vec::Vec<GrammarItem>),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        ExternToken(GrammarItem),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        Action_3f(::std::option::Option<ActionKind>),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        GrammarParameter_3f(::std::option::Option<Parameter>),
    }

    // State 0
    //   Grammar = (*) Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //   Use* = (*) ["grammar"]
    //   Use* = (*) ["use"]
    //   Use* = (*) Use* Use ["grammar"]
    //   Use* = (*) Use* Use ["use"]
    //   __Grammar = (*) Grammar [EOF]
    //
    //   "use" -> Reduce(Use* =  => Call(ActionFn(129));)
    //   "grammar" -> Reduce(Use* =  => Call(ActionFn(129));)
    //
    //   Use* -> S2
    //   Grammar -> S1
    pub fn __state0<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::Grammar(..), _)) => {
                let __nt = super::__action129(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Use_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Use_2a(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                __Nonterminal::Grammar(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state1(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
    }

    // State 1
    //   __Grammar = Grammar (*) [EOF]
    //
    //   EOF -> Reduce(__Grammar = Grammar => Call(ActionFn(0));)
    //
    pub fn __state1<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Grammar>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action0(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::____Grammar(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 2
    //   @L = (*) ["grammar"]
    //   Grammar = Use* (*) @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //   Use = (*) "use" ";" ["grammar"]
    //   Use = (*) "use" ";" ["use"]
    //   Use* = Use* (*) Use ["grammar"]
    //   Use* = Use* (*) Use ["use"]
    //
    //   "grammar" -> Reduce(@L =  => Lookahead;)
    //   "use" -> Shift(S5)
    //
    //   Use -> S4
    //   @L -> S3
    pub fn __state2<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Use(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Grammar(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Use(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 3
    //   Grammar = Use* @L (*) "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //
    //   "grammar" -> Shift(S6)
    //
    pub fn __state3<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Grammar(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state6(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 4
    //   Use* = Use* Use (*) ["grammar"]
    //   Use* = Use* Use (*) ["use"]
    //
    //   "grammar" -> Reduce(Use* = Use*, Use => Call(ActionFn(130));)
    //   "use" -> Reduce(Use* = Use*, Use => Call(ActionFn(130));)
    //
    pub fn __state4<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Grammar(..), _)) |
            Some((_, Tok::Use(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action130(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 5
    //   Use = "use" (*) ";" ["grammar"]
    //   Use = "use" (*) ";" ["use"]
    //   Use = "use" (*) ";" [EOF]
    //   Use = "use" (*) ";" ["Escape"]
    //   Use = "use" (*) ";" ["Id"]
    //   Use = "use" (*) ";" ["MacroId"]
    //   Use = "use" (*) ";" ["extern"]
    //   Use = "use" (*) ";" ["pub"]
    //   Use = "use" (*) ";" ["use"]
    //
    //   ";" -> Shift(S7)
    //
    pub fn __state5<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 6
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["["]
    //   @R = (*) ["where"]
    //   Grammar = Use* @L "grammar" (*) @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //
    //   "where" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "[" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S8
    pub fn __state6<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Where(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LeftBracket(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state8(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 7
    //   Use = "use" ";" (*) ["grammar"]
    //   Use = "use" ";" (*) ["use"]
    //   Use = "use" ";" (*) [EOF]
    //   Use = "use" ";" (*) ["Escape"]
    //   Use = "use" ";" (*) ["Id"]
    //   Use = "use" ";" (*) ["MacroId"]
    //   Use = "use" ";" (*) ["extern"]
    //   Use = "use" ";" (*) ["pub"]
    //   Use = "use" ";" (*) ["use"]
    //
    //   "MacroId" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "extern" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   EOF -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "use" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "grammar" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "Escape" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "pub" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "Id" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //
    pub fn __state7<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            None |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::Grammar(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action13(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 8
    //   Grammar = Use* @L "grammar" @R (*) GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["["]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["where"]
    //   GrammarTypeParameters? = (*) ["("]
    //   GrammarTypeParameters? = (*) [";"]
    //   GrammarTypeParameters? = (*) ["["]
    //   GrammarTypeParameters? = (*) ["where"]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters ["("]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters [";"]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters ["["]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters ["where"]
    //
    //   "(" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(128));)
    //   "where" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(128));)
    //   "[" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(128));)
    //   "<" -> Shift(S9)
    //   ";" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(128));)
    //
    //   GrammarTypeParameters -> S10
    //   GrammarTypeParameters? -> S11
    pub fn __state8<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state9(text, __lookbehind, __lookahead, __tokens, __sym4));
            }
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Where(_), _)) |
            Some((_, Tok::LeftBracket(..), _)) |
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action128(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::GrammarTypeParameters(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state10(text, __lookbehind, __lookahead, __tokens, __sym4));
                }
                __Nonterminal::GrammarTypeParameters_3f(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state11(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 9
    //   (<TypeParameter> ",")* = (*) [">"]
    //   (<TypeParameter> ",")* = (*) ["Id"]
    //   (<TypeParameter> ",")* = (*) ["Lifetime"]
    //   (<TypeParameter> ",")* = (*) ["MacroId"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") [">"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") ["Id"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") ["Lifetime"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") ["MacroId"]
    //   Comma<TypeParameter> = (*) (<TypeParameter> ",")* TypeParameter? [">"]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["["]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["where"]
    //
    //   "Id" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(133));)
    //   "MacroId" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(133));)
    //   ">" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(133));)
    //   "Lifetime" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(133));)
    //
    //   (<TypeParameter> ",")* -> S13
    //   Comma<TypeParameter> -> S12
    pub fn __state9<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action133(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeParameter_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state12(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 10
    //   GrammarTypeParameters? = GrammarTypeParameters (*) ["("]
    //   GrammarTypeParameters? = GrammarTypeParameters (*) [";"]
    //   GrammarTypeParameters? = GrammarTypeParameters (*) ["["]
    //   GrammarTypeParameters? = GrammarTypeParameters (*) ["where"]
    //
    //   "[" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(127));)
    //   ";" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(127));)
    //   "(" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(127));)
    //   "where" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(127));)
    //
    pub fn __state10<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBracket(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Where(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action127(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 11
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? (*) GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["["]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //   GrammarParameters? = (*) [";"]
    //   GrammarParameters? = (*) ["["]
    //   GrammarParameters? = (*) ["where"]
    //   GrammarParameters? = (*) GrammarParameters [";"]
    //   GrammarParameters? = (*) GrammarParameters ["["]
    //   GrammarParameters? = (*) GrammarParameters ["where"]
    //
    //   "where" -> Reduce(GrammarParameters? =  => Call(ActionFn(126));)
    //   "(" -> Shift(S14)
    //   ";" -> Reduce(GrammarParameters? =  => Call(ActionFn(126));)
    //   "[" -> Reduce(GrammarParameters? =  => Call(ActionFn(126));)
    //
    //   GrammarParameters -> S15
    //   GrammarParameters? -> S16
    pub fn __state11<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, Tok::Where(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LeftBracket(..), _)) => {
                let __nt = super::__action126(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarParameters_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::GrammarParameters(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::GrammarParameters_3f(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 12
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["("]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" [";"]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["["]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["where"]
    //
    //   ">" -> Shift(S17)
    //
    pub fn __state12<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 13
    //   (<TypeParameter> ",") = (*) TypeParameter "," [">"]
    //   (<TypeParameter> ",") = (*) TypeParameter "," ["Id"]
    //   (<TypeParameter> ",") = (*) TypeParameter "," ["Lifetime"]
    //   (<TypeParameter> ",") = (*) TypeParameter "," ["MacroId"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") [">"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") ["Id"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") ["Lifetime"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") ["MacroId"]
    //   Comma<TypeParameter> = (<TypeParameter> ",")* (*) TypeParameter? [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   TypeParameter = (*) Id [","]
    //   TypeParameter = (*) Id [">"]
    //   TypeParameter = (*) Lifetime [","]
    //   TypeParameter = (*) Lifetime [">"]
    //   TypeParameter? = (*) [">"]
    //   TypeParameter? = (*) TypeParameter [">"]
    //
    //   "Id" -> Shift(S25)
    //   "Lifetime" -> Shift(S18)
    //   ">" -> Reduce(TypeParameter? =  => Call(ActionFn(132));)
    //   "MacroId" -> Shift(S24)
    //
    //   Lifetime -> S23
    //   (<TypeParameter> ",") -> S21
    //   TypeParameter? -> S22
    //   TypeParameter -> S19
    //   Id -> S20
    pub fn __state13<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state25(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state24(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action132(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeParameter_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state21(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::TypeParameter_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state22(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::TypeParameter(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state19(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state20(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 14
    //   (<GrammarParameter> ",")* = (*) [")"]
    //   (<GrammarParameter> ",")* = (*) ["Id"]
    //   (<GrammarParameter> ",")* = (*) ["MacroId"]
    //   (<GrammarParameter> ",")* = (*) (<GrammarParameter> ",")* (<GrammarParameter> ",") [")"]
    //   (<GrammarParameter> ",")* = (*) (<GrammarParameter> ",")* (<GrammarParameter> ",") ["Id"]
    //   (<GrammarParameter> ",")* = (*) (<GrammarParameter> ",")* (<GrammarParameter> ",") ["MacroId"]
    //   Comma<GrammarParameter> = (*) (<GrammarParameter> ",")* GrammarParameter? [")"]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" ["["]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" ["where"]
    //
    //   "Id" -> Reduce((<GrammarParameter> ",")* =  => Call(ActionFn(138));)
    //   ")" -> Reduce((<GrammarParameter> ",")* =  => Call(ActionFn(138));)
    //   "MacroId" -> Reduce((<GrammarParameter> ",")* =  => Call(ActionFn(138));)
    //
    //   (<GrammarParameter> ",")* -> S27
    //   Comma<GrammarParameter> -> S26
    pub fn __state14<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action138(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state27(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cGrammarParameter_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state26(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 15
    //   GrammarParameters? = GrammarParameters (*) [";"]
    //   GrammarParameters? = GrammarParameters (*) ["["]
    //   GrammarParameters? = GrammarParameters (*) ["where"]
    //
    //   "where" -> Reduce(GrammarParameters? = GrammarParameters => Call(ActionFn(125));)
    //   "[" -> Reduce(GrammarParameters? = GrammarParameters => Call(ActionFn(125));)
    //   ";" -> Reduce(GrammarParameters? = GrammarParameters => Call(ActionFn(125));)
    //
    pub fn __state15<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Where(_), _)) |
            Some((_, Tok::LeftBracket(..), _)) |
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action125(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameters_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 16
    //   "where"? = (*) [";"]
    //   "where"? = (*) ["["]
    //   "where"? = (*) "where" [";"]
    //   "where"? = (*) "where" ["["]
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? (*) "where"? Algorithm? ";" GrammarItem* [EOF]
    //
    //   "[" -> Reduce("where"? =  => Call(ActionFn(124));)
    //   "where" -> Shift(S28)
    //   ";" -> Reduce("where"? =  => Call(ActionFn(124));)
    //
    //   "where"? -> S29
    pub fn __state16<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Where(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state28(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, Tok::LeftBracket(..), _)) |
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action124(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22where_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22where_22_3f(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 17
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["("]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) [";"]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["["]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["where"]
    //
    //   "[" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(5));)
    //   ";" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(5));)
    //   "(" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(5));)
    //   "where" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(5));)
    //
    pub fn __state17<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeParameter>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBracket(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Where(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action5(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 18
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //
    //   ">" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "," -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "&" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "::" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "#" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "(" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //
    pub fn __state18<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action74(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 19
    //   (<TypeParameter> ",") = TypeParameter (*) "," [">"]
    //   (<TypeParameter> ",") = TypeParameter (*) "," ["Id"]
    //   (<TypeParameter> ",") = TypeParameter (*) "," ["Lifetime"]
    //   (<TypeParameter> ",") = TypeParameter (*) "," ["MacroId"]
    //   TypeParameter? = TypeParameter (*) [">"]
    //
    //   ">" -> Reduce(TypeParameter? = TypeParameter => Call(ActionFn(131));)
    //   "," -> Shift(S30)
    //
    pub fn __state19<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeParameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action131(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeParameter_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 20
    //   TypeParameter = Id (*) [","]
    //   TypeParameter = Id (*) [">"]
    //
    //   ">" -> Reduce(TypeParameter = Id => Call(ActionFn(7));)
    //   "," -> Reduce(TypeParameter = Id => Call(ActionFn(7));)
    //
    pub fn __state20<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action7(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeParameter(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 21
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) [">"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) ["Id"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) ["Lifetime"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(134));)
    //   "Lifetime" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(134));)
    //   ">" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(134));)
    //   "MacroId" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(134));)
    //
    pub fn __state21<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
        __sym1: &mut Option<TypeParameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action134(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 22
    //   Comma<TypeParameter> = (<TypeParameter> ",")* TypeParameter? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeParameter> = (<TypeParameter> ",")*, TypeParameter? => Call(ActionFn(118));)
    //
    pub fn __state22<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
        __sym1: &mut Option<::std::option::Option<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action118(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeParameter_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 23
    //   TypeParameter = Lifetime (*) [","]
    //   TypeParameter = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeParameter = Lifetime => Call(ActionFn(6));)
    //   ">" -> Reduce(TypeParameter = Lifetime => Call(ActionFn(6));)
    //
    pub fn __state23<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action6(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeParameter(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 24
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) [":"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) ["="]
    //   Id = "MacroId" (*) ["="]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) [";"]
    //   Id = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "{" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "=" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "::" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "," -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   ")" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   ";" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   ">" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //
    pub fn __state24<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Colon(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action72(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 25
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) [":"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["="]
    //   Id = "Id" (*) ["="]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) [";"]
    //   Id = "Id" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "=" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "{" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   ";" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //
    pub fn __state25<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 26
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" [";"]
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" ["["]
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" ["where"]
    //
    //   ")" -> Shift(S31)
    //
    pub fn __state26<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state31(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 27
    //   (<GrammarParameter> ",") = (*) GrammarParameter "," [")"]
    //   (<GrammarParameter> ",") = (*) GrammarParameter "," ["Id"]
    //   (<GrammarParameter> ",") = (*) GrammarParameter "," ["MacroId"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (*) (<GrammarParameter> ",") [")"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (*) (<GrammarParameter> ",") ["Id"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (*) (<GrammarParameter> ",") ["MacroId"]
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")* (*) GrammarParameter? [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [","]
    //   GrammarParameter? = (*) [")"]
    //   GrammarParameter? = (*) GrammarParameter [")"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //
    //   ")" -> Reduce(GrammarParameter? =  => Call(ActionFn(137));)
    //   "Id" -> Shift(S25)
    //   "MacroId" -> Shift(S24)
    //
    //   GrammarParameter? -> S33
    //   Id -> S34
    //   (<GrammarParameter> ",") -> S35
    //   GrammarParameter -> S32
    pub fn __state27<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state25(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state24(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarParameter_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::GrammarParameter_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state33(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::GrammarParameter(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 28
    //   "where"? = "where" (*) [";"]
    //   "where"? = "where" (*) ["["]
    //
    //   ";" -> Reduce("where"? = "where" => Call(ActionFn(123));)
    //   "[" -> Reduce("where"? = "where" => Call(ActionFn(123));)
    //
    pub fn __state28<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LeftBracket(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action123(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22where_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 29
    //   Algorithm = (*) "[" @L StringLiteral @R "]" [";"]
    //   Algorithm? = (*) [";"]
    //   Algorithm? = (*) Algorithm [";"]
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? (*) Algorithm? ";" GrammarItem* [EOF]
    //
    //   ";" -> Reduce(Algorithm? =  => Call(ActionFn(122));)
    //   "[" -> Shift(S38)
    //
    //   Algorithm? -> S36
    //   Algorithm -> S37
    pub fn __state29<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        __sym6: &mut Option<::std::option::Option<Vec<&'input str>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBracket(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym7 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym7));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action122(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Algorithm_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Algorithm_3f(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state36(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                __Nonterminal::Algorithm(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 30
    //   (<TypeParameter> ",") = TypeParameter "," (*) [">"]
    //   (<TypeParameter> ",") = TypeParameter "," (*) ["Id"]
    //   (<TypeParameter> ",") = TypeParameter "," (*) ["Lifetime"]
    //   (<TypeParameter> ",") = TypeParameter "," (*) ["MacroId"]
    //
    //   "Lifetime" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(135));)
    //   ">" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(135));)
    //   "Id" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(135));)
    //   "MacroId" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(135));)
    //
    pub fn __state30<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeParameter>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action135(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 31
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) [";"]
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) ["["]
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) ["where"]
    //
    //   ";" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => Call(ActionFn(8));)
    //   "where" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => Call(ActionFn(8));)
    //   "[" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => Call(ActionFn(8));)
    //
    pub fn __state31<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<Parameter>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Where(_), _)) |
            Some((_, Tok::LeftBracket(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action8(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameters(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 32
    //   (<GrammarParameter> ",") = GrammarParameter (*) "," [")"]
    //   (<GrammarParameter> ",") = GrammarParameter (*) "," ["Id"]
    //   (<GrammarParameter> ",") = GrammarParameter (*) "," ["MacroId"]
    //   GrammarParameter? = GrammarParameter (*) [")"]
    //
    //   ")" -> Reduce(GrammarParameter? = GrammarParameter => Call(ActionFn(136));)
    //   "," -> Shift(S39)
    //
    pub fn __state32<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Parameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action136(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameter_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 33
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")* GrammarParameter? (*) [")"]
    //
    //   ")" -> Reduce(Comma<GrammarParameter> = (<GrammarParameter> ",")*, GrammarParameter? => Call(ActionFn(117));)
    //
    pub fn __state33<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Parameter>>,
        __sym1: &mut Option<::std::option::Option<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action117(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cGrammarParameter_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 34
    //   GrammarParameter = Id (*) ":" TypeRef [")"]
    //   GrammarParameter = Id (*) ":" TypeRef [","]
    //
    //   ":" -> Shift(S40)
    //
    pub fn __state34<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 35
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (<GrammarParameter> ",") (*) [")"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (<GrammarParameter> ",") (*) ["Id"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (<GrammarParameter> ",") (*) ["MacroId"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",")* = (<GrammarParameter> ",")*, (<GrammarParameter> ",") => Call(ActionFn(139));)
    //   "MacroId" -> Reduce((<GrammarParameter> ",")* = (<GrammarParameter> ",")*, (<GrammarParameter> ",") => Call(ActionFn(139));)
    //   "Id" -> Reduce((<GrammarParameter> ",")* = (<GrammarParameter> ",")*, (<GrammarParameter> ",") => Call(ActionFn(139));)
    //
    pub fn __state35<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Parameter>>,
        __sym1: &mut Option<Parameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 36
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? (*) ";" GrammarItem* [EOF]
    //
    //   ";" -> Shift(S41)
    //
    pub fn __state36<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        __sym6: &mut Option<::std::option::Option<Vec<&'input str>>>,
        __sym7: &mut Option<::std::option::Option<Algorithm>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym8 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 37
    //   Algorithm? = Algorithm (*) [";"]
    //
    //   ";" -> Reduce(Algorithm? = Algorithm => Call(ActionFn(121));)
    //
    pub fn __state37<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Algorithm>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action121(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Algorithm_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 38
    //   @L = (*) ["StringLiteral"]
    //   Algorithm = "[" (*) @L StringLiteral @R "]" [";"]
    //
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S42
    pub fn __state38<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state42(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 39
    //   (<GrammarParameter> ",") = GrammarParameter "," (*) [")"]
    //   (<GrammarParameter> ",") = GrammarParameter "," (*) ["Id"]
    //   (<GrammarParameter> ",") = GrammarParameter "," (*) ["MacroId"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",") = GrammarParameter, "," => Call(ActionFn(140));)
    //   "MacroId" -> Reduce((<GrammarParameter> ",") = GrammarParameter, "," => Call(ActionFn(140));)
    //   "Id" -> Reduce((<GrammarParameter> ",") = GrammarParameter, "," => Call(ActionFn(140));)
    //
    pub fn __state39<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Parameter>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action140(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 40
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   GrammarParameter = Id ":" (*) TypeRef [")"]
    //   GrammarParameter = Id ":" (*) TypeRef [","]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "#" -> Shift(S47)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "::" -> Shift(S48)
    //   "&" -> Shift(S49)
    //   "(" -> Shift(S44)
    //
    //   Path -> S46
    //   "::"? -> S45
    //   TypeRef -> S43
    pub fn __state40<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Path(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 41
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" (*) GrammarItem* [EOF]
    //   GrammarItem* = (*) [EOF]
    //   GrammarItem* = (*) ["Escape"]
    //   GrammarItem* = (*) ["Id"]
    //   GrammarItem* = (*) ["MacroId"]
    //   GrammarItem* = (*) ["extern"]
    //   GrammarItem* = (*) ["pub"]
    //   GrammarItem* = (*) ["use"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem [EOF]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["Escape"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["Id"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["MacroId"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["extern"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["pub"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["use"]
    //
    //   "pub" -> Reduce(GrammarItem* =  => Call(ActionFn(119));)
    //   EOF -> Reduce(GrammarItem* =  => Call(ActionFn(119));)
    //   "Id" -> Reduce(GrammarItem* =  => Call(ActionFn(119));)
    //   "use" -> Reduce(GrammarItem* =  => Call(ActionFn(119));)
    //   "extern" -> Reduce(GrammarItem* =  => Call(ActionFn(119));)
    //   "Escape" -> Reduce(GrammarItem* =  => Call(ActionFn(119));)
    //   "MacroId" -> Reduce(GrammarItem* =  => Call(ActionFn(119));)
    //
    //   GrammarItem* -> S50
    pub fn __state41<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        __sym6: &mut Option<::std::option::Option<Vec<&'input str>>>,
        __sym7: &mut Option<::std::option::Option<Algorithm>>,
        __sym8: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Pub(..), _)) |
            None |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action119(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym8.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::GrammarItem_2a(__nt) => {
                    let __sym9 = &mut Some(__nt);
                    __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 42
    //   Algorithm = "[" @L (*) StringLiteral @R "]" [";"]
    //   StringLiteral = (*) "StringLiteral" ["]"]
    //
    //   "StringLiteral" -> Shift(S52)
    //
    //   StringLiteral -> S51
    pub fn __state42<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state51(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 43
    //   GrammarParameter = Id ":" TypeRef (*) [")"]
    //   GrammarParameter = Id ":" TypeRef (*) [","]
    //
    //   "," -> Reduce(GrammarParameter = Id, ":", TypeRef => Call(ActionFn(9));)
    //   ")" -> Reduce(GrammarParameter = Id, ":", TypeRef => Call(ActionFn(9));)
    //
    pub fn __state43<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action9(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameter(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 44
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" ["="]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" ["{"]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [";"]
    //
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "#" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //
    //   Comma<TypeRef> -> S54
    //   (<TypeRef> ",")* -> S53
    pub fn __state44<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action153(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state54(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 45
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id ["="]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [";"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(88));)
    //   "MacroId" -> Reduce((<Id> "::")* =  => Call(ActionFn(88));)
    //
    //   (<Id> "::")* -> S55
    pub fn __state45<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state55(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 46
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path (*) ["="]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = Path (*) ["{"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = Path (*) [";"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [";"]
    //
    //   ")" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   "{" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   ";" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   "<" -> Shift(S56)
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   "=" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //
    pub fn __state46<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action52(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 47
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" ["="]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" ["{"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [";"]
    //
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol0 -> S58
    //   @L -> S57
    //   Symbol -> S59
    //   Symbol1 -> S60
    pub fn __state47<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 48
    //   "::"? = "::" (*) ["Id"]
    //   "::"? = "::" (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce("::"? = "::" => Call(ActionFn(91));)
    //   "Id" -> Reduce("::"? = "::" => Call(ActionFn(91));)
    //
    pub fn __state48<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action91(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 49
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef ["="]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef ["{"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [";"]
    //
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "#" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "Lifetime" -> Shift(S18)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //
    //   Lifetime? -> S61
    //   Lifetime -> S62
    pub fn __state49<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Mut(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action97(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state61(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 50
    //   "pub"? = (*) ["Escape"]
    //   "pub"? = (*) ["Id"]
    //   "pub"? = (*) ["MacroId"]
    //   "pub"? = (*) "pub" ["Escape"]
    //   "pub"? = (*) "pub" ["Id"]
    //   "pub"? = (*) "pub" ["MacroId"]
    //   @L = (*) ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem [EOF]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["Escape"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["Id"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["MacroId"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["extern"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["pub"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["use"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   "Escape" -> Reduce("pub"? =  => Call(ActionFn(116));)
    //   "Id" -> Reduce("pub"? =  => Call(ActionFn(116));)
    //   "extern" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce("pub"? =  => Call(ActionFn(116));)
    //   "use" -> Shift(S5)
    //   EOF -> Reduce(Grammar = Use*, @L, "grammar", @R, GrammarTypeParameters?, GrammarParameters?, "where"?, Algorithm?, ";", GrammarItem* => Call(ActionFn(3));)
    //   "pub" -> Shift(S69)
    //
    //   "pub"? -> S64
    //   @L -> S66
    //   ExternToken -> S63
    //   GrammarItem -> S67
    //   Use -> S65
    //   Nonterminal -> S68
    pub fn __state50<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        __sym6: &mut Option<::std::option::Option<Vec<&'input str>>>,
        __sym7: &mut Option<::std::option::Option<Algorithm>>,
        __sym8: &mut Option<Tok<'input>>,
        __sym9: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Use(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym10 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym10));
            }
            Some((_, __tok @ Tok::Pub(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym10 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state69(text, __lookbehind, __lookahead, __tokens, __sym10));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __nt = super::__action3(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Grammar(__nt)));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action116(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22pub_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym9.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22pub_22_3f(__nt) => {
                    let __sym10 = &mut Some(__nt);
                    __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym10));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym10 = &mut Some(__nt);
                    __result = try!(__state66(text, __lookbehind, __lookahead, __tokens, __sym10));
                }
                __Nonterminal::ExternToken(__nt) => {
                    let __sym10 = &mut Some(__nt);
                    __result = try!(__state63(text, __lookbehind, __lookahead, __tokens, __sym10));
                }
                __Nonterminal::GrammarItem(__nt) => {
                    let __sym10 = &mut Some(__nt);
                    __result = try!(__state67(text, __lookbehind, __lookahead, __tokens, __sym9, __sym10));
                }
                __Nonterminal::Use(__nt) => {
                    let __sym10 = &mut Some(__nt);
                    __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym10));
                }
                __Nonterminal::Nonterminal(__nt) => {
                    let __sym10 = &mut Some(__nt);
                    __result = try!(__state68(text, __lookbehind, __lookahead, __tokens, __sym10));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 51
    //   @R = (*) ["]"]
    //   Algorithm = "[" @L StringLiteral (*) @R "]" [";"]
    //
    //   "]" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S70
    pub fn __state51<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBracket(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 52
    //   StringLiteral = "StringLiteral" (*) ["]"]
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [";"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["if"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) [";"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "]" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   ";" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "if" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "=>@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "=>" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "=>?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "=>@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //
    pub fn __state52<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightBracket(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action78(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 53
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["("]
    //   (<TypeRef> ",") = (*) TypeRef "," [")"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")* (*) TypeRef? [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef? = (*) [")"]
    //   TypeRef? = (*) TypeRef [")"]
    //
    //   "#" -> Shift(S47)
    //   "(" -> Shift(S44)
    //   ")" -> Reduce(TypeRef? =  => Call(ActionFn(152));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "::" -> Shift(S48)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "&" -> Shift(S49)
    //
    //   "::"? -> S45
    //   TypeRef -> S73
    //   Path -> S46
    //   TypeRef? -> S72
    //   (<TypeRef> ",") -> S71
    pub fn __state53<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action152(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state73(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state72(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state71(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 54
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" ["="]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" ["{"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [";"]
    //
    //   ")" -> Shift(S74)
    //
    pub fn __state54<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 55
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id ["="]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [";"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //
    //   "MacroId" -> Shift(S24)
    //   "Id" -> Shift(S25)
    //
    //   Id -> S75
    //   (<Id> "::") -> S76
    pub fn __state55<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state24(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state25(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state75(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state76(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 56
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" ["="]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" ["{"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [";"]
    //
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //
    //   Comma<TypeRefOrLifetime> -> S78
    //   (<TypeRefOrLifetime> ",")* -> S77
    pub fn __state56<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action158(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state77(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 57
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [";"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["=>"]
    //   Escape = (*) "Escape" ["=>?"]
    //   Escape = (*) "Escape" ["=>@L"]
    //   Escape = (*) "Escape" ["=>@R"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   Escape = (*) "Escape" ["if"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [";"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["=>"]
    //   QuotedTerminal = (*) StringLiteral ["=>?"]
    //   QuotedTerminal = (*) StringLiteral ["=>@L"]
    //   QuotedTerminal = (*) StringLiteral ["=>@R"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["if"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [";"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["if"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [";"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [";"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["if"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [";"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["=>"]
    //   SymbolKind1 = (*) Escape ["=>?"]
    //   SymbolKind1 = (*) Escape ["=>@L"]
    //   SymbolKind1 = (*) Escape ["=>@R"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["if"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [";"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [";"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>?"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["if"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [";"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["if"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [";"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["=>"]
    //   SymbolKind1 = (*) "@L" ["=>?"]
    //   SymbolKind1 = (*) "@L" ["=>@L"]
    //   SymbolKind1 = (*) "@L" ["=>@R"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["if"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [";"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["=>"]
    //   SymbolKind1 = (*) "@R" ["=>?"]
    //   SymbolKind1 = (*) "@R" ["=>@L"]
    //   SymbolKind1 = (*) "@R" ["=>@R"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["if"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [";"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["=>"]
    //   SymbolKind1 = (*) "Id" ["=>?"]
    //   SymbolKind1 = (*) "Id" ["=>@L"]
    //   SymbolKind1 = (*) "Id" ["=>@R"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["if"]
    //
    //   "@R" -> Shift(S90)
    //   "(" -> Shift(S83)
    //   "MacroId" -> Shift(S79)
    //   "@L" -> Shift(S86)
    //   "<" -> Shift(S80)
    //   "Id" -> Shift(S89)
    //   "StringLiteral" -> Shift(S52)
    //   "Escape" -> Shift(S84)
    //
    //   StringLiteral -> S85
    //   QuotedTerminal -> S88
    //   MacroId -> S81
    //   SymbolKind1 -> S87
    //   Escape -> S82
    pub fn __state57<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state90(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state83(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state79(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state86(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state80(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state89(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state84(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state85(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state88(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state81(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state87(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state82(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 58
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [";"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["=>"]
    //   RepeatOp = (*) "*" ["=>?"]
    //   RepeatOp = (*) "*" ["=>@L"]
    //   RepeatOp = (*) "*" ["=>@R"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "*" ["if"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [";"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["=>"]
    //   RepeatOp = (*) "+" ["=>?"]
    //   RepeatOp = (*) "+" ["=>@L"]
    //   RepeatOp = (*) "+" ["=>@R"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["if"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [";"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["=>"]
    //   RepeatOp = (*) "?" ["=>?"]
    //   RepeatOp = (*) "?" ["=>@L"]
    //   RepeatOp = (*) "?" ["=>@R"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["if"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [";"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["=>"]
    //   Symbol = Symbol0 (*) ["=>?"]
    //   Symbol = Symbol0 (*) ["=>@L"]
    //   Symbol = Symbol0 (*) ["=>@R"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [";"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["if"]
    //
    //   "#" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "=>@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "(" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "+" -> Shift(S93)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   ";" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "*" -> Shift(S92)
    //   "@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "if" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "," -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   ")" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "?" -> Shift(S91)
    //   "=>@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "Id" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "=>" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   ">" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "<" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "=>?" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "Escape" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //
    //   RepeatOp -> S94
    pub fn __state58<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state93(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state92(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state91(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state94(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 59
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //   TypeRef = "#" Symbol (*) "#" ["="]
    //   TypeRef = "#" Symbol (*) "#" ["{"]
    //   TypeRef = "#" Symbol (*) "#" [";"]
    //
    //   "#" -> Shift(S95)
    //
    pub fn __state59<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state95(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 60
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [";"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["=>"]
    //   Symbol0 = Symbol1 (*) ["=>?"]
    //   Symbol0 = Symbol1 (*) ["=>@L"]
    //   Symbol0 = Symbol1 (*) ["=>@R"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["if"]
    //
    //   "=>" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   ")" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "=>@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "if" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "=>@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   ";" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "=>?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   ">" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "<" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "(" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "#" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "," -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //
    pub fn __state60<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 61
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [")"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef ["="]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef ["{"]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [";"]
    //
    //   "MacroId" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "mut" -> Shift(S97)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "#" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //
    //   "mut"? -> S96
    pub fn __state61<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state97(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action95(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state96(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 62
    //   Lifetime? = Lifetime (*) ["#"]
    //   Lifetime? = Lifetime (*) ["&"]
    //   Lifetime? = Lifetime (*) ["("]
    //   Lifetime? = Lifetime (*) ["::"]
    //   Lifetime? = Lifetime (*) ["Id"]
    //   Lifetime? = Lifetime (*) ["MacroId"]
    //   Lifetime? = Lifetime (*) ["mut"]
    //
    //   "&" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "(" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "#" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "mut" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "MacroId" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "Id" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "::" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //
    pub fn __state62<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Mut(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action96(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 63
    //   GrammarItem = ExternToken (*) [EOF]
    //   GrammarItem = ExternToken (*) ["Escape"]
    //   GrammarItem = ExternToken (*) ["Id"]
    //   GrammarItem = ExternToken (*) ["MacroId"]
    //   GrammarItem = ExternToken (*) ["extern"]
    //   GrammarItem = ExternToken (*) ["pub"]
    //   GrammarItem = ExternToken (*) ["use"]
    //
    //   "MacroId" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "Escape" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "extern" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "pub" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   EOF -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "Id" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "use" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //
    pub fn __state63<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::Pub(..), _)) |
            None |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Use(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action11(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 64
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S98
    pub fn __state64<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state98(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 65
    //   GrammarItem = Use (*) [EOF]
    //   GrammarItem = Use (*) ["Escape"]
    //   GrammarItem = Use (*) ["Id"]
    //   GrammarItem = Use (*) ["MacroId"]
    //   GrammarItem = Use (*) ["extern"]
    //   GrammarItem = Use (*) ["pub"]
    //   GrammarItem = Use (*) ["use"]
    //
    //   "MacroId" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   EOF -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "Escape" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "use" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "extern" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "pub" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "Id" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //
    pub fn __state65<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            None |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action10(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 66
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "extern" -> Shift(S99)
    //
    pub fn __state66<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Extern(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state99(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 67
    //   GrammarItem* = GrammarItem* GrammarItem (*) [EOF]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["Escape"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["Id"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["MacroId"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["extern"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["pub"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["use"]
    //
    //   "Id" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(120));)
    //   "pub" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(120));)
    //   "Escape" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(120));)
    //   "use" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(120));)
    //   "extern" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(120));)
    //   EOF -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(120));)
    //   "MacroId" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(120));)
    //
    pub fn __state67<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            None |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action120(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 68
    //   GrammarItem = Nonterminal (*) [EOF]
    //   GrammarItem = Nonterminal (*) ["Escape"]
    //   GrammarItem = Nonterminal (*) ["Id"]
    //   GrammarItem = Nonterminal (*) ["MacroId"]
    //   GrammarItem = Nonterminal (*) ["extern"]
    //   GrammarItem = Nonterminal (*) ["pub"]
    //   GrammarItem = Nonterminal (*) ["use"]
    //
    //   "MacroId" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "Id" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "Escape" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   EOF -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "pub" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "extern" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "use" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //
    pub fn __state68<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            None |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::Use(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action12(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 69
    //   "pub"? = "pub" (*) ["Escape"]
    //   "pub"? = "pub" (*) ["Id"]
    //   "pub"? = "pub" (*) ["MacroId"]
    //
    //   "Escape" -> Reduce("pub"? = "pub" => Call(ActionFn(115));)
    //   "Id" -> Reduce("pub"? = "pub" => Call(ActionFn(115));)
    //   "MacroId" -> Reduce("pub"? = "pub" => Call(ActionFn(115));)
    //
    pub fn __state69<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action115(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22pub_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 70
    //   Algorithm = "[" @L StringLiteral @R (*) "]" [";"]
    //
    //   "]" -> Shift(S100)
    //
    pub fn __state70<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBracket(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state100(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 71
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "&" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "Id" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "(" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   ")" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "::" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //
    pub fn __state71<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action154(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 72
    //   Comma<TypeRef> = (<TypeRef> ",")* TypeRef? (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")*, TypeRef? => Call(ActionFn(98));)
    //
    pub fn __state72<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action98(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRef_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 73
    //   (<TypeRef> ",") = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["("]
    //   (<TypeRef> ",") = TypeRef (*) "," [")"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["MacroId"]
    //   TypeRef? = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(TypeRef? = TypeRef => Call(ActionFn(151));)
    //   "," -> Shift(S101)
    //
    pub fn __state73<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state101(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action151(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 74
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) ["="]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) ["{"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [";"]
    //
    //   "{" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   ";" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   "=" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //
    pub fn __state74<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action48(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 75
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) ["="]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [";"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //
    //   "=" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   ";" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "{" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "::" -> Shift(S102)
    //
    pub fn __state75<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state102(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action55(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 76
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(89));)
    //   "Id" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(89));)
    //
    pub fn __state76<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<InternedString>>,
        __sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action89(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 77
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* (*) TypeRefOrLifetime? [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   TypeRefOrLifetime? = (*) [">"]
    //   TypeRefOrLifetime? = (*) TypeRefOrLifetime [">"]
    //
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "&" -> Shift(S49)
    //   "#" -> Shift(S47)
    //   ">" -> Reduce(TypeRefOrLifetime? =  => Call(ActionFn(157));)
    //   "(" -> Shift(S44)
    //   "Lifetime" -> Shift(S18)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "::" -> Shift(S48)
    //
    //   TypeRefOrLifetime -> S104
    //   Lifetime -> S105
    //   TypeRefOrLifetime? -> S103
    //   Path -> S46
    //   TypeRef -> S106
    //   "::"? -> S45
    //   (<TypeRefOrLifetime> ",") -> S107
    pub fn __state77<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRefOrLifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state104(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state105(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRefOrLifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state103(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state106(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state107(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 78
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" ["="]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" ["{"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [";"]
    //
    //   ">" -> Shift(S108)
    //
    pub fn __state78<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state108(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 79
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(69));)
    //
    pub fn __state79<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::MacroId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 80
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [";"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S110
    //   Symbol0 -> S109
    //   Symbol1 -> S60
    pub fn __state80<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state110(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state109(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 81
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [";"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["if"]
    //
    //   "<" -> Shift(S111)
    //
    pub fn __state81<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state111(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 82
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [";"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["=>"]
    //   SymbolKind1 = Escape (*) ["=>?"]
    //   SymbolKind1 = Escape (*) ["=>@L"]
    //   SymbolKind1 = Escape (*) ["=>@R"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["if"]
    //
    //   "@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "=>@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "(" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "if" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   ">" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "<" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "," -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   ")" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "=>" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "=>?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "Id" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "=>@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "#" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   ";" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //
    pub fn __state82<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action44(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 83
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [";"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["if"]
    //
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //
    //   Symbol* -> S112
    //   ExprSymbol -> S113
    pub fn __state83<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state112(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::ExprSymbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state113(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 84
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [";"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["=>"]
    //   Escape = "Escape" (*) ["=>?"]
    //   Escape = "Escape" (*) ["=>@L"]
    //   Escape = "Escape" (*) ["=>@R"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["if"]
    //
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "if" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "=>" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "<" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "(" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "@R" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "Escape" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "=>?" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "@L" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "#" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "MacroId" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "=>@R" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "Id" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   ";" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "=>@L" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //
    pub fn __state84<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action73(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 85
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [";"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["=>"]
    //   QuotedTerminal = StringLiteral (*) ["=>?"]
    //   QuotedTerminal = StringLiteral (*) ["=>@L"]
    //   QuotedTerminal = StringLiteral (*) ["=>@R"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["if"]
    //   QuotedTerminal = StringLiteral (*) ["=>"]
    //
    //   "," -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "if" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "=>?" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "=>@L" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "=>" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "=>@R" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   ";" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //
    pub fn __state85<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action77(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::QuotedTerminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 86
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [";"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["=>"]
    //   SymbolKind1 = "@L" (*) ["=>?"]
    //   SymbolKind1 = "@L" (*) ["=>@L"]
    //   SymbolKind1 = "@L" (*) ["=>@R"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["if"]
    //
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   ";" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "<" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   ")" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "=>@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "#" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   ">" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "=>@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "=>?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "," -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "=>" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "(" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "if" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //
    pub fn __state86<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action46(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 87
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [";"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["if"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S114
    pub fn __state87<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state114(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 88
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [";"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>?"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["if"]
    //
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   ";" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "=>@R" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "=>@L" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "=>?" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "if" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "=>" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //
    pub fn __state88<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 89
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [";"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["=>"]
    //   SymbolKind1 = "Id" (*) ["=>?"]
    //   SymbolKind1 = "Id" (*) ["=>@L"]
    //   SymbolKind1 = "Id" (*) ["=>@R"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["if"]
    //
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "=>@R" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "#" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "=>" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "if" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "=>@L" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "<" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ")" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "(" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "," -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ";" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "=>?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //
    pub fn __state89<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 90
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [";"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["=>"]
    //   SymbolKind1 = "@R" (*) ["=>?"]
    //   SymbolKind1 = "@R" (*) ["=>@L"]
    //   SymbolKind1 = "@R" (*) ["=>@R"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["if"]
    //
    //   "if" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "=>" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "=>@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "=>@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   ">" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "#" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "," -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "(" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "=>?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   ")" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   ";" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "<" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //
    pub fn __state90<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action47(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 91
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [";"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["=>"]
    //   RepeatOp = "?" (*) ["=>?"]
    //   RepeatOp = "?" (*) ["=>@L"]
    //   RepeatOp = "?" (*) ["=>@R"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["if"]
    //
    //   "@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "(" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "Id" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "if" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   ">" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "<" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "=>?" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   ")" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "=>@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "=>@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "MacroId" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "," -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   ";" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "Escape" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "=>" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "#" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //
    pub fn __state91<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 92
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [";"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["=>"]
    //   RepeatOp = "*" (*) ["=>?"]
    //   RepeatOp = "*" (*) ["=>@L"]
    //   RepeatOp = "*" (*) ["=>@R"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["if"]
    //
    //   "#" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   ")" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   ">" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   ";" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "Escape" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "=>?" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "Id" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "=>@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "," -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "=>@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "(" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "MacroId" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "<" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "=>" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "if" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //
    pub fn __state92<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 93
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [";"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["=>"]
    //   RepeatOp = "+" (*) ["=>?"]
    //   RepeatOp = "+" (*) ["=>@L"]
    //   RepeatOp = "+" (*) ["=>@R"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["if"]
    //
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "," -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "<" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "#" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "=>@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   ")" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "=>?" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   ">" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "MacroId" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "(" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "if" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   ";" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "=>" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "Id" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "=>@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "Escape" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //
    pub fn __state93<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action37(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 94
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [";"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["if"]
    //
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S115
    pub fn __state94<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state115(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 95
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //   TypeRef = "#" Symbol "#" (*) ["="]
    //   TypeRef = "#" Symbol "#" (*) ["{"]
    //   TypeRef = "#" Symbol "#" (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   ";" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   "=" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   "{" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //
    pub fn __state95<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Symbol>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action49(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 96
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["="]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["{"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "(" -> Shift(S44)
    //   "::" -> Shift(S48)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "&" -> Shift(S49)
    //   "#" -> Shift(S47)
    //
    //   "::"? -> S45
    //   Path -> S46
    //   TypeRef -> S116
    pub fn __state96<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state116(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 97
    //   "mut"? = "mut" (*) ["#"]
    //   "mut"? = "mut" (*) ["&"]
    //   "mut"? = "mut" (*) ["("]
    //   "mut"? = "mut" (*) ["::"]
    //   "mut"? = "mut" (*) ["Id"]
    //   "mut"? = "mut" (*) ["MacroId"]
    //
    //   "Id" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "(" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "&" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "MacroId" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "::" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "#" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //
    pub fn __state97<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action94(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 98
    //   MacroId = (*) "MacroId" ["<"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" ["="]
    //   NonterminalName = (*) NotMacroId [":"]
    //   NonterminalName = (*) NotMacroId ["="]
    //   NonterminalName = (*) "Escape" [":"]
    //   NonterminalName = (*) "Escape" ["="]
    //   NotMacroId = (*) "Id" [":"]
    //   NotMacroId = (*) "Id" ["="]
    //
    //   "Escape" -> Shift(S119)
    //   "Id" -> Shift(S118)
    //   "MacroId" -> Shift(S79)
    //
    //   MacroId -> S121
    //   NonterminalName -> S117
    //   NotMacroId -> S120
    pub fn __state98<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state119(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state118(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state79(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::MacroId(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state121(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::NonterminalName(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state117(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::NotMacroId(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state120(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 99
    //   @R = (*) ["{"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "{" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S122
    pub fn __state99<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state122(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 100
    //   Algorithm = "[" @L StringLiteral @R "]" (*) [";"]
    //
    //   ";" -> Reduce(Algorithm = "[", @L, StringLiteral, @R, "]" => Call(ActionFn(4));)
    //
    pub fn __state100<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action4(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Algorithm(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 101
    //   (<TypeRef> ",") = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["("]
    //   (<TypeRef> ",") = TypeRef "," (*) [")"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["MacroId"]
    //
    //   ")" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "#" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "Id" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "(" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "&" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "::" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "MacroId" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //
    pub fn __state101<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action155(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 102
    //   (<Id> "::") = Id "::" (*) ["Id"]
    //   (<Id> "::") = Id "::" (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(90));)
    //   "Id" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(90));)
    //
    pub fn __state102<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action90(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 103
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")*, TypeRefOrLifetime? => Call(ActionFn(93));)
    //
    pub fn __state103<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action93(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 104
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["MacroId"]
    //   TypeRefOrLifetime? = TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S123)
    //   ">" -> Reduce(TypeRefOrLifetime? = TypeRefOrLifetime => Call(ActionFn(156));)
    //
    pub fn __state104<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state123(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action156(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 105
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(54));)
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(54));)
    //
    pub fn __state105<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action54(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 106
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(53));)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(53));)
    //
    pub fn __state106<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action53(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 107
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //
    pub fn __state107<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 108
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) ["="]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) ["{"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [";"]
    //
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   "{" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   "=" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   ";" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //
    pub fn __state108<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 109
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [";"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "+" -> Shift(S93)
    //   "?" -> Shift(S91)
    //   "*" -> Shift(S92)
    //   ">" -> Shift(S124)
    //
    //   RepeatOp -> S94
    pub fn __state109<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state93(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state91(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state92(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state124(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state94(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 110
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "Escape" -> Shift(S84)
    //   "StringLiteral" -> Shift(S52)
    //   "MacroId" -> Shift(S127)
    //   "Id" -> Shift(S125)
    //   "(" -> Shift(S83)
    //   "@L" -> Shift(S86)
    //   "@R" -> Shift(S90)
    //
    //   SymbolKind1 -> S87
    //   MacroId -> S81
    //   Escape -> S82
    //   Id -> S126
    //   QuotedTerminal -> S88
    //   StringLiteral -> S85
    pub fn __state110<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state84(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state127(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state125(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state83(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state86(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state90(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state87(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state81(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state82(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state126(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state88(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state85(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 111
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [";"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["if"]
    //
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //
    //   (<Symbol> ",")* -> S128
    //   Comma<Symbol> -> S129
    pub fn __state111<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action148(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state128(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cSymbol_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state129(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 112
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol* (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(ExprSymbol = Symbol* => Call(ActionFn(31));)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S57
    //   Symbol -> S130
    //   Symbol1 -> S60
    //   Symbol0 -> S58
    pub fn __state112<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExprSymbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state130(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 113
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [";"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["if"]
    //
    //   ")" -> Shift(S131)
    //
    pub fn __state113<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state131(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 114
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [";"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["if"]
    //
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "=>@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "if" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "=>?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "=>" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   ";" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "=>@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //
    pub fn __state114<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action40(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 115
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [";"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["if"]
    //
    //   "=>" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   ";" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "=>?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "=>@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "=>@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "if" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //
    pub fn __state115<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 116
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) ["="]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) ["{"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [";"]
    //
    //   "=" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   ")" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   ";" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   "{" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //
    pub fn __state116<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action50(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 117
    //   @R = (*) [":"]
    //   @R = (*) ["="]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   "=" -> Reduce(@R =  => Lookbehind;)
    //   ":" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S132
    pub fn __state117<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::Colon(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state132(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 118
    //   NotMacroId = "Id" (*) [":"]
    //   NotMacroId = "Id" (*) ["="]
    //   NotMacroId = "Id" (*) [","]
    //   NotMacroId = "Id" (*) [">"]
    //   NotMacroId = "Id" (*) ["!="]
    //   NotMacroId = "Id" (*) ["!~"]
    //   NotMacroId = "Id" (*) ["=="]
    //   NotMacroId = "Id" (*) ["~~"]
    //
    //   "!=" -> Reduce(NotMacroId = "Id" => Call(ActionFn(70));)
    //   "~~" -> Reduce(NotMacroId = "Id" => Call(ActionFn(70));)
    //   "==" -> Reduce(NotMacroId = "Id" => Call(ActionFn(70));)
    //   "!~" -> Reduce(NotMacroId = "Id" => Call(ActionFn(70));)
    //   ">" -> Reduce(NotMacroId = "Id" => Call(ActionFn(70));)
    //   "=" -> Reduce(NotMacroId = "Id" => Call(ActionFn(70));)
    //   ":" -> Reduce(NotMacroId = "Id" => Call(ActionFn(70));)
    //   "," -> Reduce(NotMacroId = "Id" => Call(ActionFn(70));)
    //
    pub fn __state118<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::BangEquals(..), _)) |
            Some((_, Tok::TildeTilde(..), _)) |
            Some((_, Tok::EqualsEquals(..), _)) |
            Some((_, Tok::BangTilde(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::Colon(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NotMacroId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 119
    //   NonterminalName = "Escape" (*) [":"]
    //   NonterminalName = "Escape" (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = "Escape" => Call(ActionFn(17));)
    //   "=" -> Reduce(NonterminalName = "Escape" => Call(ActionFn(17));)
    //
    pub fn __state119<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) |
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action17(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 120
    //   NonterminalName = NotMacroId (*) [":"]
    //   NonterminalName = NotMacroId (*) ["="]
    //
    //   "=" -> Reduce(NonterminalName = NotMacroId => Call(ActionFn(16));)
    //   ":" -> Reduce(NonterminalName = NotMacroId => Call(ActionFn(16));)
    //
    pub fn __state120<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action16(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 121
    //   NonterminalName = MacroId (*) "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = MacroId (*) "<" Comma<NotMacroId> ">" ["="]
    //
    //   "<" -> Shift(S133)
    //
    pub fn __state121<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state133(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 122
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "{" -> Shift(S134)
    //
    pub fn __state122<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state134(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 123
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "#" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //
    pub fn __state123<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action160(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 124
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [";"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["if"]
    //
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S135
    pub fn __state124<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::If(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state135(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 125
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //
    pub fn __state125<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 126
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["if"]
    //
    //   ":" -> Shift(S136)
    //
    pub fn __state126<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state136(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 127
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(69));)
    //
    pub fn __state127<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::MacroId(__nt)));
            }
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action72(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 128
    //   (<Symbol> ",") = (*) Symbol "," ["("]
    //   (<Symbol> ",") = (*) Symbol "," ["<"]
    //   (<Symbol> ",") = (*) Symbol "," [">"]
    //   (<Symbol> ",") = (*) Symbol "," ["@L"]
    //   (<Symbol> ",") = (*) Symbol "," ["@R"]
    //   (<Symbol> ",") = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",") = (*) Symbol "," ["Id"]
    //   (<Symbol> ",") = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",") = (*) Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")* (*) Symbol? [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol? = (*) [">"]
    //   Symbol? = (*) Symbol [">"]
    //
    //   ">" -> Reduce(Symbol? =  => Call(ActionFn(147));)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol -> S139
    //   Symbol? -> S138
    //   @L -> S57
    //   Symbol1 -> S60
    //   Symbol0 -> S58
    //   (<Symbol> ",") -> S137
    pub fn __state128<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state139(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state138(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state137(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 129
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [";"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["if"]
    //
    //   ">" -> Shift(S140)
    //
    pub fn __state129<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state140(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 130
    //   Symbol* = Symbol* Symbol (*) ["("]
    //   Symbol* = Symbol* Symbol (*) [")"]
    //   Symbol* = Symbol* Symbol (*) ["<"]
    //   Symbol* = Symbol* Symbol (*) ["@L"]
    //   Symbol* = Symbol* Symbol (*) ["@R"]
    //   Symbol* = Symbol* Symbol (*) ["Escape"]
    //   Symbol* = Symbol* Symbol (*) ["Id"]
    //   Symbol* = Symbol* Symbol (*) ["MacroId"]
    //   Symbol* = Symbol* Symbol (*) ["StringLiteral"]
    //
    //   "MacroId" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "Escape" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "Id" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   ")" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "<" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "StringLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "(" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //
    pub fn __state130<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 131
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [";"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["if"]
    //
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "=>" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   ";" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "=>@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "=>@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "if" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "=>?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //
    pub fn __state131<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<ExprSymbol>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action45(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 132
    //   (":" <TypeRef>) = (*) ":" TypeRef ["="]
    //   (":" <TypeRef>)? = (*) ["="]
    //   (":" <TypeRef>)? = (*) (":" <TypeRef>) ["="]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   ":" -> Shift(S143)
    //   "=" -> Reduce((":" <TypeRef>)? =  => Call(ActionFn(113));)
    //
    //   (":" <TypeRef>)? -> S141
    //   (":" <TypeRef>) -> S142
    pub fn __state132<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state143(text, __lookbehind, __lookahead, __tokens, __sym4));
            }
            Some((_, Tok::Equals(..), _)) => {
                let __nt = super::__action113(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state141(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state142(text, __lookbehind, __lookahead, __tokens, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 133
    //   (<NotMacroId> ",")* = (*) [">"]
    //   (<NotMacroId> ",")* = (*) ["Id"]
    //   (<NotMacroId> ",")* = (*) (<NotMacroId> ",")* (<NotMacroId> ",") [">"]
    //   (<NotMacroId> ",")* = (*) (<NotMacroId> ",")* (<NotMacroId> ",") ["Id"]
    //   Comma<NotMacroId> = (*) (<NotMacroId> ",")* NotMacroId? [">"]
    //   NonterminalName = MacroId "<" (*) Comma<NotMacroId> ">" [":"]
    //   NonterminalName = MacroId "<" (*) Comma<NotMacroId> ">" ["="]
    //
    //   "Id" -> Reduce((<NotMacroId> ",")* =  => Call(ActionFn(143));)
    //   ">" -> Reduce((<NotMacroId> ",")* =  => Call(ActionFn(143));)
    //
    //   Comma<NotMacroId> -> S145
    //   (<NotMacroId> ",")* -> S144
    pub fn __state133<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action143(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cNotMacroId_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state145(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state144(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 134
    //   AssociatedType* = (*) ["enum"]
    //   AssociatedType* = (*) ["type"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["enum"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["type"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "enum" -> Reduce(AssociatedType* =  => Call(ActionFn(86));)
    //   "type" -> Reduce(AssociatedType* =  => Call(ActionFn(86));)
    //
    //   AssociatedType* -> S146
    pub fn __state134<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Enum(..), _)) |
            Some((_, Tok::Type(..), _)) => {
                let __nt = super::__action86(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AssociatedType_2a(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state146(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 135
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [";"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["if"]
    //
    //   "=>" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "=>?" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ";" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "=>@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "if" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "=>@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //
    pub fn __state135<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action33(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 136
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S147
    //   Symbol0 -> S148
    //   Symbol1 -> S60
    pub fn __state136<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state147(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state148(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 137
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "(" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "@R" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "Escape" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "<" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   ">" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "Id" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "MacroId" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "@L" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //
    pub fn __state137<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 138
    //   Comma<Symbol> = (<Symbol> ",")* Symbol? (*) [">"]
    //
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")*, Symbol? => Call(ActionFn(99));)
    //
    pub fn __state138<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<::std::option::Option<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cSymbol_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 139
    //   (<Symbol> ",") = Symbol (*) "," ["("]
    //   (<Symbol> ",") = Symbol (*) "," ["<"]
    //   (<Symbol> ",") = Symbol (*) "," [">"]
    //   (<Symbol> ",") = Symbol (*) "," ["@L"]
    //   (<Symbol> ",") = Symbol (*) "," ["@R"]
    //   (<Symbol> ",") = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",") = Symbol (*) "," ["Id"]
    //   (<Symbol> ",") = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",") = Symbol (*) "," ["StringLiteral"]
    //   Symbol? = Symbol (*) [">"]
    //
    //   ">" -> Reduce(Symbol? = Symbol => Call(ActionFn(146));)
    //   "," -> Shift(S149)
    //
    pub fn __state139<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state149(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action146(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 140
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [";"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["if"]
    //
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "=>" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "if" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   ";" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "=>@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "=>@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "=>?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //
    pub fn __state140<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 141
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives [EOF]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["use"]
    //
    //   "=" -> Shift(S150)
    //
    pub fn __state141<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Equals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state150(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 142
    //   (":" <TypeRef>)? = (":" <TypeRef>) (*) ["="]
    //
    //   "=" -> Reduce((":" <TypeRef>)? = (":" <TypeRef>) => Call(ActionFn(112));)
    //
    pub fn __state142<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action112(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 143
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (":" <TypeRef>) = ":" (*) TypeRef ["="]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //
    //   "::" -> Shift(S48)
    //   "(" -> Shift(S44)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "&" -> Shift(S49)
    //   "#" -> Shift(S47)
    //
    //   "::"? -> S45
    //   TypeRef -> S151
    //   Path -> S46
    pub fn __state143<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state151(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 144
    //   (<NotMacroId> ",") = (*) NotMacroId "," [">"]
    //   (<NotMacroId> ",") = (*) NotMacroId "," ["Id"]
    //   (<NotMacroId> ",")* = (<NotMacroId> ",")* (*) (<NotMacroId> ",") [">"]
    //   (<NotMacroId> ",")* = (<NotMacroId> ",")* (*) (<NotMacroId> ",") ["Id"]
    //   Comma<NotMacroId> = (<NotMacroId> ",")* (*) NotMacroId? [">"]
    //   NotMacroId = (*) "Id" [","]
    //   NotMacroId = (*) "Id" [">"]
    //   NotMacroId? = (*) [">"]
    //   NotMacroId? = (*) NotMacroId [">"]
    //
    //   ">" -> Reduce(NotMacroId? =  => Call(ActionFn(142));)
    //   "Id" -> Shift(S118)
    //
    //   (<NotMacroId> ",") -> S153
    //   NotMacroId -> S152
    //   NotMacroId? -> S154
    pub fn __state144<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state118(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::NotMacroId_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state153(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::NotMacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state152(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::NotMacroId_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state154(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 145
    //   NonterminalName = MacroId "<" Comma<NotMacroId> (*) ">" [":"]
    //   NonterminalName = MacroId "<" Comma<NotMacroId> (*) ">" ["="]
    //
    //   ">" -> Shift(S155)
    //
    pub fn __state145<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state155(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 146
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["enum"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["type"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "enum" -> Shift(S158)
    //   "type" -> Shift(S156)
    //
    //   AssociatedType -> S157
    pub fn __state146<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Enum(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state158(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
            }
            Some((_, __tok @ Tok::Type(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state156(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AssociatedType(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state157(text, __lookbehind, __lookahead, __tokens, __sym4, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 147
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "Id" -> Shift(S89)
    //   "MacroId" -> Shift(S79)
    //   "Escape" -> Shift(S84)
    //   "@L" -> Shift(S86)
    //   "(" -> Shift(S83)
    //   "StringLiteral" -> Shift(S52)
    //   "@R" -> Shift(S90)
    //
    //   MacroId -> S81
    //   SymbolKind1 -> S87
    //   StringLiteral -> S85
    //   QuotedTerminal -> S88
    //   Escape -> S82
    pub fn __state147<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state89(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state79(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state84(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state86(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state83(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state90(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state81(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state87(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state85(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state88(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state82(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 148
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   ">" -> Shift(S159)
    //   "*" -> Shift(S92)
    //   "?" -> Shift(S91)
    //   "+" -> Shift(S93)
    //
    //   RepeatOp -> S94
    pub fn __state148<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state159(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state92(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state91(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state93(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state94(text, __lookbehind, __lookahead, __tokens, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 149
    //   (<Symbol> ",") = Symbol "," (*) ["("]
    //   (<Symbol> ",") = Symbol "," (*) ["<"]
    //   (<Symbol> ",") = Symbol "," (*) [">"]
    //   (<Symbol> ",") = Symbol "," (*) ["@L"]
    //   (<Symbol> ",") = Symbol "," (*) ["@R"]
    //   (<Symbol> ",") = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",") = Symbol "," (*) ["Id"]
    //   (<Symbol> ",") = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",") = Symbol "," (*) ["StringLiteral"]
    //
    //   "<" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "MacroId" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "StringLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "Escape" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   ">" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "Id" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "@R" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "(" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "@L" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //
    pub fn __state149<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action150(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 150
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R [EOF]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["Escape"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["Id"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["MacroId"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["extern"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["pub"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["use"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R [EOF]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["extern"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["pub"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["use"]
    //   Alternatives = (*) Alternative [EOF]
    //   Alternatives = (*) Alternative ["Escape"]
    //   Alternatives = (*) Alternative ["Id"]
    //   Alternatives = (*) Alternative ["MacroId"]
    //   Alternatives = (*) Alternative ["extern"]
    //   Alternatives = (*) Alternative ["pub"]
    //   Alternatives = (*) Alternative ["use"]
    //   Alternatives = (*) "{" Alternative* "}" ";" [EOF]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["Id"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["extern"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["pub"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["use"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives [EOF]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["use"]
    //
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "=>" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "{" -> Shift(S162)
    //   "if" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "=>?" -> Reduce(@L =  => Lookahead;)
    //
    //   Alternatives -> S161
    //   @L -> S163
    //   Alternative -> S160
    pub fn __state150<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<TypeRef>>,
        __sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state162(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Alternatives(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state161(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state163(text, __lookbehind, __lookahead, __tokens, __sym6));
                }
                __Nonterminal::Alternative(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state160(text, __lookbehind, __lookahead, __tokens, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 151
    //   (":" <TypeRef>) = ":" TypeRef (*) ["="]
    //
    //   "=" -> Reduce((":" <TypeRef>) = ":", TypeRef => Call(ActionFn(114));)
    //
    pub fn __state151<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action114(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 152
    //   (<NotMacroId> ",") = NotMacroId (*) "," [">"]
    //   (<NotMacroId> ",") = NotMacroId (*) "," ["Id"]
    //   NotMacroId? = NotMacroId (*) [">"]
    //
    //   ">" -> Reduce(NotMacroId? = NotMacroId => Call(ActionFn(141));)
    //   "," -> Shift(S164)
    //
    pub fn __state152<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state164(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action141(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NotMacroId_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 153
    //   (<NotMacroId> ",")* = (<NotMacroId> ",")* (<NotMacroId> ",") (*) [">"]
    //   (<NotMacroId> ",")* = (<NotMacroId> ",")* (<NotMacroId> ",") (*) ["Id"]
    //
    //   "Id" -> Reduce((<NotMacroId> ",")* = (<NotMacroId> ",")*, (<NotMacroId> ",") => Call(ActionFn(144));)
    //   ">" -> Reduce((<NotMacroId> ",")* = (<NotMacroId> ",")*, (<NotMacroId> ",") => Call(ActionFn(144));)
    //
    pub fn __state153<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
        __sym1: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 154
    //   Comma<NotMacroId> = (<NotMacroId> ",")* NotMacroId? (*) [">"]
    //
    //   ">" -> Reduce(Comma<NotMacroId> = (<NotMacroId> ",")*, NotMacroId? => Call(ActionFn(111));)
    //
    pub fn __state154<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
        __sym1: &mut Option<::std::option::Option<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action111(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cNotMacroId_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 155
    //   NonterminalName = MacroId "<" Comma<NotMacroId> ">" (*) [":"]
    //   NonterminalName = MacroId "<" Comma<NotMacroId> ">" (*) ["="]
    //
    //   "=" -> Reduce(NonterminalName = MacroId, "<", Comma<NotMacroId>, ">" => Call(ActionFn(15));)
    //   ":" -> Reduce(NonterminalName = MacroId, "<", Comma<NotMacroId>, ">" => Call(ActionFn(15));)
    //
    pub fn __state155<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<NonterminalString>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) |
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action15(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 156
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["type"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["}"]
    //
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S165
    pub fn __state156<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state165(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 157
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["enum"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["type"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["type"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["}"]
    //
    //   "enum" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(87));)
    //   "}" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(87));)
    //   "type" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(87));)
    //
    pub fn __state157<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym1: &mut Option<AssociatedType>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Enum(..), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::Type(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action87(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 158
    //   @L = (*) ["#"]
    //   @L = (*) ["&"]
    //   @L = (*) ["("]
    //   @L = (*) ["::"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "&" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "#" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S166
    pub fn __state158<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state166(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 159
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["if"]
    //
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S167
    pub fn __state159<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state167(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 160
    //   Alternatives = Alternative (*) [EOF]
    //   Alternatives = Alternative (*) ["Escape"]
    //   Alternatives = Alternative (*) ["Id"]
    //   Alternatives = Alternative (*) ["MacroId"]
    //   Alternatives = Alternative (*) ["extern"]
    //   Alternatives = Alternative (*) ["pub"]
    //   Alternatives = Alternative (*) ["use"]
    //
    //   "Escape" -> Reduce(Alternatives = Alternative => Call(ActionFn(18));)
    //   "extern" -> Reduce(Alternatives = Alternative => Call(ActionFn(18));)
    //   "Id" -> Reduce(Alternatives = Alternative => Call(ActionFn(18));)
    //   "use" -> Reduce(Alternatives = Alternative => Call(ActionFn(18));)
    //   "pub" -> Reduce(Alternatives = Alternative => Call(ActionFn(18));)
    //   "MacroId" -> Reduce(Alternatives = Alternative => Call(ActionFn(18));)
    //   EOF -> Reduce(Alternatives = Alternative => Call(ActionFn(18));)
    //
    pub fn __state160<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action18(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 161
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) [EOF]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["use"]
    //
    //   "Escape" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "extern" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "Id" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "use" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "MacroId" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   EOF -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "pub" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //
    pub fn __state161<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<TypeRef>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            None |
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action14(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Nonterminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 162
    //   Alternative* = (*) ["("]
    //   Alternative* = (*) ["<"]
    //   Alternative* = (*) ["=>"]
    //   Alternative* = (*) ["=>?"]
    //   Alternative* = (*) ["=>@L"]
    //   Alternative* = (*) ["=>@R"]
    //   Alternative* = (*) ["@L"]
    //   Alternative* = (*) ["@R"]
    //   Alternative* = (*) ["Escape"]
    //   Alternative* = (*) ["Id"]
    //   Alternative* = (*) ["MacroId"]
    //   Alternative* = (*) ["StringLiteral"]
    //   Alternative* = (*) ["if"]
    //   Alternative* = (*) ["}"]
    //   Alternative* = (*) Alternative* Alternative ["("]
    //   Alternative* = (*) Alternative* Alternative ["<"]
    //   Alternative* = (*) Alternative* Alternative ["=>"]
    //   Alternative* = (*) Alternative* Alternative ["=>?"]
    //   Alternative* = (*) Alternative* Alternative ["=>@L"]
    //   Alternative* = (*) Alternative* Alternative ["=>@R"]
    //   Alternative* = (*) Alternative* Alternative ["@L"]
    //   Alternative* = (*) Alternative* Alternative ["@R"]
    //   Alternative* = (*) Alternative* Alternative ["Escape"]
    //   Alternative* = (*) Alternative* Alternative ["Id"]
    //   Alternative* = (*) Alternative* Alternative ["MacroId"]
    //   Alternative* = (*) Alternative* Alternative ["StringLiteral"]
    //   Alternative* = (*) Alternative* Alternative ["if"]
    //   Alternative* = (*) Alternative* Alternative ["}"]
    //   Alternatives = "{" (*) Alternative* "}" ";" [EOF]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["Escape"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["Id"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["MacroId"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["extern"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["pub"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["use"]
    //
    //   "=>" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "=>@L" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "@L" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "<" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "}" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "(" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "=>@R" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "MacroId" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "=>?" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "StringLiteral" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "Escape" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "Id" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "@R" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //   "if" -> Reduce(Alternative* =  => Call(ActionFn(109));)
    //
    //   Alternative* -> S168
    pub fn __state162<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::If(..), _)) => {
                let __nt = super::__action109(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Alternative_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state168(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 163
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R [EOF]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["Escape"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["Id"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["MacroId"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["extern"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["pub"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["use"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R [EOF]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["extern"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["pub"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["use"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [";"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["=>"]
    //   Symbol+ = (*) Symbol ["=>?"]
    //   Symbol+ = (*) Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["if"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [";"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>?"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["("]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["<"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["=>"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["=>?"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["=>@L"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["=>@R"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["@L"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["@R"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["Escape"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["Id"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["MacroId"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["StringLiteral"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["if"]
    //   Alternative = @L (*) ("if" <Cond>)? Action ";" @R ["}"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["("]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["<"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["=>"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["=>?"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["=>@L"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["=>@R"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["@L"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["@R"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["StringLiteral"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["if"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? ";" @R ["}"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [";"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["=>"]
    //   Symbol+ = (*) Symbol ["=>?"]
    //   Symbol+ = (*) Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["if"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [";"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>?"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //
    //   "=>" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Shift(S173)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "=>?" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //
    //   Symbol0 -> S58
    //   ("if" <Cond>)? -> S171
    //   Symbol -> S169
    //   Symbol+ -> S172
    //   Symbol1 -> S60
    //   ("if" <Cond>) -> S170
    //   @L -> S57
    pub fn __state163<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::If(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state173(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = super::__action105(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state171(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state169(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol_2b(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state172(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state170(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 164
    //   (<NotMacroId> ",") = NotMacroId "," (*) [">"]
    //   (<NotMacroId> ",") = NotMacroId "," (*) ["Id"]
    //
    //   "Id" -> Reduce((<NotMacroId> ",") = NotMacroId, "," => Call(ActionFn(145));)
    //   ">" -> Reduce((<NotMacroId> ",") = NotMacroId, "," => Call(ActionFn(145));)
    //
    pub fn __state164<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action145(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 165
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["type"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["="]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["}"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["="]
    //
    //   "Id" -> Shift(S25)
    //   "MacroId" -> Shift(S24)
    //
    //   Id -> S174
    pub fn __state165<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state25(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state24(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state174(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 166
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "#" -> Shift(S47)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "&" -> Shift(S49)
    //   "::" -> Shift(S48)
    //   "(" -> Shift(S44)
    //
    //   "::"? -> S45
    //   Path -> S46
    //   TypeRef -> S175
    pub fn __state166<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym7 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym7));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym7 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym7));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym7 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym7));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym7 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym7));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym7));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym7));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state175(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 167
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["if"]
    //
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "=>@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "=>@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "=>?" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "if" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "=>" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   ";" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //
    pub fn __state167<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 168
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["("]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["<"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["=>"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["=>?"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["=>@L"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["=>@R"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["@L"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["@R"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["Escape"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["Id"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["MacroId"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["StringLiteral"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["if"]
    //   Alternative = (*) @L ("if" <Cond>)? Action ";" @R ["}"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["("]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["<"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["=>"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["=>?"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["=>@L"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["=>@R"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["@L"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["@R"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["StringLiteral"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["if"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? ";" @R ["}"]
    //   Alternative* = Alternative* (*) Alternative ["("]
    //   Alternative* = Alternative* (*) Alternative ["<"]
    //   Alternative* = Alternative* (*) Alternative ["=>"]
    //   Alternative* = Alternative* (*) Alternative ["=>?"]
    //   Alternative* = Alternative* (*) Alternative ["=>@L"]
    //   Alternative* = Alternative* (*) Alternative ["=>@R"]
    //   Alternative* = Alternative* (*) Alternative ["@L"]
    //   Alternative* = Alternative* (*) Alternative ["@R"]
    //   Alternative* = Alternative* (*) Alternative ["Escape"]
    //   Alternative* = Alternative* (*) Alternative ["Id"]
    //   Alternative* = Alternative* (*) Alternative ["MacroId"]
    //   Alternative* = Alternative* (*) Alternative ["StringLiteral"]
    //   Alternative* = Alternative* (*) Alternative ["if"]
    //   Alternative* = Alternative* (*) Alternative ["}"]
    //   Alternatives = "{" Alternative* (*) "}" ";" [EOF]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["Escape"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["Id"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["MacroId"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["extern"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["pub"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["use"]
    //
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "=>" -> Reduce(@L =  => Lookahead;)
    //   "=>?" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(@L =  => Lookahead;)
    //   "}" -> Shift(S177)
    //   "if" -> Reduce(@L =  => Lookahead;)
    //
    //   Alternative -> S176
    //   @L -> S163
    pub fn __state168<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state177(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::If(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Alternative(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state176(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state163(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 169
    //   Symbol+ = Symbol (*) ["("]
    //   Symbol+ = Symbol (*) [";"]
    //   Symbol+ = Symbol (*) ["<"]
    //   Symbol+ = Symbol (*) ["=>"]
    //   Symbol+ = Symbol (*) ["=>?"]
    //   Symbol+ = Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol (*) ["@L"]
    //   Symbol+ = Symbol (*) ["@R"]
    //   Symbol+ = Symbol (*) ["Escape"]
    //   Symbol+ = Symbol (*) ["Id"]
    //   Symbol+ = Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol (*) ["if"]
    //
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   ";" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "(" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "=>@L" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "MacroId" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "=>" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "Escape" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "Id" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "@L" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "=>?" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "@R" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "if" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "<" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //   "=>@R" -> Reduce(Symbol+ = Symbol => Call(ActionFn(107));)
    //
    pub fn __state169<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action107(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2b(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 170
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>?"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@L"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@R"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) [";"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>?"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@L"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@R"]
    //
    //   "=>?" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(104));)
    //   "=>@R" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(104));)
    //   "=>" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(104));)
    //   ";" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(104));)
    //   "=>@L" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(104));)
    //
    pub fn __state170<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Condition>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action104(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 171
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R [EOF]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["Escape"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["Id"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["MacroId"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["extern"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["pub"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["use"]
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["("]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["<"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["=>"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["=>?"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["=>@L"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["=>@R"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["@L"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["@R"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["Escape"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["Id"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["MacroId"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["StringLiteral"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["if"]
    //   Alternative = @L ("if" <Cond>)? (*) Action ";" @R ["}"]
    //
    //   "=>@R" -> Shift(S180)
    //   "=>@L" -> Shift(S179)
    //   "=>?" -> Shift(S178)
    //   "=>" -> Shift(S182)
    //
    //   Action -> S181
    pub fn __state171<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::option::Option<Condition>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::EqualsGreaterThanLookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state180(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::EqualsGreaterThanLookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state179(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state178(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::EqualsGreaterThanCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state182(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Action(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state181(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 172
    //   ("if" <Cond>) = (*) "if" Cond [";"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) [";"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) [";"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R [EOF]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["extern"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["pub"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["use"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [";"]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>?"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   ("if" <Cond>) = (*) "if" Cond [";"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) [";"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) [";"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["("]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["<"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["=>"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["=>?"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["=>@L"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["=>@R"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["@L"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["@R"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["StringLiteral"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["if"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? ";" @R ["}"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [";"]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>?"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //
    //   "=>" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ";" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "=>?" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(105));)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Shift(S173)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   ("if" <Cond>) -> S170
    //   ("if" <Cond>)? -> S183
    //   @L -> S57
    //   Symbol0 -> S58
    //   Symbol -> S184
    //   Symbol1 -> S60
    pub fn __state172<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::If(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state173(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = super::__action105(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state170(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state183(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state184(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 173
    //   ("if" <Cond>) = "if" (*) Cond ["=>"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>?"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@L"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@R"]
    //   @L = (*) ["Id"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   ("if" <Cond>) = "if" (*) Cond [";"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>?"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@L"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@R"]
    //   @L = (*) ["Id"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R [";"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   Cond -> S186
    //   @L -> S185
    pub fn __state173<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Cond(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state186(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state185(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 174
    //   @R = (*) ["="]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["type"]
    //   @R = (*) ["="]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["}"]
    //
    //   "=" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S187
    pub fn __state174<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state187(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 175
    //   @R = (*) ["{"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "{" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S188
    pub fn __state175<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<usize>,
        __sym7: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym7.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym8 = &mut Some(__nt);
                    __result = try!(__state188(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 176
    //   Alternative* = Alternative* Alternative (*) ["("]
    //   Alternative* = Alternative* Alternative (*) ["<"]
    //   Alternative* = Alternative* Alternative (*) ["=>"]
    //   Alternative* = Alternative* Alternative (*) ["=>?"]
    //   Alternative* = Alternative* Alternative (*) ["=>@L"]
    //   Alternative* = Alternative* Alternative (*) ["=>@R"]
    //   Alternative* = Alternative* Alternative (*) ["@L"]
    //   Alternative* = Alternative* Alternative (*) ["@R"]
    //   Alternative* = Alternative* Alternative (*) ["Escape"]
    //   Alternative* = Alternative* Alternative (*) ["Id"]
    //   Alternative* = Alternative* Alternative (*) ["MacroId"]
    //   Alternative* = Alternative* Alternative (*) ["StringLiteral"]
    //   Alternative* = Alternative* Alternative (*) ["if"]
    //   Alternative* = Alternative* Alternative (*) ["}"]
    //
    //   "=>" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "}" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "if" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "=>?" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "<" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "@R" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "(" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "MacroId" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "StringLiteral" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "=>@R" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "Id" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "=>@L" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "@L" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //   "Escape" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(110));)
    //
    pub fn __state176<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Alternative>>,
        __sym1: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action110(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 177
    //   Alternatives = "{" Alternative* "}" (*) ";" [EOF]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["Escape"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["Id"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["MacroId"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["extern"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["pub"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["use"]
    //
    //   ";" -> Shift(S189)
    //
    pub fn __state177<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Alternative>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state189(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 178
    //   Action = "=>?" (*) [";"]
    //
    //   ";" -> Reduce(Action = "=>?" => Call(ActionFn(25));)
    //
    pub fn __state178<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action25(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 179
    //   Action = "=>@L" (*) [";"]
    //
    //   ";" -> Reduce(Action = "=>@L" => Call(ActionFn(22));)
    //
    pub fn __state179<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action22(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 180
    //   Action = "=>@R" (*) [";"]
    //
    //   ";" -> Reduce(Action = "=>@R" => Call(ActionFn(23));)
    //
    pub fn __state180<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action23(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 181
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R [EOF]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["Escape"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["Id"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["MacroId"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["extern"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["pub"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["use"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["("]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["<"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["=>"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["=>?"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["=>@L"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["=>@R"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["@L"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["@R"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["Escape"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["Id"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["MacroId"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["StringLiteral"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["if"]
    //   Alternative = @L ("if" <Cond>)? Action (*) ";" @R ["}"]
    //
    //   ";" -> Shift(S190)
    //
    pub fn __state181<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::option::Option<Condition>>,
        __sym2: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state190(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 182
    //   Action = "=>" (*) [";"]
    //
    //   ";" -> Reduce(Action = "=>" => Call(ActionFn(24));)
    //
    pub fn __state182<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action24(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 183
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Action? = (*) [";"]
    //   Action? = (*) Action [";"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R [EOF]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["Escape"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["Id"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["MacroId"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["extern"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["pub"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["use"]
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Action? = (*) [";"]
    //   Action? = (*) Action [";"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["("]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["<"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["=>"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["=>?"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["=>@L"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["=>@R"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["@L"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["@R"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["Escape"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["Id"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["MacroId"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["StringLiteral"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["if"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? ";" @R ["}"]
    //
    //   "=>@R" -> Shift(S180)
    //   "=>@L" -> Shift(S179)
    //   ";" -> Reduce(Action? =  => Call(ActionFn(103));)
    //   "=>?" -> Shift(S178)
    //   "=>" -> Shift(S182)
    //
    //   Action? -> S191
    //   Action -> S192
    pub fn __state183<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::EqualsGreaterThanLookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state180(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::EqualsGreaterThanLookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state179(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state178(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::EqualsGreaterThanCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state182(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action103(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Action_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Action_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state191(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Action(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state192(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 184
    //   Symbol+ = Symbol+ Symbol (*) ["("]
    //   Symbol+ = Symbol+ Symbol (*) [";"]
    //   Symbol+ = Symbol+ Symbol (*) ["<"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>?"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["Escape"]
    //   Symbol+ = Symbol+ Symbol (*) ["Id"]
    //   Symbol+ = Symbol+ Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol+ Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["if"]
    //
    //   "Id" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "=>" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "=>?" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "Escape" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "@R" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "(" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   ";" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "=>@R" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "=>@L" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "MacroId" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "<" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "@L" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //   "if" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(108));)
    //
    pub fn __state184<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action108(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2b(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 185
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   NotMacroId = (*) "Id" ["!="]
    //   NotMacroId = (*) "Id" ["!~"]
    //   NotMacroId = (*) "Id" ["=="]
    //   NotMacroId = (*) "Id" ["~~"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R [";"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   NotMacroId = (*) "Id" ["!="]
    //   NotMacroId = (*) "Id" ["!~"]
    //   NotMacroId = (*) "Id" ["=="]
    //   NotMacroId = (*) "Id" ["~~"]
    //
    //   "Id" -> Shift(S118)
    //
    //   NotMacroId -> S193
    pub fn __state185<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state118(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::NotMacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state193(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 186
    //   ("if" <Cond>) = "if" Cond (*) ["=>"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>?"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@L"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@R"]
    //   ("if" <Cond>) = "if" Cond (*) [";"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>?"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@L"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@R"]
    //
    //   "=>" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(106));)
    //   "=>@L" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(106));)
    //   ";" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(106));)
    //   "=>?" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(106));)
    //   "=>@R" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(106));)
    //
    pub fn __state186<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Condition>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action106(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 187
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["}"]
    //
    //   "=" -> Shift(S194)
    //
    pub fn __state187<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Equals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state194(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 188
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "{" -> Shift(S195)
    //
    pub fn __state188<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<usize>,
        __sym7: &mut Option<TypeRef>,
        __sym8: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym9 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state195(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 189
    //   Alternatives = "{" Alternative* "}" ";" (*) [EOF]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["Escape"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["Id"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["MacroId"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["extern"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["pub"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["use"]
    //
    //   "Id" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(19));)
    //   "use" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(19));)
    //   "extern" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(19));)
    //   EOF -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(19));)
    //   "MacroId" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(19));)
    //   "pub" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(19));)
    //   "Escape" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(19));)
    //
    pub fn __state189<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Alternative>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            None |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action19(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 190
    //   @R = (*) [EOF]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["extern"]
    //   @R = (*) ["pub"]
    //   @R = (*) ["use"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R [EOF]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["Escape"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["Id"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["MacroId"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["extern"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["pub"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["use"]
    //   @R = (*) ["("]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["("]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["<"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["=>"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["=>?"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["=>@L"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["=>@R"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["@L"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["@R"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["Escape"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["Id"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["MacroId"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["StringLiteral"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["if"]
    //   Alternative = @L ("if" <Cond>)? Action ";" (*) @R ["}"]
    //
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "extern" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "pub" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   EOF -> Reduce(@R =  => Lookbehind;)
    //   "use" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S196
    pub fn __state190<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::option::Option<Condition>>,
        __sym2: &mut Option<ActionKind>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            None |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state196(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 191
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R [EOF]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["Escape"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["Id"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["MacroId"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["extern"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["pub"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["use"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["("]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["<"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["=>"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["=>?"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["=>@L"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["=>@R"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["@L"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["@R"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["Escape"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["Id"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["MacroId"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["StringLiteral"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["if"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) ";" @R ["}"]
    //
    //   ";" -> Shift(S197)
    //
    pub fn __state191<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state197(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 192
    //   Action? = Action (*) [";"]
    //
    //   ";" -> Reduce(Action? = Action => Call(ActionFn(102));)
    //
    pub fn __state192<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action102(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 193
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@R"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R [";"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@R"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //
    //   "!~" -> Shift(S200)
    //   "==" -> Shift(S201)
    //   "~~" -> Shift(S199)
    //   "!=" -> Shift(S198)
    //
    //   CondOp -> S202
    pub fn __state193<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::BangTilde(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state200(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::EqualsEquals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state201(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::TildeTilde(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state199(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::BangEquals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state198(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::CondOp(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state202(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 194
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["type"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["}"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "::" -> Shift(S48)
    //   "#" -> Shift(S47)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "(" -> Shift(S44)
    //   "&" -> Shift(S49)
    //
    //   Path -> S46
    //   TypeRef -> S203
    //   "::"? -> S45
    pub fn __state194<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Path(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state203(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 195
    //   (<Conversion> ",")* = (*) ["Id"]
    //   (<Conversion> ",")* = (*) ["StringLiteral"]
    //   (<Conversion> ",")* = (*) ["}"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["Id"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["StringLiteral"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["}"]
    //   Comma<Conversion> = (*) (<Conversion> ",")* Conversion? ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "}" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(163));)
    //   "Id" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(163));)
    //   "StringLiteral" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(163));)
    //
    //   (<Conversion> ",")* -> S205
    //   Comma<Conversion> -> S204
    pub fn __state195<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<usize>,
        __sym7: &mut Option<TypeRef>,
        __sym8: &mut Option<usize>,
        __sym9: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action163(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym9.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym10 = &mut Some(__nt);
                    __result = try!(__state205(text, __lookbehind, __lookahead, __tokens, __sym10));
                }
                __Nonterminal::Comma_3cConversion_3e(__nt) => {
                    let __sym10 = &mut Some(__nt);
                    __result = try!(__state204(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 196
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) [EOF]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["Escape"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["Id"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["MacroId"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["extern"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["pub"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["use"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["("]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["<"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["=>"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["=>?"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["=>@L"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["=>@R"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["@L"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["@R"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["Escape"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["Id"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["MacroId"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["StringLiteral"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["if"]
    //   Alternative = @L ("if" <Cond>)? Action ";" @R (*) ["}"]
    //
    //   "}" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "StringLiteral" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "(" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "Escape" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "=>@L" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "pub" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "=>?" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "if" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "=>" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "MacroId" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "<" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "extern" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "use" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "Id" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "@R" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   EOF -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "=>@R" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //   "@L" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, ";", @R => Call(ActionFn(21));)
    //
    pub fn __state196<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::option::Option<Condition>>,
        __sym2: &mut Option<ActionKind>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            None |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action21(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 197
    //   @R = (*) [EOF]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["extern"]
    //   @R = (*) ["pub"]
    //   @R = (*) ["use"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R [EOF]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["Escape"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["Id"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["MacroId"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["extern"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["pub"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["use"]
    //   @R = (*) ["("]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["("]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["<"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["=>"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["=>?"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["=>@L"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["=>@R"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["@L"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["@R"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["Escape"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["Id"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["MacroId"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["StringLiteral"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["if"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" (*) @R ["}"]
    //
    //   "extern" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   EOF -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "use" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "pub" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S206
    pub fn __state197<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            None |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::If(..), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Pub(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state206(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 198
    //   CondOp = "!=" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "!=" => Call(ActionFn(28));)
    //
    pub fn __state198<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action28(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::CondOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 199
    //   CondOp = "~~" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "~~" => Call(ActionFn(29));)
    //
    pub fn __state199<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action29(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::CondOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 200
    //   CondOp = "!~" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "!~" => Call(ActionFn(30));)
    //
    pub fn __state200<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::CondOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 201
    //   CondOp = "==" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "==" => Call(ActionFn(27));)
    //
    pub fn __state201<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action27(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::CondOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 202
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R [";"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" [";"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //
    //   "StringLiteral" -> Shift(S52)
    //
    //   StringLiteral -> S207
    pub fn __state202<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<NonterminalString>,
        __sym2: &mut Option<ConditionOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state207(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 203
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["enum"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["}"]
    //
    //   ";" -> Shift(S208)
    //
    pub fn __state203<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state208(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 204
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["use"]
    //
    //   "}" -> Shift(S209)
    //
    pub fn __state204<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<usize>,
        __sym7: &mut Option<TypeRef>,
        __sym8: &mut Option<usize>,
        __sym9: &mut Option<Tok<'input>>,
        __sym10: &mut Option<Vec<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym11 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state209(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 205
    //   (<Conversion> ",") = (*) Conversion "," ["Id"]
    //   (<Conversion> ",") = (*) Conversion "," ["StringLiteral"]
    //   (<Conversion> ",") = (*) Conversion "," ["}"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["Id"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["StringLiteral"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Conversion> = (<Conversion> ",")* (*) Conversion? ["}"]
    //   Conversion = (*) @L Terminal @L "=>" @R [","]
    //   Conversion = (*) @L Terminal @L "=>" @R ["}"]
    //   Conversion? = (*) ["}"]
    //   Conversion? = (*) Conversion ["}"]
    //
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "}" -> Reduce(Conversion? =  => Call(ActionFn(162));)
    //
    //   @L -> S213
    //   (<Conversion> ",") -> S210
    //   Conversion? -> S211
    //   Conversion -> S212
    pub fn __state205<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action162(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Conversion_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state213(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state210(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Conversion_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state211(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Conversion(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state212(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 206
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) [EOF]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["Escape"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["Id"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["MacroId"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["extern"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["pub"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["use"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["("]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["<"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["=>"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["=>?"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["=>@L"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["=>@R"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["@L"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["@R"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["Escape"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["Id"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["MacroId"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["StringLiteral"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["if"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? ";" @R (*) ["}"]
    //
    //   "MacroId" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "Escape" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "use" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "}" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "pub" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "=>@L" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "extern" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "(" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "@L" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "@R" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "StringLiteral" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "Id" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "=>" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "if" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   EOF -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "=>?" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "<" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //   "=>@R" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(20));)
    //
    pub fn __state206<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Use(_), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::If(..), _)) |
            None |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action20(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 207
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@R"]
    //   @R = (*) [";"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R [";"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@R"]
    //
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S214
    pub fn __state207<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<NonterminalString>,
        __sym2: &mut Option<ConditionOp>,
        __sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state214(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 208
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["enum"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["}"]
    //
    //   "enum" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(57));)
    //   "type" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(57));)
    //   "}" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(57));)
    //
    pub fn __state208<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<TypeRef>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Enum(..), _)) |
            Some((_, Tok::Type(..), _)) |
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action57(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 209
    //   AssociatedType* = (*) ["type"]
    //   AssociatedType* = (*) ["}"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["type"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["use"]
    //
    //   "type" -> Reduce(AssociatedType* =  => Call(ActionFn(86));)
    //   "}" -> Reduce(AssociatedType* =  => Call(ActionFn(86));)
    //
    //   AssociatedType* -> S215
    pub fn __state209<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<usize>,
        __sym7: &mut Option<TypeRef>,
        __sym8: &mut Option<usize>,
        __sym9: &mut Option<Tok<'input>>,
        __sym10: &mut Option<Vec<Conversion>>,
        __sym11: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Type(..), _)) |
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action86(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym11.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AssociatedType_2a(__nt) => {
                    let __sym12 = &mut Some(__nt);
                    __result = try!(__state215(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 210
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["Id"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["StringLiteral"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["}"]
    //
    //   "StringLiteral" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(164));)
    //   "Id" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(164));)
    //   "}" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(164));)
    //
    pub fn __state210<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Conversion>>,
        __sym1: &mut Option<Conversion>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action164(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 211
    //   Comma<Conversion> = (<Conversion> ",")* Conversion? (*) ["}"]
    //
    //   "}" -> Reduce(Comma<Conversion> = (<Conversion> ",")*, Conversion? => Call(ActionFn(85));)
    //
    pub fn __state211<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Conversion>>,
        __sym1: &mut Option<::std::option::Option<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action85(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cConversion_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 212
    //   (<Conversion> ",") = Conversion (*) "," ["Id"]
    //   (<Conversion> ",") = Conversion (*) "," ["StringLiteral"]
    //   (<Conversion> ",") = Conversion (*) "," ["}"]
    //   Conversion? = Conversion (*) ["}"]
    //
    //   "," -> Shift(S216)
    //   "}" -> Reduce(Conversion? = Conversion => Call(ActionFn(161));)
    //
    pub fn __state212<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Conversion>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state216(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action161(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Conversion_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 213
    //   Conversion = @L (*) Terminal @L "=>" @R [","]
    //   Conversion = @L (*) Terminal @L "=>" @R ["}"]
    //   QuotedTerminal = (*) StringLiteral ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   Terminal = (*) QuotedTerminal ["=>"]
    //   Terminal = (*) "Id" ["=>"]
    //
    //   "StringLiteral" -> Shift(S52)
    //   "Id" -> Shift(S217)
    //
    //   Terminal -> S218
    //   QuotedTerminal -> S219
    //   StringLiteral -> S85
    pub fn __state213<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state217(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Terminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state218(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state219(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state85(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 214
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) [";"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@R"]
    //
    //   "=>" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(26));)
    //   "=>@R" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(26));)
    //   "=>?" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(26));)
    //   ";" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(26));)
    //   "=>@L" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(26));)
    //
    pub fn __state214<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<NonterminalString>,
        __sym2: &mut Option<ConditionOp>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::Semi(..), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action26(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Cond(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 215
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["type"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["use"]
    //
    //   "}" -> Shift(S220)
    //   "type" -> Shift(S156)
    //
    //   AssociatedType -> S157
    pub fn __state215<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<usize>,
        __sym7: &mut Option<TypeRef>,
        __sym8: &mut Option<usize>,
        __sym9: &mut Option<Tok<'input>>,
        __sym10: &mut Option<Vec<Conversion>>,
        __sym11: &mut Option<Tok<'input>>,
        __sym12: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym13 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state220(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13));
            }
            Some((_, __tok @ Tok::Type(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym13 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state156(text, __lookbehind, __lookahead, __tokens, __sym13));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym12.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AssociatedType(__nt) => {
                    let __sym13 = &mut Some(__nt);
                    __result = try!(__state157(text, __lookbehind, __lookahead, __tokens, __sym12, __sym13));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 216
    //   (<Conversion> ",") = Conversion "," (*) ["Id"]
    //   (<Conversion> ",") = Conversion "," (*) ["StringLiteral"]
    //   (<Conversion> ",") = Conversion "," (*) ["}"]
    //
    //   "StringLiteral" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(165));)
    //   "}" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(165));)
    //   "Id" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(165));)
    //
    pub fn __state216<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Conversion>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action165(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 217
    //   Terminal = "Id" (*) ["=>"]
    //
    //   "=>" -> Reduce(Terminal = "Id" => Call(ActionFn(76));)
    //
    pub fn __state217<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action76(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 218
    //   @L = (*) ["=>"]
    //   Conversion = @L Terminal (*) @L "=>" @R [","]
    //   Conversion = @L Terminal (*) @L "=>" @R ["}"]
    //
    //   "=>" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S221
    pub fn __state218<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state221(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 219
    //   Terminal = QuotedTerminal (*) ["=>"]
    //
    //   "=>" -> Reduce(Terminal = QuotedTerminal => Call(ActionFn(75));)
    //
    pub fn __state219<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action75(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 220
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["use"]
    //
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(56));)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(56));)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(56));)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(56));)
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(56));)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(56));)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(56));)
    //
    pub fn __state220<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<usize>,
        __sym7: &mut Option<TypeRef>,
        __sym8: &mut Option<usize>,
        __sym9: &mut Option<Tok<'input>>,
        __sym10: &mut Option<Vec<Conversion>>,
        __sym11: &mut Option<Tok<'input>>,
        __sym12: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym13: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Pub(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Extern(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            None |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Use(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __sym10 = __sym10.take().unwrap();
                let __sym11 = __sym11.take().unwrap();
                let __sym12 = __sym12.take().unwrap();
                let __sym13 = __sym13.take().unwrap();
                let __nt = super::__action56(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExternToken(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 221
    //   Conversion = @L Terminal @L (*) "=>" @R [","]
    //   Conversion = @L Terminal @L (*) "=>" @R ["}"]
    //
    //   "=>" -> Shift(S222)
    //
    pub fn __state221<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<TerminalString>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state222(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 222
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Conversion = @L Terminal @L "=>" (*) @R [","]
    //   Conversion = @L Terminal @L "=>" (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S223
    pub fn __state222<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<TerminalString>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state223(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 223
    //   Conversion = @L Terminal @L "=>" @R (*) [","]
    //   Conversion = @L Terminal @L "=>" @R (*) ["}"]
    //
    //   "}" -> Reduce(Conversion = @L, Terminal, @L, "=>", @R => TryCall(ActionFn(58));)
    //   "," -> Reduce(Conversion = @L, Terminal, @L, "=>", @R => TryCall(ActionFn(58));)
    //
    pub fn __state223<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<TerminalString>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<&'input str>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = try!(super::__action58(text, __sym0, __sym1, __sym2, __sym3, __sym4));
                return Ok((__lookbehind, __lookahead, __Nonterminal::Conversion(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
#[allow(non_snake_case)]
pub fn parse_Pattern<
    'input,
    __TOKEN: __ToTriple<'input, Error=tok::Error>,
    __TOKENS: IntoIterator<Item=__TOKEN>,
>(
    text: &'input str,
    __tokens: __TOKENS,
) -> Result<Pattern<TypeRef>, __ParseError<usize,Tok<'input>,tok::Error>>
{
    let mut __tokens = __tokens.into_iter();
    let mut __tokens = __tokens.map(|t| __ToTriple::to_triple(t));
    let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
    match try!(__parse__Pattern::__state0(text, None, __lookahead, &mut __tokens)) {
        (_, Some(__lookahead), _) => {
            Err(__ParseError::ExtraToken { token: __lookahead })
        }
        (_, None, __parse__Pattern::__Nonterminal::____Pattern(__nt)) => {
            Ok(__nt)
        }
        _ => unreachable!(),
    }
}

mod __parse__Pattern {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as __lalrpop_util;
    use self::__lalrpop_util::ParseError as __ParseError;
    use super::__ToTriple;

    #[allow(dead_code)]
    pub enum __Nonterminal<'input, > {
        RepeatOp(RepeatOp),
        Algorithm_3f(::std::option::Option<Algorithm>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Path(Path),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        Alternative(Alternative),
        Terminal(TerminalString),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        Lifetime(InternedString),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        NotMacroId(NonterminalString),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        TypeParameter(TypeParameter),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        Symbol_3f(::std::option::Option<Symbol>),
        Grammar(Grammar),
        Nonterminal(GrammarItem),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        CondOp(ConditionOp),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _40R(usize),
        Symbol_2b(::std::vec::Vec<Symbol>),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        Symbol_2a(::std::vec::Vec<Symbol>),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        Alternative_2a(::std::vec::Vec<Alternative>),
        TypeRef_3f(::std::option::Option<TypeRef>),
        ____TypeRef(TypeRef),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        Conversion(Conversion),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        MacroId(NonterminalString),
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        Symbol(Symbol),
        SymbolKind1(SymbolKind),
        _28_22if_22_20_3cCond_3e_29(Condition),
        Alternatives(Vec<Alternative>),
        TypeRef(TypeRef),
        AssociatedType(AssociatedType),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        ____Grammar(Grammar),
        Lifetime_3f(::std::option::Option<InternedString>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        GrammarItem(GrammarItem),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Symbol0(Symbol),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        QuotedTerminal(TerminalString),
        Escape(InternedString),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        ExprSymbol(ExprSymbol),
        GrammarTypeParameters(Vec<TypeParameter>),
        FieldPattern(FieldPattern<TypeRef>),
        Action(ActionKind),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        ____Pattern(Pattern<TypeRef>),
        Use(GrammarItem),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        _40L(usize),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Cond(Condition),
        Algorithm(Algorithm),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        StringLiteral(InternedString),
        Pattern(Pattern<TypeRef>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        Conversion_3f(::std::option::Option<Conversion>),
        GrammarParameters(Vec<Parameter>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Id(InternedString),
        GrammarParameter(Parameter),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        TypeRefOrLifetime(TypeRef),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        Symbol1(Symbol),
        Use_2a(::std::vec::Vec<GrammarItem>),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        ExternToken(GrammarItem),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        Action_3f(::std::option::Option<ActionKind>),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        GrammarParameter_3f(::std::option::Option<Parameter>),
    }

    // State 0
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Pattern = (*) @L PatternKind @R [EOF]
    //   __Pattern = (*) Pattern [EOF]
    //
    //   "_" -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ".." -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   Pattern -> S1
    //   @L -> S2
    pub fn __state0<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Underscore(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::DotDot(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Pattern(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state1(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
    }

    // State 1
    //   __Pattern = Pattern (*) [EOF]
    //
    //   EOF -> Reduce(__Pattern = Pattern => Call(ActionFn(2));)
    //
    pub fn __state1<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action2(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::____Pattern(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 2
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [EOF]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Pattern = @L (*) PatternKind @R [EOF]
    //   PatternKind = (*) Path [EOF]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [EOF]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = (*) ".." [EOF]
    //   PatternKind = (*) "<" TypeRef ">" [EOF]
    //   PatternKind = (*) "_" [EOF]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Pattern = @L (*) PatternKind @R [")"]
    //   Pattern = @L (*) PatternKind @R [","]
    //   PatternKind = (*) Path [")"]
    //   PatternKind = (*) Path [","]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [")"]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [")"]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) ".." [")"]
    //   PatternKind = (*) ".." [","]
    //   PatternKind = (*) "<" TypeRef ">" [")"]
    //   PatternKind = (*) "<" TypeRef ">" [","]
    //   PatternKind = (*) "_" [")"]
    //   PatternKind = (*) "_" [","]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Path = (*) "::"? (<Id> "::")* Id ["}"]
    //   Pattern = @L (*) PatternKind @R [","]
    //   Pattern = @L (*) PatternKind @R ["}"]
    //   PatternKind = (*) Path [","]
    //   PatternKind = (*) Path ["}"]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" ["}"]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = (*) ".." [","]
    //   PatternKind = (*) ".." ["}"]
    //   PatternKind = (*) "<" TypeRef ">" [","]
    //   PatternKind = (*) "<" TypeRef ">" ["}"]
    //   PatternKind = (*) "_" [","]
    //   PatternKind = (*) "_" ["}"]
    //
    //   "::" -> Shift(S3)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   ".." -> Shift(S8)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "<" -> Shift(S7)
    //   "(" -> Shift(S6)
    //   "_" -> Shift(S5)
    //
    //   "::"? -> S4
    //   Path -> S10
    //   PatternKind -> S9
    pub fn __state2<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::DotDot(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state8(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state6(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Underscore(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state10(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::PatternKind(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state9(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 3
    //   "::"? = "::" (*) ["Id"]
    //   "::"? = "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce("::"? = "::" => Call(ActionFn(91));)
    //   "MacroId" -> Reduce("::"? = "::" => Call(ActionFn(91));)
    //
    pub fn __state3<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action91(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 4
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [EOF]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   Path = "::"? (*) (<Id> "::")* Id ["}"]
    //
    //   "MacroId" -> Reduce((<Id> "::")* =  => Call(ActionFn(88));)
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(88));)
    //
    //   (<Id> "::")* -> S11
    pub fn __state4<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state11(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 5
    //   PatternKind = "_" (*) [EOF]
    //   PatternKind = "_" (*) [")"]
    //   PatternKind = "_" (*) [","]
    //   PatternKind = "_" (*) [","]
    //   PatternKind = "_" (*) ["}"]
    //
    //   ")" -> Reduce(PatternKind = "_" => Call(ActionFn(63));)
    //   "}" -> Reduce(PatternKind = "_" => Call(ActionFn(63));)
    //   EOF -> Reduce(PatternKind = "_" => Call(ActionFn(63));)
    //   "," -> Reduce(PatternKind = "_" => Call(ActionFn(63));)
    //
    pub fn __state5<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            None |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action63(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 6
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [EOF]
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [","]
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [","]
    //   PatternKind = "(" (*) Comma<Pattern> ")" ["}"]
    //
    //   ")" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   ".." -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "Id" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "<" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "_" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "::" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "MacroId" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "(" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //
    //   (<Pattern> ",")* -> S13
    //   Comma<Pattern> -> S12
    pub fn __state6<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::DotDot(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Underscore(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action168(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cPattern_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state12(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 7
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [EOF]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [")"]
    //   PatternKind = "<" (*) TypeRef ">" [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [","]
    //   PatternKind = "<" (*) TypeRef ">" ["}"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "::" -> Shift(S3)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "(" -> Shift(S18)
    //   "&" -> Shift(S15)
    //   "#" -> Shift(S16)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //
    //   "::"? -> S4
    //   Path -> S17
    //   TypeRef -> S14
    pub fn __state7<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 8
    //   PatternKind = ".." (*) [EOF]
    //   PatternKind = ".." (*) [")"]
    //   PatternKind = ".." (*) [","]
    //   PatternKind = ".." (*) [","]
    //   PatternKind = ".." (*) ["}"]
    //
    //   "," -> Reduce(PatternKind = ".." => Call(ActionFn(64));)
    //   ")" -> Reduce(PatternKind = ".." => Call(ActionFn(64));)
    //   "}" -> Reduce(PatternKind = ".." => Call(ActionFn(64));)
    //   EOF -> Reduce(PatternKind = ".." => Call(ActionFn(64));)
    //
    pub fn __state8<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action64(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 9
    //   @R = (*) [EOF]
    //   Pattern = @L PatternKind (*) @R [EOF]
    //   @R = (*) [")"]
    //   @R = (*) [","]
    //   Pattern = @L PatternKind (*) @R [")"]
    //   Pattern = @L PatternKind (*) @R [","]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Pattern = @L PatternKind (*) @R [","]
    //   Pattern = @L PatternKind (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   EOF -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S19
    pub fn __state9<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<PatternKind<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            None |
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state19(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 10
    //   PatternKind = Path (*) [EOF]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [EOF]
    //   PatternKind = Path (*) [")"]
    //   PatternKind = Path (*) [","]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [")"]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = Path (*) [","]
    //   PatternKind = Path (*) ["}"]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" ["}"]
    //
    //   "," -> Reduce(PatternKind = Path => Call(ActionFn(67));)
    //   "{" -> Shift(S21)
    //   "(" -> Shift(S20)
    //   ")" -> Reduce(PatternKind = Path => Call(ActionFn(67));)
    //   "}" -> Reduce(PatternKind = Path => Call(ActionFn(67));)
    //   EOF -> Reduce(PatternKind = Path => Call(ActionFn(67));)
    //
    pub fn __state10<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state21(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state20(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 11
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id [EOF]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "Id" ["}"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Id = (*) "MacroId" ["}"]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["}"]
    //
    //   "MacroId" -> Shift(S22)
    //   "Id" -> Shift(S23)
    //
    //   (<Id> "::") -> S24
    //   Id -> S25
    pub fn __state11<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state22(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state24(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state25(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 12
    //   PatternKind = "(" Comma<Pattern> (*) ")" [EOF]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [")"]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = "(" Comma<Pattern> (*) ")" ["}"]
    //
    //   ")" -> Shift(S26)
    //
    pub fn __state12<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state26(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 13
    //   (<Pattern> ",") = (*) Pattern "," ["("]
    //   (<Pattern> ",") = (*) Pattern "," [")"]
    //   (<Pattern> ",") = (*) Pattern "," [".."]
    //   (<Pattern> ",") = (*) Pattern "," ["::"]
    //   (<Pattern> ",") = (*) Pattern "," ["<"]
    //   (<Pattern> ",") = (*) Pattern "," ["Id"]
    //   (<Pattern> ",") = (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",") = (*) Pattern "," ["_"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (<Pattern> ",")* (*) Pattern? [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   Pattern? = (*) [")"]
    //   Pattern? = (*) Pattern [")"]
    //
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   ".." -> Reduce(@L =  => Lookahead;)
    //   "_" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(Pattern? =  => Call(ActionFn(167));)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   (<Pattern> ",") -> S27
    //   Pattern? -> S29
    //   @L -> S2
    //   Pattern -> S28
    pub fn __state13<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action167(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Pattern_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::DotDot(..), _)) |
            Some((_, Tok::Underscore(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state27(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Pattern_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Pattern(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state28(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 14
    //   PatternKind = "<" TypeRef (*) ">" [EOF]
    //   PatternKind = "<" TypeRef (*) ">" [")"]
    //   PatternKind = "<" TypeRef (*) ">" [","]
    //   PatternKind = "<" TypeRef (*) ">" [","]
    //   PatternKind = "<" TypeRef (*) ">" ["}"]
    //
    //   ">" -> Shift(S30)
    //
    pub fn __state14<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 15
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "#" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce(Lifetime? =  => Call(ActionFn(97));)
    //   "Lifetime" -> Shift(S33)
    //
    //   Lifetime -> S32
    //   Lifetime? -> S31
    pub fn __state15<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state33(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Mut(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action97(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state31(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 16
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol1 -> S35
    //   Symbol0 -> S37
    //   Symbol -> S36
    //   @L -> S34
    pub fn __state16<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state36(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 17
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   ")" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   "<" -> Shift(S38)
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(52));)
    //
    pub fn __state17<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action52(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 18
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(153));)
    //
    //   Comma<TypeRef> -> S39
    //   (<TypeRef> ",")* -> S40
    pub fn __state18<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action153(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 19
    //   Pattern = @L PatternKind @R (*) [EOF]
    //   Pattern = @L PatternKind @R (*) [")"]
    //   Pattern = @L PatternKind @R (*) [","]
    //   Pattern = @L PatternKind @R (*) [","]
    //   Pattern = @L PatternKind @R (*) ["}"]
    //
    //   EOF -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(59));)
    //   ")" -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(59));)
    //   "," -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(59));)
    //   "}" -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(59));)
    //
    pub fn __state19<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<PatternKind<TypeRef>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action59(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Pattern(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 20
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [EOF]
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [","]
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [","]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" ["}"]
    //
    //   "MacroId" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "_" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "Id" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   ")" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "(" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "<" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   "::" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //   ".." -> Reduce((<Pattern> ",")* =  => Call(ActionFn(168));)
    //
    //   Comma<Pattern> -> S41
    //   (<Pattern> ",")* -> S13
    pub fn __state20<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = super::__action168(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cPattern_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 21
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["MacroId"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [EOF]
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["MacroId"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [","]
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["MacroId"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" ["}"]
    //
    //   "}" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(81));)
    //   "Id" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(81));)
    //   ".." -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(81));)
    //   "MacroId" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(81));)
    //
    //   (<FieldPattern> ",")* -> S42
    pub fn __state21<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::DotDot(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state42(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 22
    //   Id = "MacroId" (*) [EOF]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) [":"]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["}"]
    //
    //   ">" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "," -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "(" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "<" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "{" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   EOF -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   ")" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "::" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //   "}" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //
    pub fn __state22<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            None |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Colon(..), _)) |
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action72(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 23
    //   Id = "Id" (*) [EOF]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) [":"]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["}"]
    //
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "{" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   EOF -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "}" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //   "(" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //
    pub fn __state23<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::Colon(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            None |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 24
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(89));)
    //   "Id" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(89));)
    //
    pub fn __state24<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<InternedString>>,
        __sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action89(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 25
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [EOF]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   Path = "::"? (<Id> "::")* Id (*) ["}"]
    //
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "(" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "::" -> Shift(S43)
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   EOF -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "{" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //   "}" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(55));)
    //
    pub fn __state25<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            None |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LeftBrace(..), _)) |
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action55(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 26
    //   PatternKind = "(" Comma<Pattern> ")" (*) [EOF]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [")"]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = "(" Comma<Pattern> ")" (*) ["}"]
    //
    //   "}" -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => Call(ActionFn(66));)
    //   EOF -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => Call(ActionFn(66));)
    //   ")" -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => Call(ActionFn(66));)
    //   "," -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => Call(ActionFn(66));)
    //
    pub fn __state26<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<Pattern<TypeRef>>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) |
            None |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action66(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 27
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["("]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) [")"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) [".."]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["::"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["<"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["Id"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["MacroId"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["_"]
    //
    //   ")" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(169));)
    //   "<" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(169));)
    //   "(" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(169));)
    //   ".." -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(169));)
    //   "_" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(169));)
    //   "::" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(169));)
    //   "Id" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(169));)
    //   "MacroId" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(169));)
    //
    pub fn __state27<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
        __sym1: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::DotDot(..), _)) |
            Some((_, Tok::Underscore(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action169(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 28
    //   (<Pattern> ",") = Pattern (*) "," ["("]
    //   (<Pattern> ",") = Pattern (*) "," [")"]
    //   (<Pattern> ",") = Pattern (*) "," [".."]
    //   (<Pattern> ",") = Pattern (*) "," ["::"]
    //   (<Pattern> ",") = Pattern (*) "," ["<"]
    //   (<Pattern> ",") = Pattern (*) "," ["Id"]
    //   (<Pattern> ",") = Pattern (*) "," ["MacroId"]
    //   (<Pattern> ",") = Pattern (*) "," ["_"]
    //   Pattern? = Pattern (*) [")"]
    //
    //   "," -> Shift(S44)
    //   ")" -> Reduce(Pattern? = Pattern => Call(ActionFn(166));)
    //
    pub fn __state28<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action166(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Pattern_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 29
    //   Comma<Pattern> = (<Pattern> ",")* Pattern? (*) [")"]
    //
    //   ")" -> Reduce(Comma<Pattern> = (<Pattern> ",")*, Pattern? => Call(ActionFn(84));)
    //
    pub fn __state29<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
        __sym1: &mut Option<::std::option::Option<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action84(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cPattern_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 30
    //   PatternKind = "<" TypeRef ">" (*) [EOF]
    //   PatternKind = "<" TypeRef ">" (*) [")"]
    //   PatternKind = "<" TypeRef ">" (*) [","]
    //   PatternKind = "<" TypeRef ">" (*) [","]
    //   PatternKind = "<" TypeRef ">" (*) ["}"]
    //
    //   ")" -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(65));)
    //   "}" -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(65));)
    //   EOF -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(65));)
    //   "," -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(65));)
    //
    pub fn __state30<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            None |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action65(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 31
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [")"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "mut" -> Shift(S45)
    //   "#" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "MacroId" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(95));)
    //
    //   "mut"? -> S46
    pub fn __state31<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action95(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 32
    //   Lifetime? = Lifetime (*) ["#"]
    //   Lifetime? = Lifetime (*) ["&"]
    //   Lifetime? = Lifetime (*) ["("]
    //   Lifetime? = Lifetime (*) ["::"]
    //   Lifetime? = Lifetime (*) ["Id"]
    //   Lifetime? = Lifetime (*) ["MacroId"]
    //   Lifetime? = Lifetime (*) ["mut"]
    //
    //   "(" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "#" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "::" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "Id" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "MacroId" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "&" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //   "mut" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(96));)
    //
    pub fn __state32<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::Mut(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action96(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 33
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //
    //   "mut" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "(" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "::" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "&" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "#" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   ">" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //   "," -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(74));)
    //
    pub fn __state33<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Mut(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action74(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 34
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "@R" -> Shift(S47)
    //   "@L" -> Shift(S49)
    //   "(" -> Shift(S50)
    //   "Id" -> Shift(S51)
    //   "StringLiteral" -> Shift(S57)
    //   "MacroId" -> Shift(S58)
    //   "<" -> Shift(S59)
    //   "Escape" -> Shift(S56)
    //
    //   QuotedTerminal -> S55
    //   StringLiteral -> S53
    //   SymbolKind1 -> S52
    //   MacroId -> S48
    //   Escape -> S54
    pub fn __state34<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state51(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state55(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state54(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 35
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   ")" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "<" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "(" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "#" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   ">" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "," -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(35));)
    //
    pub fn __state35<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 36
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //
    //   "#" -> Shift(S60)
    //
    pub fn __state36<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 37
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "<" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "?" -> Shift(S64)
    //   "Escape" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   ">" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   ")" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "," -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "+" -> Shift(S63)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "(" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "*" -> Shift(S61)
    //   "#" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //   "Id" -> Reduce(Symbol = Symbol0 => Call(ActionFn(34));)
    //
    //   RepeatOp -> S62
    pub fn __state37<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state63(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state61(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 38
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(158));)
    //
    //   Comma<TypeRefOrLifetime> -> S66
    //   (<TypeRefOrLifetime> ",")* -> S65
    pub fn __state38<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action158(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state66(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 39
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S67)
    //
    pub fn __state39<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state67(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 40
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["("]
    //   (<TypeRef> ",") = (*) TypeRef "," [")"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")* (*) TypeRef? [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef? = (*) [")"]
    //   TypeRef? = (*) TypeRef [")"]
    //
    //   "&" -> Shift(S15)
    //   "#" -> Shift(S16)
    //   "::" -> Shift(S3)
    //   ")" -> Reduce(TypeRef? =  => Call(ActionFn(152));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "(" -> Shift(S18)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //
    //   TypeRef? -> S69
    //   (<TypeRef> ",") -> S68
    //   TypeRef -> S70
    //   "::"? -> S4
    //   Path -> S17
    pub fn __state40<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action152(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRef_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state69(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state68(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 41
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [EOF]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [")"]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" ["}"]
    //
    //   ")" -> Shift(S71)
    //
    pub fn __state41<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state71(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 42
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [EOF]
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [","]
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" ["}"]
    //
    //   ".." -> Shift(S74)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "}" -> Reduce(FieldPattern? =  => Call(ActionFn(80));)
    //
    //   FieldPattern? -> S76
    //   @L -> S73
    //   FieldPattern -> S75
    //   (<FieldPattern> ",") -> S72
    pub fn __state42<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::DotDot(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action80(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::FieldPattern_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::FieldPattern_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state76(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state73(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::FieldPattern(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state75(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state72(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 43
    //   (<Id> "::") = Id "::" (*) ["Id"]
    //   (<Id> "::") = Id "::" (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(90));)
    //   "Id" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(90));)
    //
    pub fn __state43<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action90(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 44
    //   (<Pattern> ",") = Pattern "," (*) ["("]
    //   (<Pattern> ",") = Pattern "," (*) [")"]
    //   (<Pattern> ",") = Pattern "," (*) [".."]
    //   (<Pattern> ",") = Pattern "," (*) ["::"]
    //   (<Pattern> ",") = Pattern "," (*) ["<"]
    //   (<Pattern> ",") = Pattern "," (*) ["Id"]
    //   (<Pattern> ",") = Pattern "," (*) ["MacroId"]
    //   (<Pattern> ",") = Pattern "," (*) ["_"]
    //
    //   "Id" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(170));)
    //   ")" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(170));)
    //   "_" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(170));)
    //   "(" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(170));)
    //   "<" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(170));)
    //   "::" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(170));)
    //   ".." -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(170));)
    //   "MacroId" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(170));)
    //
    pub fn __state44<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Pattern<TypeRef>>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Underscore(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::DotDot(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action170(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 45
    //   "mut"? = "mut" (*) ["#"]
    //   "mut"? = "mut" (*) ["&"]
    //   "mut"? = "mut" (*) ["("]
    //   "mut"? = "mut" (*) ["::"]
    //   "mut"? = "mut" (*) ["Id"]
    //   "mut"? = "mut" (*) ["MacroId"]
    //
    //   "&" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "::" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "#" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "(" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "MacroId" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //   "Id" -> Reduce("mut"? = "mut" => Call(ActionFn(94));)
    //
    pub fn __state45<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action94(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 46
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "::" -> Shift(S3)
    //   "&" -> Shift(S15)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "(" -> Shift(S18)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "#" -> Shift(S16)
    //
    //   Path -> S17
    //   TypeRef -> S77
    //   "::"? -> S4
    pub fn __state46<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state77(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 47
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   ">" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "<" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "#" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "(" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "," -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   ")" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(47));)
    //
    pub fn __state47<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action47(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 48
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Shift(S78)
    //
    pub fn __state48<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 49
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //
    //   ")" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "," -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   ">" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "#" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "(" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "<" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(46));)
    //
    pub fn __state49<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action46(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 50
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(100));)
    //
    //   Symbol* -> S80
    //   ExprSymbol -> S79
    pub fn __state50<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state80(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::ExprSymbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state79(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 51
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "<" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ")" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "(" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "#" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "," -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //
    pub fn __state51<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 52
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S81
    pub fn __state52<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state81(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 53
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //
    //   "," -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(77));)
    //
    pub fn __state53<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action77(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::QuotedTerminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 54
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   ")" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   ">" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "Id" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "<" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "," -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //   "(" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(44));)
    //
    pub fn __state54<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action44(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 55
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(42));)
    //
    pub fn __state55<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 56
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //
    //   "MacroId" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "@L" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "<" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "Id" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "(" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "@R" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "#" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "Escape" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(73));)
    //
    pub fn __state56<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action73(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 57
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(78));)
    //
    pub fn __state57<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action78(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 58
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(69));)
    //
    pub fn __state58<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::MacroId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 59
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S82
    //   Symbol1 -> S35
    //   Symbol0 -> S83
    pub fn __state59<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state82(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state83(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 60
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(49));)
    //
    pub fn __state60<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Symbol>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action49(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 61
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //
    //   "," -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "(" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "<" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   ">" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "Escape" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "MacroId" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "#" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   "Id" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //   ")" -> Reduce(RepeatOp = "*" => Call(ActionFn(38));)
    //
    pub fn __state61<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 62
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S84
    pub fn __state62<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state84(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 63
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   ">" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "(" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "," -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "#" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   ")" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "MacroId" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "<" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "Escape" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //   "Id" -> Reduce(RepeatOp = "+" => Call(ActionFn(37));)
    //
    pub fn __state63<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action37(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 64
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //
    //   "," -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   ">" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "Escape" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   ")" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "#" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "Id" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "MacroId" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "<" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //   "(" -> Reduce(RepeatOp = "?" => Call(ActionFn(39));)
    //
    pub fn __state64<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 65
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* (*) TypeRefOrLifetime? [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   TypeRefOrLifetime? = (*) [">"]
    //   TypeRefOrLifetime? = (*) TypeRefOrLifetime [">"]
    //
    //   ">" -> Reduce(TypeRefOrLifetime? =  => Call(ActionFn(157));)
    //   "Lifetime" -> Shift(S33)
    //   "#" -> Shift(S16)
    //   "(" -> Shift(S18)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(92));)
    //   "&" -> Shift(S15)
    //   "::" -> Shift(S3)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(92));)
    //
    //   (<TypeRefOrLifetime> ",") -> S88
    //   TypeRefOrLifetime -> S85
    //   TypeRef -> S86
    //   "::"? -> S4
    //   Lifetime -> S87
    //   TypeRefOrLifetime? -> S89
    //   Path -> S17
    pub fn __state65<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state33(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Hash(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action92(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state88(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::TypeRefOrLifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state85(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state86(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state87(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRefOrLifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state89(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 66
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S90)
    //
    pub fn __state66<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state90(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 67
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(48));)
    //
    pub fn __state67<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action48(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 68
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "&" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   ")" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "::" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "(" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //   "Id" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(154));)
    //
    pub fn __state68<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action154(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 69
    //   Comma<TypeRef> = (<TypeRef> ",")* TypeRef? (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")*, TypeRef? => Call(ActionFn(98));)
    //
    pub fn __state69<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action98(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRef_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 70
    //   (<TypeRef> ",") = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["("]
    //   (<TypeRef> ",") = TypeRef (*) "," [")"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["MacroId"]
    //   TypeRef? = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(TypeRef? = TypeRef => Call(ActionFn(151));)
    //   "," -> Shift(S91)
    //
    pub fn __state70<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state91(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action151(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 71
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [EOF]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [")"]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) ["}"]
    //
    //   "," -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(60));)
    //   ")" -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(60));)
    //   EOF -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(60));)
    //   "}" -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(60));)
    //
    pub fn __state71<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Pattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            None |
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action60(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 72
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) ["MacroId"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) ["}"]
    //
    //   ".." -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(82));)
    //   "Id" -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(82));)
    //   "}" -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(82));)
    //   "MacroId" -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(82));)
    //
    pub fn __state72<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym1: &mut Option<FieldPattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::DotDot(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action82(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 73
    //   FieldPattern = @L (*) Id @R ":" Pattern [","]
    //   FieldPattern = @L (*) Id @R ":" Pattern ["}"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //
    //   "Id" -> Shift(S23)
    //   "MacroId" -> Shift(S22)
    //
    //   Id -> S92
    pub fn __state73<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state22(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state92(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 74
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" ["}"]
    //
    //   "}" -> Shift(S93)
    //
    pub fn __state74<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state93(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 75
    //   (<FieldPattern> ",") = FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",") = FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",") = FieldPattern (*) "," ["MacroId"]
    //   (<FieldPattern> ",") = FieldPattern (*) "," ["}"]
    //   FieldPattern? = FieldPattern (*) ["}"]
    //
    //   "}" -> Reduce(FieldPattern? = FieldPattern => Call(ActionFn(79));)
    //   "," -> Shift(S94)
    //
    pub fn __state75<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<FieldPattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state94(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action79(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::FieldPattern_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 76
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" ["}"]
    //
    //   "}" -> Shift(S95)
    //
    pub fn __state76<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state95(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 77
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   ")" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(50));)
    //
    pub fn __state77<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action50(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 78
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(148));)
    //
    //   (<Symbol> ",")* -> S97
    //   Comma<Symbol> -> S96
    pub fn __state78<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action148(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state97(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cSymbol_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state96(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 79
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //
    //   ")" -> Shift(S98)
    //
    pub fn __state79<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state98(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 80
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol* (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(ExprSymbol = Symbol* => Call(ActionFn(31));)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S34
    //   Symbol0 -> S37
    //   Symbol -> S99
    //   Symbol1 -> S35
    pub fn __state80<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExprSymbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state99(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 81
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(40));)
    //
    pub fn __state81<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action40(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 82
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "@R" -> Shift(S47)
    //   "@L" -> Shift(S49)
    //   "Id" -> Shift(S101)
    //   "MacroId" -> Shift(S100)
    //   "StringLiteral" -> Shift(S57)
    //   "(" -> Shift(S50)
    //   "Escape" -> Shift(S56)
    //
    //   Escape -> S54
    //   MacroId -> S48
    //   SymbolKind1 -> S52
    //   Id -> S102
    //   QuotedTerminal -> S55
    //   StringLiteral -> S53
    pub fn __state82<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state101(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state100(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state54(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state102(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state55(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 83
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S61)
    //   "+" -> Shift(S63)
    //   "?" -> Shift(S64)
    //   ">" -> Shift(S103)
    //
    //   RepeatOp -> S62
    pub fn __state83<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state61(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state63(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state103(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 84
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(36));)
    //
    pub fn __state84<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 85
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["MacroId"]
    //   TypeRefOrLifetime? = TypeRefOrLifetime (*) [">"]
    //
    //   ">" -> Reduce(TypeRefOrLifetime? = TypeRefOrLifetime => Call(ActionFn(156));)
    //   "," -> Shift(S104)
    //
    pub fn __state85<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state104(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action156(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 86
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(53));)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(53));)
    //
    pub fn __state86<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action53(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 87
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(54));)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(54));)
    //
    pub fn __state87<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action54(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 88
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(159));)
    //
    pub fn __state88<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 89
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")*, TypeRefOrLifetime? => Call(ActionFn(93));)
    //
    pub fn __state89<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action93(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 90
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(51));)
    //
    pub fn __state90<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 91
    //   (<TypeRef> ",") = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["("]
    //   (<TypeRef> ",") = TypeRef "," (*) [")"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["MacroId"]
    //
    //   "::" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "&" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "(" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   ")" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "Id" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "#" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //   "MacroId" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(155));)
    //
    pub fn __state91<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action155(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 92
    //   @R = (*) [":"]
    //   FieldPattern = @L Id (*) @R ":" Pattern [","]
    //   FieldPattern = @L Id (*) @R ":" Pattern ["}"]
    //
    //   ":" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S105
    pub fn __state92<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state105(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 93
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(62));)
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(62));)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(62));)
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(62));)
    //
    pub fn __state93<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None |
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action62(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 94
    //   (<FieldPattern> ",") = FieldPattern "," (*) [".."]
    //   (<FieldPattern> ",") = FieldPattern "," (*) ["Id"]
    //   (<FieldPattern> ",") = FieldPattern "," (*) ["MacroId"]
    //   (<FieldPattern> ",") = FieldPattern "," (*) ["}"]
    //
    //   "}" -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(83));)
    //   ".." -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(83));)
    //   "Id" -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(83));)
    //   "MacroId" -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(83));)
    //
    pub fn __state94<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<FieldPattern<TypeRef>>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) |
            Some((_, Tok::DotDot(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action83(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 95
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) ["}"]
    //
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(61));)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(61));)
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(61));)
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(61));)
    //
    pub fn __state95<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            None |
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action61(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 96
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //
    //   ">" -> Shift(S106)
    //
    pub fn __state96<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state106(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 97
    //   (<Symbol> ",") = (*) Symbol "," ["("]
    //   (<Symbol> ",") = (*) Symbol "," ["<"]
    //   (<Symbol> ",") = (*) Symbol "," [">"]
    //   (<Symbol> ",") = (*) Symbol "," ["@L"]
    //   (<Symbol> ",") = (*) Symbol "," ["@R"]
    //   (<Symbol> ",") = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",") = (*) Symbol "," ["Id"]
    //   (<Symbol> ",") = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",") = (*) Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")* (*) Symbol? [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol? = (*) [">"]
    //   Symbol? = (*) Symbol [">"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   ">" -> Reduce(Symbol? =  => Call(ActionFn(147));)
    //
    //   @L -> S34
    //   Symbol -> S107
    //   Symbol1 -> S35
    //   Symbol0 -> S37
    //   Symbol? -> S109
    //   (<Symbol> ",") -> S108
    pub fn __state97<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state107(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state109(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state108(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 98
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(45));)
    //
    pub fn __state98<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<ExprSymbol>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Hash(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action45(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 99
    //   Symbol* = Symbol* Symbol (*) ["("]
    //   Symbol* = Symbol* Symbol (*) [")"]
    //   Symbol* = Symbol* Symbol (*) ["<"]
    //   Symbol* = Symbol* Symbol (*) ["@L"]
    //   Symbol* = Symbol* Symbol (*) ["@R"]
    //   Symbol* = Symbol* Symbol (*) ["Escape"]
    //   Symbol* = Symbol* Symbol (*) ["Id"]
    //   Symbol* = Symbol* Symbol (*) ["MacroId"]
    //   Symbol* = Symbol* Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "StringLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "<" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "Id" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "MacroId" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   ")" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "Escape" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //   "@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(101));)
    //
    pub fn __state99<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 100
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(69));)
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(72));)
    //
    pub fn __state100<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action72(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::MacroId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 101
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(43));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(71));)
    //
    pub fn __state101<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 102
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //
    //   ":" -> Shift(S110)
    //
    pub fn __state102<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state110(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 103
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S111
    pub fn __state103<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state111(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 104
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "#" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(160));)
    //
    pub fn __state104<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Ampersand(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action160(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 105
    //   FieldPattern = @L Id @R (*) ":" Pattern [","]
    //   FieldPattern = @L Id @R (*) ":" Pattern ["}"]
    //
    //   ":" -> Shift(S112)
    //
    pub fn __state105<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<InternedString>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state112(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 106
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(41));)
    //
    pub fn __state106<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Question(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Plus(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Star(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 107
    //   (<Symbol> ",") = Symbol (*) "," ["("]
    //   (<Symbol> ",") = Symbol (*) "," ["<"]
    //   (<Symbol> ",") = Symbol (*) "," [">"]
    //   (<Symbol> ",") = Symbol (*) "," ["@L"]
    //   (<Symbol> ",") = Symbol (*) "," ["@R"]
    //   (<Symbol> ",") = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",") = Symbol (*) "," ["Id"]
    //   (<Symbol> ",") = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",") = Symbol (*) "," ["StringLiteral"]
    //   Symbol? = Symbol (*) [">"]
    //
    //   "," -> Shift(S113)
    //   ">" -> Reduce(Symbol? = Symbol => Call(ActionFn(146));)
    //
    pub fn __state107<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state113(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action146(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 108
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   ">" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "MacroId" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "<" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "@L" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "Id" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "Escape" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //   "@R" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(149));)
    //
    pub fn __state108<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 109
    //   Comma<Symbol> = (<Symbol> ",")* Symbol? (*) [">"]
    //
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")*, Symbol? => Call(ActionFn(99));)
    //
    pub fn __state109<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<::std::option::Option<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cSymbol_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 110
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol0 -> S115
    //   Symbol1 -> S35
    //   @L -> S114
    pub fn __state110<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state115(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state114(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 111
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(33));)
    //
    pub fn __state111<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action33(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 112
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   FieldPattern = @L Id @R ":" (*) Pattern [","]
    //   FieldPattern = @L Id @R ":" (*) Pattern ["}"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   Pattern = (*) @L PatternKind @R ["}"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "_" -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   ".." -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S2
    //   Pattern -> S116
    pub fn __state112<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<InternedString>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore(..), _)) |
            Some((_, Tok::ColonColon(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym4));
                }
                __Nonterminal::Pattern(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state116(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 113
    //   (<Symbol> ",") = Symbol "," (*) ["("]
    //   (<Symbol> ",") = Symbol "," (*) ["<"]
    //   (<Symbol> ",") = Symbol "," (*) [">"]
    //   (<Symbol> ",") = Symbol "," (*) ["@L"]
    //   (<Symbol> ",") = Symbol "," (*) ["@R"]
    //   (<Symbol> ",") = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",") = Symbol "," (*) ["Id"]
    //   (<Symbol> ",") = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",") = Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "<" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "@L" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "Id" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "Escape" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   ">" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "@R" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "MacroId" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //   "StringLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(150));)
    //
    pub fn __state113<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action150(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 114
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "@L" -> Shift(S49)
    //   "StringLiteral" -> Shift(S57)
    //   "@R" -> Shift(S47)
    //   "Id" -> Shift(S51)
    //   "Escape" -> Shift(S56)
    //   "(" -> Shift(S50)
    //   "MacroId" -> Shift(S58)
    //
    //   StringLiteral -> S53
    //   SymbolKind1 -> S52
    //   MacroId -> S48
    //   Escape -> S54
    //   QuotedTerminal -> S55
    pub fn __state114<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state51(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state54(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::QuotedTerminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state55(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 115
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "?" -> Shift(S64)
    //   "+" -> Shift(S63)
    //   ">" -> Shift(S117)
    //   "*" -> Shift(S61)
    //
    //   RepeatOp -> S62
    pub fn __state115<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state63(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state117(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state61(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 116
    //   FieldPattern = @L Id @R ":" Pattern (*) [","]
    //   FieldPattern = @L Id @R ":" Pattern (*) ["}"]
    //
    //   "," -> Reduce(FieldPattern = @L, Id, @R, ":", Pattern => Call(ActionFn(68));)
    //   "}" -> Reduce(FieldPattern = @L, Id, @R, ":", Pattern => Call(ActionFn(68));)
    //
    pub fn __state116<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<InternedString>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action68(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::FieldPattern(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 117
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S118
    pub fn __state117<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state118(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 118
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(32));)
    //
    pub fn __state118<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) |
            Some((_, Tok::LessThan(..), _)) |
            Some((_, Tok::RightParen(..), _)) |
            Some((_, Tok::Lookbehind(..), _)) |
            Some((_, Tok::LeftParen(..), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::Lookahead(..), _)) |
            Some((_, Tok::Comma(..), _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Hash(..), _)) |
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }
}

pub fn __action0<
    'input,
>(
    text: &'input str,
    __0: Grammar,
) -> Grammar
{
    (__0)
}

pub fn __action1<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> TypeRef
{
    (__0)
}

pub fn __action2<
    'input,
>(
    text: &'input str,
    __0: Pattern<TypeRef>,
) -> Pattern<TypeRef>
{
    (__0)
}

pub fn __action3<
    'input,
>(
    text: &'input str,
    uses: ::std::vec::Vec<GrammarItem>,
    lo: usize,
    _: Tok<'input>,
    hi: usize,
    tps: ::std::option::Option<Vec<TypeParameter>>,
    parameters: ::std::option::Option<Vec<Parameter>>,
    where_clauses: ::std::option::Option<Vec<&'input str>>,
    algorithm: ::std::option::Option<Algorithm>,
    _: Tok<'input>,
    items: ::std::vec::Vec<GrammarItem>,
) -> Grammar
{
    {
        let where_clauses =
            where_clauses.iter()
                         .flat_map(|wc| wc.iter())
                         .map(|s| strip(s))
                         .filter(|s| !s.is_empty())
                         .map(|s| s.to_string())
                         .collect();
        Grammar { span: Span(lo, hi),
                  type_parameters: tps.unwrap_or(vec![]),
                  parameters: parameters.unwrap_or(vec![]),
                  where_clauses: where_clauses,
                  items: uses.into_iter().chain(items).collect(),
                  algorithm: algorithm }
    }
}

pub fn __action4<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    lo: usize,
    t: InternedString,
    hi: usize,
    _: Tok<'input>,
) -> Algorithm
{
    {
        Algorithm {
            span: Span(lo, hi),
            text: t
        }
    }
}

pub fn __action5<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Vec<TypeParameter>,
    _: Tok<'input>,
) -> Vec<TypeParameter>
{
    (__0)
}

pub fn __action6<
    'input,
>(
    text: &'input str,
    l: InternedString,
) -> TypeParameter
{
    TypeParameter::Lifetime(l)
}

pub fn __action7<
    'input,
>(
    text: &'input str,
    l: InternedString,
) -> TypeParameter
{
    TypeParameter::Id(l)
}

pub fn __action8<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Vec<Parameter>,
    _: Tok<'input>,
) -> Vec<Parameter>
{
    (__0)
}

pub fn __action9<
    'input,
>(
    text: &'input str,
    id: InternedString,
    _: Tok<'input>,
    ty: TypeRef,
) -> Parameter
{
    Parameter { name: id, ty: ty }
}

pub fn __action10<
    'input,
>(
    text: &'input str,
    __0: GrammarItem,
) -> GrammarItem
{
    (__0)
}

pub fn __action11<
    'input,
>(
    text: &'input str,
    __0: GrammarItem,
) -> GrammarItem
{
    (__0)
}

pub fn __action12<
    'input,
>(
    text: &'input str,
    __0: GrammarItem,
) -> GrammarItem
{
    (__0)
}

pub fn __action13<
    'input,
>(
    text: &'input str,
    u: &'input str,
    _: Tok<'input>,
) -> GrammarItem
{
    GrammarItem::Use(strip(u).to_string())
}

pub fn __action14<
    'input,
>(
    text: &'input str,
    p: ::std::option::Option<Tok<'input>>,
    lo: usize,
    n: (NonterminalString, Vec<NonterminalString>),
    hi: usize,
    t: ::std::option::Option<TypeRef>,
    _: Tok<'input>,
    a: Vec<Alternative>,
) -> GrammarItem
{
    {
        GrammarItem::Nonterminal(NonterminalData { public: p.is_some(),
                                                   span: Span(lo, hi),
                                                   name: n.0,
                                                   args: n.1,
                                                   type_decl: t,
                                                   alternatives: a })
    }
}

pub fn __action15<
    'input,
>(
    text: &'input str,
    __0: NonterminalString,
    _: Tok<'input>,
    __1: Vec<NonterminalString>,
    _: Tok<'input>,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (__0, __1)
}

pub fn __action16<
    'input,
>(
    text: &'input str,
    n: NonterminalString,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (n, vec![])
}

pub fn __action17<
    'input,
>(
    text: &'input str,
    __0: &'input str,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (NonterminalString(intern(__0)), vec![])
}

pub fn __action18<
    'input,
>(
    text: &'input str,
    a: Alternative,
) -> Vec<Alternative>
{
    vec![a]
}

pub fn __action19<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: ::std::vec::Vec<Alternative>,
    _: Tok<'input>,
    _: Tok<'input>,
) -> Vec<Alternative>
{
    (__0)
}

pub fn __action20<
    'input,
>(
    text: &'input str,
    lo: usize,
    s: ::std::vec::Vec<Symbol>,
    c: ::std::option::Option<Condition>,
    a: ::std::option::Option<ActionKind>,
    _: Tok<'input>,
    hi: usize,
) -> Alternative
{
    {
        Alternative {
            span: Span(lo, hi),
            expr: ExprSymbol { symbols: s },
            condition: c,
            action: a
        }
    }
}

pub fn __action21<
    'input,
>(
    text: &'input str,
    lo: usize,
    c: ::std::option::Option<Condition>,
    a: ActionKind,
    _: Tok<'input>,
    hi: usize,
) -> Alternative
{
    {
        Alternative {
            span: Span(lo, hi),
            expr: ExprSymbol { symbols: vec![] },
            condition: c,
            action: Some(a)
        }
    }
}

pub fn __action22<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ActionKind
{
    ActionKind::Lookahead
}

pub fn __action23<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ActionKind
{
    ActionKind::Lookbehind
}

pub fn __action24<
    'input,
>(
    text: &'input str,
    c: &'input str,
) -> ActionKind
{
    ActionKind::User(strip(c).to_string())
}

pub fn __action25<
    'input,
>(
    text: &'input str,
    c: &'input str,
) -> ActionKind
{
    ActionKind::Fallible(strip(c).to_string())
}

pub fn __action26<
    'input,
>(
    text: &'input str,
    lo: usize,
    a: NonterminalString,
    op: ConditionOp,
    b: InternedString,
    hi: usize,
) -> Condition
{
    {
        Condition { span:Span(lo, hi), lhs:a, rhs:b, op:op }
    }
}

pub fn __action27<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::Equals
}

pub fn __action28<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::NotEquals
}

pub fn __action29<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::Match
}

pub fn __action30<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::NotMatch
}

pub fn __action31<
    'input,
>(
    text: &'input str,
    __0: ::std::vec::Vec<Symbol>,
) -> ExprSymbol
{
    ExprSymbol { symbols: __0 }
}

pub fn __action32<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    _: usize,
    l: InternedString,
    _: Tok<'input>,
    s: Symbol,
    _: Tok<'input>,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), SymbolKind::Name(l, Box::new(s)))
}

pub fn __action33<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    s: Symbol,
    _: Tok<'input>,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), SymbolKind::Choose(Box::new(s)))
}

pub fn __action34<
    'input,
>(
    text: &'input str,
    __0: Symbol,
) -> Symbol
{
    (__0)
}

pub fn __action35<
    'input,
>(
    text: &'input str,
    __0: Symbol,
) -> Symbol
{
    (__0)
}

pub fn __action36<
    'input,
>(
    text: &'input str,
    lhs: Symbol,
    op: RepeatOp,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lhs.span.0, hi),
                    SymbolKind::Repeat(Box::new(RepeatSymbol { symbol: lhs, op: op })))
}

pub fn __action37<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Plus
}

pub fn __action38<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Star
}

pub fn __action39<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Question
}

pub fn __action40<
    'input,
>(
    text: &'input str,
    lo: usize,
    sk: SymbolKind,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), sk)
}

pub fn __action41<
    'input,
>(
    text: &'input str,
    name: NonterminalString,
    _: Tok<'input>,
    args: Vec<Symbol>,
    _: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Macro(MacroSymbol { name: name, args: args })
}

pub fn __action42<
    'input,
>(
    text: &'input str,
    __0: TerminalString,
) -> SymbolKind
{
    SymbolKind::Terminal(__0)
}

pub fn __action43<
    'input,
>(
    text: &'input str,
    __0: &'input str,
) -> SymbolKind
{
    SymbolKind::AmbiguousId(intern(__0))
}

pub fn __action44<
    'input,
>(
    text: &'input str,
    __0: InternedString,
) -> SymbolKind
{
    SymbolKind::Nonterminal(NonterminalString(__0))
}

pub fn __action45<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: ExprSymbol,
    _: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Expr(__0)
}

pub fn __action46<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Lookahead
}

pub fn __action47<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Lookbehind
}

pub fn __action48<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Vec<TypeRef>,
    _: Tok<'input>,
) -> TypeRef
{
    TypeRef::Tuple(__0)
}

pub fn __action49<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Symbol,
    _: Tok<'input>,
) -> TypeRef
{
    {
        TypeRef::OfSymbol(__0.kind)
    }
}

pub fn __action50<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    l: ::std::option::Option<InternedString>,
    m: ::std::option::Option<Tok<'input>>,
    t: TypeRef,
) -> TypeRef
{
    TypeRef::Ref { lifetime: l,
                       mutable: m.is_some(),
                       referent: Box::new(t) }
}

pub fn __action51<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a: Vec<TypeRef>,
    _: Tok<'input>,
) -> TypeRef
{
    TypeRef::Nominal { path: p, types: a }
}

pub fn __action52<
    'input,
>(
    text: &'input str,
    p: Path,
) -> TypeRef
{
    match p.as_id() {
            Some(id) => TypeRef::Id(id),
            None => TypeRef::Nominal { path: p, types: vec![] }
        }
}

pub fn __action53<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> TypeRef
{
    (__0)
}

pub fn __action54<
    'input,
>(
    text: &'input str,
    __0: InternedString,
) -> TypeRef
{
    TypeRef::Lifetime(__0)
}

pub fn __action55<
    'input,
>(
    text: &'input str,
    a: ::std::option::Option<Tok<'input>>,
    h: ::std::vec::Vec<InternedString>,
    t: InternedString,
) -> Path
{
    {
        Path { absolute: a.is_some(),
               ids: h.into_iter().chain(once(t)).collect() }
    }
}

pub fn __action56<
    'input,
>(
    text: &'input str,
    lo0: usize,
    _: Tok<'input>,
    hi0: usize,
    _: Tok<'input>,
    a0: ::std::vec::Vec<AssociatedType>,
    _: Tok<'input>,
    lo: usize,
    t: TypeRef,
    hi: usize,
    _: Tok<'input>,
    c: Vec<Conversion>,
    _: Tok<'input>,
    a1: ::std::vec::Vec<AssociatedType>,
    _: Tok<'input>,
) -> GrammarItem
{
    {
        GrammarItem::ExternToken(ExternToken {
            span: Span(lo0, hi0),
            associated_types: a0.into_iter().chain(a1).collect(),
            enum_token: EnumToken {
                type_name: t,
                type_span: Span(lo, hi),
                conversions: c,
            }
        })
    }
}

pub fn __action57<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    lo: usize,
    n: InternedString,
    hi: usize,
    _: Tok<'input>,
    t: TypeRef,
    _: Tok<'input>,
) -> AssociatedType
{
    {
        AssociatedType { type_span: Span(lo, hi),
                         type_name: n,
                         type_ref: t }
    }
}

pub fn __action58<
    'input,
>(
    text: &'input str,
    lo: usize,
    from: TerminalString,
    start: usize,
    p: &'input str,
    hi: usize,
) -> Result<Conversion,__ParseError<usize,Tok<'input>,tok::Error>>
{
    {
        let pattern = try!(super::parse_pattern(p, start + 2));
        Ok(Conversion { span: Span(lo, hi),
                        from: from,
                        to: pattern })
    }
}

pub fn __action59<
    'input,
>(
    text: &'input str,
    lo: usize,
    k: PatternKind<TypeRef>,
    hi: usize,
) -> Pattern<TypeRef>
{
    Pattern { span: Span(lo, hi), kind: k }
}

pub fn __action60<
    'input,
>(
    text: &'input str,
    __0: Path,
    _: Tok<'input>,
    __1: Vec<Pattern<TypeRef>>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Enum(__0, __1)
}

pub fn __action61<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    a1: ::std::option::Option<FieldPattern<TypeRef>>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Struct(p, a0.into_iter().chain(a1).collect(), false)
}

pub fn __action62<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    _: Tok<'input>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Struct(p, a0, true)
}

pub fn __action63<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Underscore
}

pub fn __action64<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::DotDot
}

pub fn __action65<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: TypeRef,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Choose(__0)
}

pub fn __action66<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Vec<Pattern<TypeRef>>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Tuple(__0)
}

pub fn __action67<
    'input,
>(
    text: &'input str,
    __0: Path,
) -> PatternKind<TypeRef>
{
    PatternKind::Path(__0)
}

pub fn __action68<
    'input,
>(
    text: &'input str,
    lo: usize,
    id: InternedString,
    hi: usize,
    _: Tok<'input>,
    pat: Pattern<TypeRef>,
) -> FieldPattern<TypeRef>
{
    {
        FieldPattern { field_span: Span(lo, hi),
                       field_name: id,
                       pattern: pat }
    }
}

pub fn __action69<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> NonterminalString
{
    NonterminalString(intern(i))
}

pub fn __action70<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> NonterminalString
{
    NonterminalString(intern(i))
}

pub fn __action71<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn __action72<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn __action73<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn __action74<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn __action75<
    'input,
>(
    text: &'input str,
    __0: TerminalString,
) -> TerminalString
{
    (__0)
}

pub fn __action76<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> TerminalString
{
    TerminalString::Bare(intern(i))
}

pub fn __action77<
    'input,
>(
    text: &'input str,
    s: InternedString,
) -> TerminalString
{
    TerminalString::Quoted(s)
}

pub fn __action78<
    'input,
>(
    text: &'input str,
    s: &'input str,
) -> InternedString
{
    intern(s)
}

pub fn __action79<
    'input,
>(
    text: &'input str,
    __0: FieldPattern<TypeRef>,
) -> ::std::option::Option<FieldPattern<TypeRef>>
{
    Some(__0)
}

pub fn __action80<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<FieldPattern<TypeRef>>
{
    None
}

pub fn __action81<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    vec![]
}

pub fn __action82<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<FieldPattern<TypeRef>>,
    e: FieldPattern<TypeRef>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action83<
    'input,
>(
    text: &'input str,
    __0: FieldPattern<TypeRef>,
    _: Tok<'input>,
) -> FieldPattern<TypeRef>
{
    (__0)
}

pub fn __action84<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Pattern<TypeRef>>,
    e1: ::std::option::Option<Pattern<TypeRef>>,
) -> Vec<Pattern<TypeRef>>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action85<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Conversion>,
    e1: ::std::option::Option<Conversion>,
) -> Vec<Conversion>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action86<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<AssociatedType>
{
    vec![]
}

pub fn __action87<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<AssociatedType>,
    e: AssociatedType,
) -> ::std::vec::Vec<AssociatedType>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action88<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<InternedString>
{
    vec![]
}

pub fn __action89<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<InternedString>,
    e: InternedString,
) -> ::std::vec::Vec<InternedString>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action90<
    'input,
>(
    text: &'input str,
    __0: InternedString,
    _: Tok<'input>,
) -> InternedString
{
    (__0)
}

pub fn __action91<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

pub fn __action92<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn __action93<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeRef>,
    e1: ::std::option::Option<TypeRef>,
) -> Vec<TypeRef>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action94<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

pub fn __action95<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn __action96<
    'input,
>(
    text: &'input str,
    __0: InternedString,
) -> ::std::option::Option<InternedString>
{
    Some(__0)
}

pub fn __action97<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<InternedString>
{
    None
}

pub fn __action98<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeRef>,
    e1: ::std::option::Option<TypeRef>,
) -> Vec<TypeRef>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action99<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Symbol>,
    e1: ::std::option::Option<Symbol>,
) -> Vec<Symbol>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action100<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Symbol>
{
    vec![]
}

pub fn __action101<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action102<
    'input,
>(
    text: &'input str,
    __0: ActionKind,
) -> ::std::option::Option<ActionKind>
{
    Some(__0)
}

pub fn __action103<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<ActionKind>
{
    None
}

pub fn __action104<
    'input,
>(
    text: &'input str,
    __0: Condition,
) -> ::std::option::Option<Condition>
{
    Some(__0)
}

pub fn __action105<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Condition>
{
    None
}

pub fn __action106<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Condition,
) -> Condition
{
    (__0)
}

pub fn __action107<
    'input,
>(
    text: &'input str,
    __0: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    vec![__0]
}

pub fn __action108<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action109<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Alternative>
{
    vec![]
}

pub fn __action110<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Alternative>,
    e: Alternative,
) -> ::std::vec::Vec<Alternative>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action111<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<NonterminalString>,
    e1: ::std::option::Option<NonterminalString>,
) -> Vec<NonterminalString>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action112<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(__0)
}

pub fn __action113<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn __action114<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: TypeRef,
) -> TypeRef
{
    (__0)
}

pub fn __action115<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

pub fn __action116<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn __action117<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Parameter>,
    e1: ::std::option::Option<Parameter>,
) -> Vec<Parameter>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action118<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeParameter>,
    e1: ::std::option::Option<TypeParameter>,
) -> Vec<TypeParameter>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action119<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![]
}

pub fn __action120<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    e: GrammarItem,
) -> ::std::vec::Vec<GrammarItem>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action121<
    'input,
>(
    text: &'input str,
    __0: Algorithm,
) -> ::std::option::Option<Algorithm>
{
    Some(__0)
}

pub fn __action122<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Algorithm>
{
    None
}

pub fn __action123<
    'input,
>(
    text: &'input str,
    __0: Vec<&'input str>,
) -> ::std::option::Option<Vec<&'input str>>
{
    Some(__0)
}

pub fn __action124<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Vec<&'input str>>
{
    None
}

pub fn __action125<
    'input,
>(
    text: &'input str,
    __0: Vec<Parameter>,
) -> ::std::option::Option<Vec<Parameter>>
{
    Some(__0)
}

pub fn __action126<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Vec<Parameter>>
{
    None
}

pub fn __action127<
    'input,
>(
    text: &'input str,
    __0: Vec<TypeParameter>,
) -> ::std::option::Option<Vec<TypeParameter>>
{
    Some(__0)
}

pub fn __action128<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Vec<TypeParameter>>
{
    None
}

pub fn __action129<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![]
}

pub fn __action130<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    e: GrammarItem,
) -> ::std::vec::Vec<GrammarItem>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action131<
    'input,
>(
    text: &'input str,
    __0: TypeParameter,
) -> ::std::option::Option<TypeParameter>
{
    Some(__0)
}

pub fn __action132<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeParameter>
{
    None
}

pub fn __action133<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeParameter>
{
    vec![]
}

pub fn __action134<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeParameter>,
    e: TypeParameter,
) -> ::std::vec::Vec<TypeParameter>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action135<
    'input,
>(
    text: &'input str,
    __0: TypeParameter,
    _: Tok<'input>,
) -> TypeParameter
{
    (__0)
}

pub fn __action136<
    'input,
>(
    text: &'input str,
    __0: Parameter,
) -> ::std::option::Option<Parameter>
{
    Some(__0)
}

pub fn __action137<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Parameter>
{
    None
}

pub fn __action138<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Parameter>
{
    vec![]
}

pub fn __action139<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Parameter>,
    e: Parameter,
) -> ::std::vec::Vec<Parameter>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action140<
    'input,
>(
    text: &'input str,
    __0: Parameter,
    _: Tok<'input>,
) -> Parameter
{
    (__0)
}

pub fn __action141<
    'input,
>(
    text: &'input str,
    __0: NonterminalString,
) -> ::std::option::Option<NonterminalString>
{
    Some(__0)
}

pub fn __action142<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<NonterminalString>
{
    None
}

pub fn __action143<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<NonterminalString>
{
    vec![]
}

pub fn __action144<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<NonterminalString>,
    e: NonterminalString,
) -> ::std::vec::Vec<NonterminalString>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action145<
    'input,
>(
    text: &'input str,
    __0: NonterminalString,
    _: Tok<'input>,
) -> NonterminalString
{
    (__0)
}

pub fn __action146<
    'input,
>(
    text: &'input str,
    __0: Symbol,
) -> ::std::option::Option<Symbol>
{
    Some(__0)
}

pub fn __action147<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Symbol>
{
    None
}

pub fn __action148<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Symbol>
{
    vec![]
}

pub fn __action149<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action150<
    'input,
>(
    text: &'input str,
    __0: Symbol,
    _: Tok<'input>,
) -> Symbol
{
    (__0)
}

pub fn __action151<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(__0)
}

pub fn __action152<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn __action153<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeRef>
{
    vec![]
}

pub fn __action154<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    e: TypeRef,
) -> ::std::vec::Vec<TypeRef>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action155<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
    _: Tok<'input>,
) -> TypeRef
{
    (__0)
}

pub fn __action156<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(__0)
}

pub fn __action157<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn __action158<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeRef>
{
    vec![]
}

pub fn __action159<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    e: TypeRef,
) -> ::std::vec::Vec<TypeRef>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action160<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
    _: Tok<'input>,
) -> TypeRef
{
    (__0)
}

pub fn __action161<
    'input,
>(
    text: &'input str,
    __0: Conversion,
) -> ::std::option::Option<Conversion>
{
    Some(__0)
}

pub fn __action162<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Conversion>
{
    None
}

pub fn __action163<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Conversion>
{
    vec![]
}

pub fn __action164<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Conversion>,
    e: Conversion,
) -> ::std::vec::Vec<Conversion>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action165<
    'input,
>(
    text: &'input str,
    __0: Conversion,
    _: Tok<'input>,
) -> Conversion
{
    (__0)
}

pub fn __action166<
    'input,
>(
    text: &'input str,
    __0: Pattern<TypeRef>,
) -> ::std::option::Option<Pattern<TypeRef>>
{
    Some(__0)
}

pub fn __action167<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Pattern<TypeRef>>
{
    None
}

pub fn __action168<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    vec![]
}

pub fn __action169<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Pattern<TypeRef>>,
    e: Pattern<TypeRef>,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action170<
    'input,
>(
    text: &'input str,
    __0: Pattern<TypeRef>,
    _: Tok<'input>,
) -> Pattern<TypeRef>
{
    (__0)
}

pub trait __ToTriple<'input, > {
    type Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),Self::Error>;
}

impl<'input, > __ToTriple<'input, > for (usize, Tok<'input>, usize) {
    type Error = tok::Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),tok::Error> {
        Ok(value)
    }
}
impl<'input, > __ToTriple<'input, > for Result<(usize, Tok<'input>, usize),tok::Error> {
    type Error = tok::Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),tok::Error> {
        value
    }
}
