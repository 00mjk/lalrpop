#![allow(unused_imports)]
#![allow(unused_variables)]
use intern::{intern, InternedString};
use grammar::parse_tree::*;
use grammar::pattern::*;
use std::iter::once;
use tok::{self, Tok};
use util::strip;
extern crate lalrpop_util as ___lalrpop_util;
use self::___lalrpop_util::ParseError as ___ParseError;

mod ___parse___Grammar {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as ___lalrpop_util;
    use self::___lalrpop_util::ParseError as ___ParseError;
    use super::___ToTriple;
    pub fn parse_Grammar<
        'input,
        ___TOKEN: ___ToTriple<'input, Error=tok::Error>,
        ___TOKENS: IntoIterator<Item=___TOKEN>,
    >(
        text: &'input str,
        ___tokens: ___TOKENS,
    ) -> Result<Grammar, ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let ___tokens = ___tokens.into_iter();
        let mut ___tokens = ___tokens.map(|t| ___ToTriple::to_triple(t));
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match try!(___state0(text, None, &mut ___tokens, ___lookahead)) {
            (_, Some(___lookahead), _) => {
                Err(___ParseError::ExtraToken { token: ___lookahead })
            }
            (_, None, ___Nonterminal::______Grammar(___nt)) => {
                Ok(___nt)
            }
            _ => unreachable!(),
        }
    }

    #[allow(dead_code)]
    pub enum ___Nonterminal<'input> {
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        _28_22if_22_20_3cCond_3e_29(Condition),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        _28_3cAlternative_3e_20_22_2c_22_29(Alternative),
        _28_3cAlternative_3e_20_22_2c_22_29_2a(::std::vec::Vec<Alternative>),
        _28_3cAlternative_3e_20_22_2c_22_29_2b(::std::vec::Vec<Alternative>),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        _28_3cConversion_3e_20_22_2c_22_29_2b(::std::vec::Vec<Conversion>),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2b(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2b(::std::vec::Vec<Parameter>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        _28_3cId_3e_20_22_3a_3a_22_29_2b(::std::vec::Vec<InternedString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2b(::std::vec::Vec<NonterminalString>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cPattern_3e_20_22_2c_22_29_2b(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        _28_3cSymbol_3e_20_22_2c_22_29_2b(::std::vec::Vec<Symbol>),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeParameter>),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRef_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeRef>),
        _40L(usize),
        _40R(usize),
        Action(ActionKind),
        Action_3f(::std::option::Option<ActionKind>),
        Alternative(Alternative),
        Alternative_3f(::std::option::Option<Alternative>),
        Alternatives(Vec<Alternative>),
        Annotation(Annotation),
        Annotation_2a(::std::vec::Vec<Annotation>),
        Annotation_2b(::std::vec::Vec<Annotation>),
        AssociatedType(AssociatedType),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        AssociatedType_2b(::std::vec::Vec<AssociatedType>),
        Comma_3cAlternative_3e(Vec<Alternative>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        Cond(Condition),
        CondOp(ConditionOp),
        Conversion(Conversion),
        Conversion_3f(::std::option::Option<Conversion>),
        EnumToken(EnumToken),
        Escape(InternedString),
        ExprSymbol(ExprSymbol),
        ExternToken(GrammarItem),
        FieldPattern(FieldPattern<TypeRef>),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        Grammar(Grammar),
        GrammarItem(GrammarItem),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        GrammarItem_2b(::std::vec::Vec<GrammarItem>),
        GrammarParameter(Parameter),
        GrammarParameter_3f(::std::option::Option<Parameter>),
        GrammarParameters(Vec<Parameter>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        GrammarTypeParameters(Vec<TypeParameter>),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        Id(InternedString),
        Lifetime(InternedString),
        Lifetime_3f(::std::option::Option<InternedString>),
        MacroId(NonterminalString),
        Nonterminal(GrammarItem),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        NotMacroId(NonterminalString),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        Path(Path),
        Pattern(Pattern<TypeRef>),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        QuotedTerminal(TerminalString),
        RegexLiteral(InternedString),
        RepeatOp(RepeatOp),
        StringLiteral(InternedString),
        Symbol(Symbol),
        Symbol_2a(::std::vec::Vec<Symbol>),
        Symbol_2b(::std::vec::Vec<Symbol>),
        Symbol0(Symbol),
        Symbol1(Symbol),
        Symbol_3f(::std::option::Option<Symbol>),
        SymbolKind1(SymbolKind),
        Terminal(TerminalString),
        TypeParameter(TypeParameter),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        TypeRef(TypeRef),
        TypeRef_3f(::std::option::Option<TypeRef>),
        TypeRefOrLifetime(TypeRef),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        Use(GrammarItem),
        Use_2a(::std::vec::Vec<GrammarItem>),
        Use_2b(::std::vec::Vec<GrammarItem>),
        ______Grammar(Grammar),
        ______Pattern(Pattern<TypeRef>),
        ______TypeRef(TypeRef),
    }

    // State 0
    //   @L = (*) ["grammar"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["grammar"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["grammar"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["grammar"]
    //   Grammar = (*) @L "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = (*) @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) @L "grammar" @R ";" [EOF]
    //   Grammar = (*) @L "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = (*) @L "grammar" @R "where" ";" [EOF]
    //   Grammar = (*) @L "grammar" @R "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R ";" [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R "where" ";" [EOF]
    //   Grammar = (*) Annotation+ @L "grammar" @R "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R ";" [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R "where" ";" [EOF]
    //   Grammar = (*) Use+ @L "grammar" @R "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R ";" [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R "where" ";" [EOF]
    //   Grammar = (*) Use+ Annotation+ @L "grammar" @R "where" ";" GrammarItem+ [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["grammar"]
    //   Use = (*) "use" ";" ["use"]
    //   Use+ = (*) Use ["#"]
    //   Use+ = (*) Use ["grammar"]
    //   Use+ = (*) Use ["use"]
    //   Use+ = (*) Use+ Use ["#"]
    //   Use+ = (*) Use+ Use ["grammar"]
    //   Use+ = (*) Use+ Use ["use"]
    //   ___Grammar = (*) Grammar [EOF]
    //
    //   "#" -> Shift(S7)
    //   "grammar" -> Reduce(@L =  => ActionFn(131);)
    //   "use" -> Shift(S8)
    //
    //   @L -> S1
    //   Annotation -> S2
    //   Annotation+ -> S3
    //   Grammar -> S4
    //   Use -> S5
    //   Use+ -> S6
    pub fn ___state0<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, Tok::Grammar, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Grammar(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state5(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Use_2b(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state6(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
    }

    // State 1
    //   Grammar = @L (*) "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = @L (*) "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L (*) "grammar" @R ";" [EOF]
    //   Grammar = @L (*) "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = @L (*) "grammar" @R "where" ";" [EOF]
    //   Grammar = @L (*) "grammar" @R "where" ";" GrammarItem+ [EOF]
    //
    //   "grammar" -> Shift(S9)
    //
    pub fn ___state1<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Grammar, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 2
    //   Annotation+ = Annotation (*) ["#"]
    //   Annotation+ = Annotation (*) ["grammar"]
    //   Annotation+ = Annotation (*) ["#"]
    //   Annotation+ = Annotation (*) ["Escape"]
    //   Annotation+ = Annotation (*) ["Id"]
    //   Annotation+ = Annotation (*) ["MacroId"]
    //   Annotation+ = Annotation (*) ["pub"]
    //
    //   "#" -> Reduce(Annotation+ = Annotation => ActionFn(138);)
    //   "Escape" -> Reduce(Annotation+ = Annotation => ActionFn(138);)
    //   "Id" -> Reduce(Annotation+ = Annotation => ActionFn(138);)
    //   "MacroId" -> Reduce(Annotation+ = Annotation => ActionFn(138);)
    //   "grammar" -> Reduce(Annotation+ = Annotation => ActionFn(138);)
    //   "pub" -> Reduce(Annotation+ = Annotation => ActionFn(138);)
    //
    pub fn ___state2<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Annotation>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Pub, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action138(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Annotation_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 3
    //   @L = (*) ["grammar"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["grammar"]
    //   Annotation+ = Annotation+ (*) Annotation ["#"]
    //   Annotation+ = Annotation+ (*) Annotation ["grammar"]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R ";" [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R "where" ";" [EOF]
    //   Grammar = Annotation+ (*) @L "grammar" @R "where" ";" GrammarItem+ [EOF]
    //
    //   "#" -> Shift(S7)
    //   "grammar" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S10
    //   Annotation -> S11
    pub fn ___state3<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Grammar, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state10(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state11(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 4
    //   ___Grammar = Grammar (*) [EOF]
    //
    //   EOF -> Reduce(___Grammar = Grammar => ActionFn(0);)
    //
    pub fn ___state4<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Grammar>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action0(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::______Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 5
    //   Use+ = Use (*) ["#"]
    //   Use+ = Use (*) ["grammar"]
    //   Use+ = Use (*) ["use"]
    //
    //   "#" -> Reduce(Use+ = Use => ActionFn(136);)
    //   "grammar" -> Reduce(Use+ = Use => ActionFn(136);)
    //   "use" -> Reduce(Use+ = Use => ActionFn(136);)
    //
    pub fn ___state5<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action136(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Use_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 6
    //   @L = (*) ["grammar"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["grammar"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["grammar"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["grammar"]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R ";" [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R "where" ";" [EOF]
    //   Grammar = Use+ (*) @L "grammar" @R "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R ";" [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R "where" ";" [EOF]
    //   Grammar = Use+ (*) Annotation+ @L "grammar" @R "where" ";" GrammarItem+ [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["grammar"]
    //   Use = (*) "use" ";" ["use"]
    //   Use+ = Use+ (*) Use ["#"]
    //   Use+ = Use+ (*) Use ["grammar"]
    //   Use+ = Use+ (*) Use ["use"]
    //
    //   "#" -> Shift(S7)
    //   "grammar" -> Reduce(@L =  => ActionFn(131);)
    //   "use" -> Shift(S8)
    //
    //   @L -> S12
    //   Annotation -> S2
    //   Annotation+ -> S13
    //   Use -> S14
    pub fn ___state6<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Grammar, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state12(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state13(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 7
    //   Annotation = "#" (*) "[" @L Id @R "]" ["#"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["grammar"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["#"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["Escape"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["Id"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["MacroId"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["pub"]
    //
    //   "[" -> Shift(S15)
    //
    pub fn ___state7<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBracket, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state15(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 8
    //   Use = "use" (*) ";" ["#"]
    //   Use = "use" (*) ";" ["grammar"]
    //   Use = "use" (*) ";" ["use"]
    //   Use = "use" (*) ";" [EOF]
    //   Use = "use" (*) ";" ["#"]
    //   Use = "use" (*) ";" ["Escape"]
    //   Use = "use" (*) ";" ["Id"]
    //   Use = "use" (*) ";" ["MacroId"]
    //   Use = "use" (*) ";" ["extern"]
    //   Use = "use" (*) ";" ["pub"]
    //   Use = "use" (*) ";" ["use"]
    //
    //   ";" -> Shift(S16)
    //
    pub fn ___state8<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state16(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 9
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["where"]
    //   Grammar = @L "grammar" (*) @R GrammarParameters ";" [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarParameters "where" ";" [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarTypeParameters ";" [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = @L "grammar" (*) @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" (*) @R ";" [EOF]
    //   Grammar = @L "grammar" (*) @R ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" (*) @R "where" ";" [EOF]
    //   Grammar = @L "grammar" (*) @R "where" ";" GrammarItem+ [EOF]
    //
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   "where" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S17
    pub fn ___state9<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 10
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R ";" [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R "where" ";" [EOF]
    //   Grammar = Annotation+ @L (*) "grammar" @R "where" ";" GrammarItem+ [EOF]
    //
    //   "grammar" -> Shift(S18)
    //
    pub fn ___state10<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Grammar, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state18(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 11
    //   Annotation+ = Annotation+ Annotation (*) ["#"]
    //   Annotation+ = Annotation+ Annotation (*) ["grammar"]
    //   Annotation+ = Annotation+ Annotation (*) ["#"]
    //   Annotation+ = Annotation+ Annotation (*) ["Escape"]
    //   Annotation+ = Annotation+ Annotation (*) ["Id"]
    //   Annotation+ = Annotation+ Annotation (*) ["MacroId"]
    //   Annotation+ = Annotation+ Annotation (*) ["pub"]
    //
    //   "#" -> Reduce(Annotation+ = Annotation+, Annotation => ActionFn(139);)
    //   "Escape" -> Reduce(Annotation+ = Annotation+, Annotation => ActionFn(139);)
    //   "Id" -> Reduce(Annotation+ = Annotation+, Annotation => ActionFn(139);)
    //   "MacroId" -> Reduce(Annotation+ = Annotation+, Annotation => ActionFn(139);)
    //   "grammar" -> Reduce(Annotation+ = Annotation+, Annotation => ActionFn(139);)
    //   "pub" -> Reduce(Annotation+ = Annotation+, Annotation => ActionFn(139);)
    //
    pub fn ___state11<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Annotation>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Pub, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action139(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Annotation_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 12
    //   Grammar = Use+ @L (*) "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R ";" [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R "where" ";" [EOF]
    //   Grammar = Use+ @L (*) "grammar" @R "where" ";" GrammarItem+ [EOF]
    //
    //   "grammar" -> Shift(S19)
    //
    pub fn ___state12<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Grammar, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state19(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 13
    //   @L = (*) ["grammar"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["grammar"]
    //   Annotation+ = Annotation+ (*) Annotation ["#"]
    //   Annotation+ = Annotation+ (*) Annotation ["grammar"]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R ";" [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ (*) @L "grammar" @R "where" ";" GrammarItem+ [EOF]
    //
    //   "#" -> Shift(S7)
    //   "grammar" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S20
    //   Annotation -> S11
    pub fn ___state13<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Grammar, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state20(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state11(text, ___lookbehind, ___tokens, ___lookahead, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 14
    //   Use+ = Use+ Use (*) ["#"]
    //   Use+ = Use+ Use (*) ["grammar"]
    //   Use+ = Use+ Use (*) ["use"]
    //
    //   "#" -> Reduce(Use+ = Use+, Use => ActionFn(137);)
    //   "grammar" -> Reduce(Use+ = Use+, Use => ActionFn(137);)
    //   "use" -> Reduce(Use+ = Use+, Use => ActionFn(137);)
    //
    pub fn ___state14<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action137(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Use_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 15
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["#"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["grammar"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["#"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["Escape"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["Id"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["MacroId"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["pub"]
    //
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S21
    pub fn ___state15<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state21(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 16
    //   Use = "use" ";" (*) ["#"]
    //   Use = "use" ";" (*) ["grammar"]
    //   Use = "use" ";" (*) ["use"]
    //   Use = "use" ";" (*) [EOF]
    //   Use = "use" ";" (*) ["#"]
    //   Use = "use" ";" (*) ["Escape"]
    //   Use = "use" ";" (*) ["Id"]
    //   Use = "use" ";" (*) ["MacroId"]
    //   Use = "use" ";" (*) ["extern"]
    //   Use = "use" ";" (*) ["pub"]
    //   Use = "use" ";" (*) ["use"]
    //
    //   EOF -> Reduce(Use = "use", ";" => ActionFn(12);)
    //   "#" -> Reduce(Use = "use", ";" => ActionFn(12);)
    //   "Escape" -> Reduce(Use = "use", ";" => ActionFn(12);)
    //   "Id" -> Reduce(Use = "use", ";" => ActionFn(12);)
    //   "MacroId" -> Reduce(Use = "use", ";" => ActionFn(12);)
    //   "extern" -> Reduce(Use = "use", ";" => ActionFn(12);)
    //   "grammar" -> Reduce(Use = "use", ";" => ActionFn(12);)
    //   "pub" -> Reduce(Use = "use", ";" => ActionFn(12);)
    //   "use" -> Reduce(Use = "use", ";" => ActionFn(12);)
    //
    pub fn ___state16<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action12(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Use(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 17
    //   Grammar = @L "grammar" @R (*) GrammarParameters ";" [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarParameters "where" ";" [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarTypeParameters ";" [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = @L "grammar" @R (*) GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R (*) ";" [EOF]
    //   Grammar = @L "grammar" @R (*) ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R (*) "where" ";" [EOF]
    //   Grammar = @L "grammar" @R (*) "where" ";" GrammarItem+ [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["where"]
    //
    //   "(" -> Shift(S24)
    //   ";" -> Shift(S25)
    //   "<" -> Shift(S26)
    //   "where" -> Shift(S27)
    //
    //   GrammarParameters -> S22
    //   GrammarTypeParameters -> S23
    pub fn ___state17<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state25(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state22(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::GrammarTypeParameters(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state23(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 18
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["where"]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" (*) @R "where" ";" GrammarItem+ [EOF]
    //
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   "where" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S28
    pub fn ___state18<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state28(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 19
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["where"]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarParameters ";" [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R ";" [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" (*) @R "where" ";" GrammarItem+ [EOF]
    //
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   "where" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S29
    pub fn ___state19<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state29(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 20
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R ";" [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L (*) "grammar" @R "where" ";" GrammarItem+ [EOF]
    //
    //   "grammar" -> Shift(S30)
    //
    pub fn ___state20<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Grammar, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state30(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 21
    //   Annotation = "#" "[" @L (*) Id @R "]" ["#"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["grammar"]
    //   Id = (*) "Id" ["]"]
    //   Id = (*) "MacroId" ["]"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["#"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["Escape"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["Id"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["MacroId"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["pub"]
    //   Id = (*) "Id" ["]"]
    //   Id = (*) "MacroId" ["]"]
    //
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   Id -> S31
    pub fn ___state21<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state31(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 22
    //   Grammar = @L "grammar" @R GrammarParameters (*) ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R GrammarParameters (*) "where" ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarParameters (*) "where" ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S34)
    //   "where" -> Shift(S35)
    //
    pub fn ___state22<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state34(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state35(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 23
    //   Grammar = @L "grammar" @R GrammarTypeParameters (*) GrammarParameters ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters (*) GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters (*) GrammarParameters "where" ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters (*) GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters (*) ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters (*) "where" ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters (*) "where" ";" GrammarItem+ [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //
    //   "(" -> Shift(S24)
    //   ";" -> Shift(S37)
    //   "where" -> Shift(S38)
    //
    //   GrammarParameters -> S36
    pub fn ___state23<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state37(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state38(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 24
    //   (<GrammarParameter> ",")+ = (*) (<GrammarParameter> ",")+ GrammarParameter "," [")"]
    //   (<GrammarParameter> ",")+ = (*) (<GrammarParameter> ",")+ GrammarParameter "," ["Id"]
    //   (<GrammarParameter> ",")+ = (*) (<GrammarParameter> ",")+ GrammarParameter "," ["MacroId"]
    //   (<GrammarParameter> ",")+ = (*) GrammarParameter "," [")"]
    //   (<GrammarParameter> ",")+ = (*) GrammarParameter "," ["Id"]
    //   (<GrammarParameter> ",")+ = (*) GrammarParameter "," ["MacroId"]
    //   Comma<GrammarParameter> = (*) [")"]
    //   Comma<GrammarParameter> = (*) (<GrammarParameter> ",")+ [")"]
    //   Comma<GrammarParameter> = (*) (<GrammarParameter> ",")+ GrammarParameter [")"]
    //   Comma<GrammarParameter> = (*) GrammarParameter [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [","]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" ["where"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //
    //   ")" -> Reduce(Comma<GrammarParameter> =  => ActionFn(320);)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<GrammarParameter> ",")+ -> S39
    //   Comma<GrammarParameter> -> S40
    //   GrammarParameter -> S41
    //   Id -> S42
    pub fn ___state24<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action320(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cGrammarParameter_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state39(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cGrammarParameter_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state40(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::GrammarParameter(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state41(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state42(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 25
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R ";" (*) [EOF]
    //   Grammar = @L "grammar" @R ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, ";" => ActionFn(439);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S47
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state25<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action439(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 26
    //   (<TypeParameter> ",")+ = (*) (<TypeParameter> ",")+ TypeParameter "," [">"]
    //   (<TypeParameter> ",")+ = (*) (<TypeParameter> ",")+ TypeParameter "," ["Id"]
    //   (<TypeParameter> ",")+ = (*) (<TypeParameter> ",")+ TypeParameter "," ["Lifetime"]
    //   (<TypeParameter> ",")+ = (*) (<TypeParameter> ",")+ TypeParameter "," ["MacroId"]
    //   (<TypeParameter> ",")+ = (*) TypeParameter "," [">"]
    //   (<TypeParameter> ",")+ = (*) TypeParameter "," ["Id"]
    //   (<TypeParameter> ",")+ = (*) TypeParameter "," ["Lifetime"]
    //   (<TypeParameter> ",")+ = (*) TypeParameter "," ["MacroId"]
    //   Comma<TypeParameter> = (*) [">"]
    //   Comma<TypeParameter> = (*) (<TypeParameter> ",")+ [">"]
    //   Comma<TypeParameter> = (*) (<TypeParameter> ",")+ TypeParameter [">"]
    //   Comma<TypeParameter> = (*) TypeParameter [">"]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["where"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   TypeParameter = (*) Id [","]
    //   TypeParameter = (*) Id [">"]
    //   TypeParameter = (*) Lifetime [","]
    //   TypeParameter = (*) Lifetime [">"]
    //
    //   ">" -> Reduce(Comma<TypeParameter> =  => ActionFn(390);)
    //   "Id" -> Shift(S32)
    //   "Lifetime" -> Shift(S56)
    //   "MacroId" -> Shift(S33)
    //
    //   (<TypeParameter> ",")+ -> S51
    //   Comma<TypeParameter> -> S52
    //   Id -> S53
    //   Lifetime -> S54
    //   TypeParameter -> S55
    pub fn ___state26<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state56(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action390(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeParameter_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state51(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cTypeParameter_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state52(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state53(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state54(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeParameter(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state55(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 27
    //   Grammar = @L "grammar" @R "where" (*) ";" [EOF]
    //   Grammar = @L "grammar" @R "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S57)
    //
    pub fn ___state27<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state57(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 28
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarTypeParameters ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R (*) "where" ";" GrammarItem+ [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["where"]
    //
    //   "(" -> Shift(S24)
    //   ";" -> Shift(S60)
    //   "<" -> Shift(S26)
    //   "where" -> Shift(S61)
    //
    //   GrammarParameters -> S58
    //   GrammarTypeParameters -> S59
    pub fn ___state28<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state60(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state61(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state58(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                ___Nonterminal::GrammarTypeParameters(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state59(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 29
    //   Grammar = Use+ @L "grammar" @R (*) GrammarParameters ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R (*) "where" ";" GrammarItem+ [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["where"]
    //
    //   "(" -> Shift(S24)
    //   ";" -> Shift(S64)
    //   "<" -> Shift(S26)
    //   "where" -> Shift(S65)
    //
    //   GrammarParameters -> S62
    //   GrammarTypeParameters -> S63
    pub fn ___state29<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state64(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state65(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state62(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                ___Nonterminal::GrammarTypeParameters(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state63(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 30
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["where"]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" (*) @R "where" ";" GrammarItem+ [EOF]
    //
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   "where" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S66
    pub fn ___state30<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state66(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 31
    //   @R = (*) ["]"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["#"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["grammar"]
    //   @R = (*) ["]"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["#"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["Escape"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["Id"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["MacroId"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["pub"]
    //
    //   "]" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S67
    pub fn ___state31<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightBracket, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state67(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 32
    //   Id = "Id" (*) ["]"]
    //   Id = "Id" (*) [":"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["="]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["="]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) [";"]
    //   Id = "Id" (*) ["<"]
    //
    //   ")" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "," -> Reduce(Id = "Id" => ActionFn(73);)
    //   ":" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "::" -> Reduce(Id = "Id" => ActionFn(73);)
    //   ";" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "<" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "=" -> Reduce(Id = "Id" => ActionFn(73);)
    //   ">" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "]" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "{" -> Reduce(Id = "Id" => ActionFn(73);)
    //
    pub fn ___state32<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::RightBracket, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action73(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 33
    //   Id = "MacroId" (*) ["]"]
    //   Id = "MacroId" (*) [":"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) ["="]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["="]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) [";"]
    //   Id = "MacroId" (*) ["<"]
    //
    //   ")" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "," -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   ":" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "::" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   ";" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "<" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "=" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   ">" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "]" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "{" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //
    pub fn ___state33<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::RightBracket, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 34
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarParameters ";" (*) [EOF]
    //   Grammar = @L "grammar" @R GrammarParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarParameters, ";" => ActionFn(435);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S68
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state34<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<Parameter>>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action435(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state68(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 35
    //   Grammar = @L "grammar" @R GrammarParameters "where" (*) ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S69)
    //
    pub fn ___state35<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<Parameter>>,
        ___sym4: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state69(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 36
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters (*) ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters (*) "where" ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters (*) "where" ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S70)
    //   "where" -> Shift(S71)
    //
    pub fn ___state36<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state70(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state71(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 37
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarTypeParameters ";" (*) [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarTypeParameters, ";" => ActionFn(437);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S72
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state37<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action437(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state72(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 38
    //   Grammar = @L "grammar" @R GrammarTypeParameters "where" (*) ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S73)
    //
    pub fn ___state38<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state73(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 39
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ (*) GrammarParameter "," [")"]
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ (*) GrammarParameter "," ["Id"]
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ (*) GrammarParameter "," ["MacroId"]
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")+ (*) [")"]
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")+ (*) GrammarParameter [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [","]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //
    //   ")" -> Reduce(Comma<GrammarParameter> = (<GrammarParameter> ",")+ => ActionFn(322);)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   GrammarParameter -> S74
    //   Id -> S42
    pub fn ___state39<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action322(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cGrammarParameter_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameter(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state74(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state42(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 40
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" [";"]
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" ["where"]
    //
    //   ")" -> Shift(S75)
    //
    pub fn ___state40<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state75(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 41
    //   (<GrammarParameter> ",")+ = GrammarParameter (*) "," [")"]
    //   (<GrammarParameter> ",")+ = GrammarParameter (*) "," ["Id"]
    //   (<GrammarParameter> ",")+ = GrammarParameter (*) "," ["MacroId"]
    //   Comma<GrammarParameter> = GrammarParameter (*) [")"]
    //
    //   ")" -> Reduce(Comma<GrammarParameter> = GrammarParameter => ActionFn(319);)
    //   "," -> Shift(S76)
    //
    pub fn ___state41<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Parameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state76(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action319(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cGrammarParameter_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 42
    //   GrammarParameter = Id (*) ":" TypeRef [")"]
    //   GrammarParameter = Id (*) ":" TypeRef [","]
    //
    //   ":" -> Shift(S77)
    //
    pub fn ___state42<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state77(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 43
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = @L (*) "extern" @R "{" "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" "}" ["#"]
    //   ExternToken = @L (*) "extern" @R "{" "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" "}" ["use"]
    //   MacroId = (*) "MacroId" ["<"]
    //   Nonterminal = @L (*) NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = @L (*) NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = @L (*) NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = @L (*) NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = @L (*) NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = @L (*) NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = @L (*) NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = @L (*) NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = @L (*) NonterminalName @R "=" Alternatives ["use"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" ["="]
    //   NonterminalName = (*) NotMacroId [":"]
    //   NonterminalName = (*) NotMacroId ["="]
    //   NonterminalName = (*) "Escape" [":"]
    //   NonterminalName = (*) "Escape" ["="]
    //   NotMacroId = (*) "Id" [":"]
    //   NotMacroId = (*) "Id" ["="]
    //
    //   "Escape" -> Shift(S81)
    //   "Id" -> Shift(S82)
    //   "MacroId" -> Shift(S83)
    //   "extern" -> Shift(S84)
    //
    //   MacroId -> S78
    //   NonterminalName -> S79
    //   NotMacroId -> S80
    pub fn ___state43<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state83(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Extern, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state84(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state78(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::NonterminalName(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state79(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state80(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 44
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = Annotation+ (*) Annotation ["#"]
    //   Annotation+ = Annotation+ (*) Annotation ["Escape"]
    //   Annotation+ = Annotation+ (*) Annotation ["Id"]
    //   Annotation+ = Annotation+ (*) Annotation ["MacroId"]
    //   Annotation+ = Annotation+ (*) Annotation ["pub"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S86)
    //
    //   @L -> S85
    //   Annotation -> S11
    pub fn ___state44<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state86(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state85(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state11(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 45
    //   GrammarItem = ExternToken (*) [EOF]
    //   GrammarItem = ExternToken (*) ["#"]
    //   GrammarItem = ExternToken (*) ["Escape"]
    //   GrammarItem = ExternToken (*) ["Id"]
    //   GrammarItem = ExternToken (*) ["MacroId"]
    //   GrammarItem = ExternToken (*) ["extern"]
    //   GrammarItem = ExternToken (*) ["pub"]
    //   GrammarItem = ExternToken (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem = ExternToken => ActionFn(10);)
    //   "#" -> Reduce(GrammarItem = ExternToken => ActionFn(10);)
    //   "Escape" -> Reduce(GrammarItem = ExternToken => ActionFn(10);)
    //   "Id" -> Reduce(GrammarItem = ExternToken => ActionFn(10);)
    //   "MacroId" -> Reduce(GrammarItem = ExternToken => ActionFn(10);)
    //   "extern" -> Reduce(GrammarItem = ExternToken => ActionFn(10);)
    //   "pub" -> Reduce(GrammarItem = ExternToken => ActionFn(10);)
    //   "use" -> Reduce(GrammarItem = ExternToken => ActionFn(10);)
    //
    pub fn ___state45<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action10(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 46
    //   GrammarItem+ = GrammarItem (*) [EOF]
    //   GrammarItem+ = GrammarItem (*) ["#"]
    //   GrammarItem+ = GrammarItem (*) ["Escape"]
    //   GrammarItem+ = GrammarItem (*) ["Id"]
    //   GrammarItem+ = GrammarItem (*) ["MacroId"]
    //   GrammarItem+ = GrammarItem (*) ["extern"]
    //   GrammarItem+ = GrammarItem (*) ["pub"]
    //   GrammarItem+ = GrammarItem (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem+ = GrammarItem => ActionFn(140);)
    //   "#" -> Reduce(GrammarItem+ = GrammarItem => ActionFn(140);)
    //   "Escape" -> Reduce(GrammarItem+ = GrammarItem => ActionFn(140);)
    //   "Id" -> Reduce(GrammarItem+ = GrammarItem => ActionFn(140);)
    //   "MacroId" -> Reduce(GrammarItem+ = GrammarItem => ActionFn(140);)
    //   "extern" -> Reduce(GrammarItem+ = GrammarItem => ActionFn(140);)
    //   "pub" -> Reduce(GrammarItem+ = GrammarItem => ActionFn(140);)
    //   "use" -> Reduce(GrammarItem+ = GrammarItem => ActionFn(140);)
    //
    pub fn ___state46<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action140(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 47
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, ";", GrammarItem+ => ActionFn(447);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state47<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action447(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym4, ___sym5));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 48
    //   GrammarItem = Nonterminal (*) [EOF]
    //   GrammarItem = Nonterminal (*) ["#"]
    //   GrammarItem = Nonterminal (*) ["Escape"]
    //   GrammarItem = Nonterminal (*) ["Id"]
    //   GrammarItem = Nonterminal (*) ["MacroId"]
    //   GrammarItem = Nonterminal (*) ["extern"]
    //   GrammarItem = Nonterminal (*) ["pub"]
    //   GrammarItem = Nonterminal (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem = Nonterminal => ActionFn(11);)
    //   "#" -> Reduce(GrammarItem = Nonterminal => ActionFn(11);)
    //   "Escape" -> Reduce(GrammarItem = Nonterminal => ActionFn(11);)
    //   "Id" -> Reduce(GrammarItem = Nonterminal => ActionFn(11);)
    //   "MacroId" -> Reduce(GrammarItem = Nonterminal => ActionFn(11);)
    //   "extern" -> Reduce(GrammarItem = Nonterminal => ActionFn(11);)
    //   "pub" -> Reduce(GrammarItem = Nonterminal => ActionFn(11);)
    //   "use" -> Reduce(GrammarItem = Nonterminal => ActionFn(11);)
    //
    pub fn ___state48<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action11(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 49
    //   GrammarItem = Use (*) [EOF]
    //   GrammarItem = Use (*) ["#"]
    //   GrammarItem = Use (*) ["Escape"]
    //   GrammarItem = Use (*) ["Id"]
    //   GrammarItem = Use (*) ["MacroId"]
    //   GrammarItem = Use (*) ["extern"]
    //   GrammarItem = Use (*) ["pub"]
    //   GrammarItem = Use (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem = Use => ActionFn(9);)
    //   "#" -> Reduce(GrammarItem = Use => ActionFn(9);)
    //   "Escape" -> Reduce(GrammarItem = Use => ActionFn(9);)
    //   "Id" -> Reduce(GrammarItem = Use => ActionFn(9);)
    //   "MacroId" -> Reduce(GrammarItem = Use => ActionFn(9);)
    //   "extern" -> Reduce(GrammarItem = Use => ActionFn(9);)
    //   "pub" -> Reduce(GrammarItem = Use => ActionFn(9);)
    //   "use" -> Reduce(GrammarItem = Use => ActionFn(9);)
    //
    pub fn ___state49<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action9(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 50
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = "pub" (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = "pub" (*) @L NonterminalName @R "=" Alternatives ["use"]
    //
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S88
    pub fn ___state50<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state88(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 51
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ (*) TypeParameter "," [">"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ (*) TypeParameter "," ["Id"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ (*) TypeParameter "," ["Lifetime"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ (*) TypeParameter "," ["MacroId"]
    //   Comma<TypeParameter> = (<TypeParameter> ",")+ (*) [">"]
    //   Comma<TypeParameter> = (<TypeParameter> ",")+ (*) TypeParameter [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   TypeParameter = (*) Id [","]
    //   TypeParameter = (*) Id [">"]
    //   TypeParameter = (*) Lifetime [","]
    //   TypeParameter = (*) Lifetime [">"]
    //
    //   ">" -> Reduce(Comma<TypeParameter> = (<TypeParameter> ",")+ => ActionFn(392);)
    //   "Id" -> Shift(S32)
    //   "Lifetime" -> Shift(S56)
    //   "MacroId" -> Shift(S33)
    //
    //   Id -> S53
    //   Lifetime -> S54
    //   TypeParameter -> S89
    pub fn ___state51<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state56(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action392(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeParameter_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state53(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state54(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeParameter(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state89(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 52
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["("]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" [";"]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["where"]
    //
    //   ">" -> Shift(S90)
    //
    pub fn ___state52<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state90(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 53
    //   TypeParameter = Id (*) [","]
    //   TypeParameter = Id (*) [">"]
    //
    //   "," -> Reduce(TypeParameter = Id => ActionFn(6);)
    //   ">" -> Reduce(TypeParameter = Id => ActionFn(6);)
    //
    pub fn ___state53<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action6(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeParameter(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 54
    //   TypeParameter = Lifetime (*) [","]
    //   TypeParameter = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeParameter = Lifetime => ActionFn(5);)
    //   ">" -> Reduce(TypeParameter = Lifetime => ActionFn(5);)
    //
    pub fn ___state54<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action5(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeParameter(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 55
    //   (<TypeParameter> ",")+ = TypeParameter (*) "," [">"]
    //   (<TypeParameter> ",")+ = TypeParameter (*) "," ["Id"]
    //   (<TypeParameter> ",")+ = TypeParameter (*) "," ["Lifetime"]
    //   (<TypeParameter> ",")+ = TypeParameter (*) "," ["MacroId"]
    //   Comma<TypeParameter> = TypeParameter (*) [">"]
    //
    //   "," -> Shift(S91)
    //   ">" -> Reduce(Comma<TypeParameter> = TypeParameter => ActionFn(389);)
    //
    pub fn ___state55<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeParameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state91(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action389(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeParameter_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 56
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //
    //   "#" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "&" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "(" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "," -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "::" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   ">" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //
    pub fn ___state56<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action76(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 57
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R "where" ";" (*) [EOF]
    //   Grammar = @L "grammar" @R "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, "where", ";" => ActionFn(407);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S92
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state57<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<&'input str>>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action407(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state92(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 58
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters (*) ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters (*) "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters (*) "where" ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S93)
    //   "where" -> Shift(S94)
    //
    pub fn ___state58<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state93(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state94(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 59
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters (*) ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters (*) "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters (*) "where" ";" GrammarItem+ [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //
    //   "(" -> Shift(S24)
    //   ";" -> Shift(S96)
    //   "where" -> Shift(S97)
    //
    //   GrammarParameters -> S95
    pub fn ___state59<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state96(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state97(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state95(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 60
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R ";" (*) [EOF]
    //   Grammar = Annotation+ @L "grammar" @R ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, ";" => ActionFn(455);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S98
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state60<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action455(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state98(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 61
    //   Grammar = Annotation+ @L "grammar" @R "where" (*) ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S99)
    //
    pub fn ___state61<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state99(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 62
    //   Grammar = Use+ @L "grammar" @R GrammarParameters (*) ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters (*) "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters (*) "where" ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S100)
    //   "where" -> Shift(S101)
    //
    pub fn ___state62<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state100(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state101(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 63
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters (*) ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters (*) "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters (*) "where" ";" GrammarItem+ [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //
    //   "(" -> Shift(S24)
    //   ";" -> Shift(S103)
    //   "where" -> Shift(S104)
    //
    //   GrammarParameters -> S102
    pub fn ___state63<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state103(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state104(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state102(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 64
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R ";" (*) [EOF]
    //   Grammar = Use+ @L "grammar" @R ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, ";" => ActionFn(440);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S105
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state64<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action440(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state105(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 65
    //   Grammar = Use+ @L "grammar" @R "where" (*) ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S106)
    //
    pub fn ___state65<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state106(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 66
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarTypeParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarTypeParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarTypeParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) GrammarTypeParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R (*) "where" ";" GrammarItem+ [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["where"]
    //
    //   "(" -> Shift(S24)
    //   ";" -> Shift(S109)
    //   "<" -> Shift(S26)
    //   "where" -> Shift(S110)
    //
    //   GrammarParameters -> S107
    //   GrammarTypeParameters -> S108
    pub fn ___state66<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state109(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state110(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state107(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::GrammarTypeParameters(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state108(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 67
    //   Annotation = "#" "[" @L Id @R (*) "]" ["#"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["grammar"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["#"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["Escape"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["Id"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["MacroId"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["pub"]
    //
    //   "]" -> Shift(S111)
    //
    pub fn ___state67<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBracket, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state111(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 68
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarParameters, ";", GrammarItem+ => ActionFn(443);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state68<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<Parameter>>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action443(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 69
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarParameters "where" ";" (*) [EOF]
    //   Grammar = @L "grammar" @R GrammarParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarParameters, "where", ";" => ActionFn(403);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S112
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state69<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<Parameter>>,
        ___sym4: &mut Option<Vec<&'input str>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action403(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state112(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 70
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters ";" (*) [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, ";" => ActionFn(433);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S113
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state70<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action433(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state113(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 71
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters "where" (*) ";" [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S114)
    //
    pub fn ___state71<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state114(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 72
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarTypeParameters, ";", GrammarItem+ => ActionFn(445);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state72<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action445(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 73
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarTypeParameters "where" ";" (*) [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarTypeParameters, "where", ";" => ActionFn(405);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S115
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state73<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<&'input str>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action405(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state115(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 74
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ GrammarParameter (*) "," [")"]
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ GrammarParameter (*) "," ["Id"]
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ GrammarParameter (*) "," ["MacroId"]
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")+ GrammarParameter (*) [")"]
    //
    //   ")" -> Reduce(Comma<GrammarParameter> = (<GrammarParameter> ",")+, GrammarParameter => ActionFn(321);)
    //   "," -> Shift(S116)
    //
    pub fn ___state74<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Parameter>>,
        ___sym1: &mut Option<Parameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state116(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action321(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cGrammarParameter_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 75
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) [";"]
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) ["where"]
    //
    //   ";" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => ActionFn(7);)
    //   "where" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => ActionFn(7);)
    //
    pub fn ___state75<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Parameter>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action7(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarParameters(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 76
    //   (<GrammarParameter> ",")+ = GrammarParameter "," (*) [")"]
    //   (<GrammarParameter> ",")+ = GrammarParameter "," (*) ["Id"]
    //   (<GrammarParameter> ",")+ = GrammarParameter "," (*) ["MacroId"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",")+ = GrammarParameter, "," => ActionFn(243);)
    //   "Id" -> Reduce((<GrammarParameter> ",")+ = GrammarParameter, "," => ActionFn(243);)
    //   "MacroId" -> Reduce((<GrammarParameter> ",")+ = GrammarParameter, "," => ActionFn(243);)
    //
    pub fn ___state76<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Parameter>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action243(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 77
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   GrammarParameter = Id ":" (*) TypeRef [")"]
    //   GrammarParameter = Id ":" (*) TypeRef [","]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S120
    pub fn ___state77<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state120(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 78
    //   NonterminalName = MacroId (*) "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = MacroId (*) "<" Comma<NotMacroId> ">" ["="]
    //
    //   "<" -> Shift(S125)
    //
    pub fn ___state78<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state125(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 79
    //   @R = (*) [":"]
    //   @R = (*) ["="]
    //   Nonterminal = @L NonterminalName (*) @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = @L NonterminalName (*) @R "=" Alternatives [EOF]
    //   Nonterminal = @L NonterminalName (*) @R "=" Alternatives ["#"]
    //   Nonterminal = @L NonterminalName (*) @R "=" Alternatives ["Escape"]
    //   Nonterminal = @L NonterminalName (*) @R "=" Alternatives ["Id"]
    //   Nonterminal = @L NonterminalName (*) @R "=" Alternatives ["MacroId"]
    //   Nonterminal = @L NonterminalName (*) @R "=" Alternatives ["extern"]
    //   Nonterminal = @L NonterminalName (*) @R "=" Alternatives ["pub"]
    //   Nonterminal = @L NonterminalName (*) @R "=" Alternatives ["use"]
    //
    //   ":" -> Reduce(@R =  => ActionFn(130);)
    //   "=" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S126
    pub fn ___state79<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state126(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 80
    //   NonterminalName = NotMacroId (*) [":"]
    //   NonterminalName = NotMacroId (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = NotMacroId => ActionFn(16);)
    //   "=" -> Reduce(NonterminalName = NotMacroId => ActionFn(16);)
    //
    pub fn ___state80<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action16(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NonterminalName(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 81
    //   NonterminalName = "Escape" (*) [":"]
    //   NonterminalName = "Escape" (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = "Escape" => ActionFn(17);)
    //   "=" -> Reduce(NonterminalName = "Escape" => ActionFn(17);)
    //
    pub fn ___state81<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action17(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NonterminalName(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 82
    //   NotMacroId = "Id" (*) [":"]
    //   NotMacroId = "Id" (*) ["="]
    //   NotMacroId = "Id" (*) [","]
    //   NotMacroId = "Id" (*) [">"]
    //   NotMacroId = "Id" (*) ["!="]
    //   NotMacroId = "Id" (*) ["!~"]
    //   NotMacroId = "Id" (*) ["=="]
    //   NotMacroId = "Id" (*) ["~~"]
    //
    //   "!=" -> Reduce(NotMacroId = "Id" => ActionFn(72);)
    //   "!~" -> Reduce(NotMacroId = "Id" => ActionFn(72);)
    //   "," -> Reduce(NotMacroId = "Id" => ActionFn(72);)
    //   ":" -> Reduce(NotMacroId = "Id" => ActionFn(72);)
    //   "=" -> Reduce(NotMacroId = "Id" => ActionFn(72);)
    //   "==" -> Reduce(NotMacroId = "Id" => ActionFn(72);)
    //   ">" -> Reduce(NotMacroId = "Id" => ActionFn(72);)
    //   "~~" -> Reduce(NotMacroId = "Id" => ActionFn(72);)
    //
    pub fn ___state82<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::BangEquals, _)) |
            Some((_, Tok::BangTilde, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::EqualsEquals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::TildeTilde, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action72(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NotMacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 83
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => ActionFn(71);)
    //
    pub fn ___state83<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action71(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 84
    //   @R = (*) ["{"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken "}" ["#"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" EnumToken "}" ["use"]
    //   ExternToken = @L "extern" (*) @R "{" "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" "}" ["#"]
    //   ExternToken = @L "extern" (*) @R "{" "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" "}" ["use"]
    //
    //   "{" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S127
    pub fn ___state84<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state127(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 85
    //   MacroId = (*) "MacroId" ["<"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L (*) NonterminalName @R "=" Alternatives ["use"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" ["="]
    //   NonterminalName = (*) NotMacroId [":"]
    //   NonterminalName = (*) NotMacroId ["="]
    //   NonterminalName = (*) "Escape" [":"]
    //   NonterminalName = (*) "Escape" ["="]
    //   NotMacroId = (*) "Id" [":"]
    //   NotMacroId = (*) "Id" ["="]
    //
    //   "Escape" -> Shift(S81)
    //   "Id" -> Shift(S82)
    //   "MacroId" -> Shift(S83)
    //
    //   MacroId -> S78
    //   NonterminalName -> S128
    //   NotMacroId -> S80
    pub fn ___state85<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state83(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state78(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::NonterminalName(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state128(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state80(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 86
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" (*) @L NonterminalName @R "=" Alternatives ["use"]
    //
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S129
    pub fn ___state86<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state129(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 87
    //   GrammarItem+ = GrammarItem+ GrammarItem (*) [EOF]
    //   GrammarItem+ = GrammarItem+ GrammarItem (*) ["#"]
    //   GrammarItem+ = GrammarItem+ GrammarItem (*) ["Escape"]
    //   GrammarItem+ = GrammarItem+ GrammarItem (*) ["Id"]
    //   GrammarItem+ = GrammarItem+ GrammarItem (*) ["MacroId"]
    //   GrammarItem+ = GrammarItem+ GrammarItem (*) ["extern"]
    //   GrammarItem+ = GrammarItem+ GrammarItem (*) ["pub"]
    //   GrammarItem+ = GrammarItem+ GrammarItem (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem+ = GrammarItem+, GrammarItem => ActionFn(141);)
    //   "#" -> Reduce(GrammarItem+ = GrammarItem+, GrammarItem => ActionFn(141);)
    //   "Escape" -> Reduce(GrammarItem+ = GrammarItem+, GrammarItem => ActionFn(141);)
    //   "Id" -> Reduce(GrammarItem+ = GrammarItem+, GrammarItem => ActionFn(141);)
    //   "MacroId" -> Reduce(GrammarItem+ = GrammarItem+, GrammarItem => ActionFn(141);)
    //   "extern" -> Reduce(GrammarItem+ = GrammarItem+, GrammarItem => ActionFn(141);)
    //   "pub" -> Reduce(GrammarItem+ = GrammarItem+, GrammarItem => ActionFn(141);)
    //   "use" -> Reduce(GrammarItem+ = GrammarItem+, GrammarItem => ActionFn(141);)
    //
    pub fn ___state87<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action141(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 88
    //   MacroId = (*) "MacroId" ["<"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = "pub" @L (*) NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = "pub" @L (*) NonterminalName @R "=" Alternatives ["use"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" ["="]
    //   NonterminalName = (*) NotMacroId [":"]
    //   NonterminalName = (*) NotMacroId ["="]
    //   NonterminalName = (*) "Escape" [":"]
    //   NonterminalName = (*) "Escape" ["="]
    //   NotMacroId = (*) "Id" [":"]
    //   NotMacroId = (*) "Id" ["="]
    //
    //   "Escape" -> Shift(S81)
    //   "Id" -> Shift(S82)
    //   "MacroId" -> Shift(S83)
    //
    //   MacroId -> S78
    //   NonterminalName -> S130
    //   NotMacroId -> S80
    pub fn ___state88<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state83(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state78(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::NonterminalName(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state130(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state80(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 89
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ TypeParameter (*) "," [">"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ TypeParameter (*) "," ["Id"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ TypeParameter (*) "," ["Lifetime"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ TypeParameter (*) "," ["MacroId"]
    //   Comma<TypeParameter> = (<TypeParameter> ",")+ TypeParameter (*) [">"]
    //
    //   "," -> Shift(S131)
    //   ">" -> Reduce(Comma<TypeParameter> = (<TypeParameter> ",")+, TypeParameter => ActionFn(391);)
    //
    pub fn ___state89<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
        ___sym1: &mut Option<TypeParameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state131(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action391(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeParameter_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 90
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["("]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) [";"]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["where"]
    //
    //   "(" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => ActionFn(4);)
    //   ";" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => ActionFn(4);)
    //   "where" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => ActionFn(4);)
    //
    pub fn ___state90<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeParameter>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action4(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarTypeParameters(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 91
    //   (<TypeParameter> ",")+ = TypeParameter "," (*) [">"]
    //   (<TypeParameter> ",")+ = TypeParameter "," (*) ["Id"]
    //   (<TypeParameter> ",")+ = TypeParameter "," (*) ["Lifetime"]
    //   (<TypeParameter> ",")+ = TypeParameter "," (*) ["MacroId"]
    //
    //   ">" -> Reduce((<TypeParameter> ",")+ = TypeParameter, "," => ActionFn(265);)
    //   "Id" -> Reduce((<TypeParameter> ",")+ = TypeParameter, "," => ActionFn(265);)
    //   "Lifetime" -> Reduce((<TypeParameter> ",")+ = TypeParameter, "," => ActionFn(265);)
    //   "MacroId" -> Reduce((<TypeParameter> ",")+ = TypeParameter, "," => ActionFn(265);)
    //
    pub fn ___state91<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeParameter>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action265(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 92
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, "where", ";", GrammarItem+ => ActionFn(415);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state92<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<&'input str>>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action415(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 93
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters ";" (*) [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarParameters, ";" => ActionFn(451);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S132
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state93<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action451(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state132(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 94
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters "where" (*) ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S133)
    //
    pub fn ___state94<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state133(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 95
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) "where" ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) "where" ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S134)
    //   "where" -> Shift(S135)
    //
    pub fn ___state95<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state134(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state135(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 96
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters ";" (*) [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarTypeParameters, ";" => ActionFn(453);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S136
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state96<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action453(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state136(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 97
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters "where" (*) ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S137)
    //
    pub fn ___state97<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state137(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 98
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, ";", GrammarItem+ => ActionFn(463);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state98<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action463(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 99
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R "where" ";" (*) [EOF]
    //   Grammar = Annotation+ @L "grammar" @R "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, "where", ";" => ActionFn(423);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S138
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state99<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<&'input str>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action423(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state138(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 100
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters ";" (*) [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarParameters, ";" => ActionFn(436);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S139
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state100<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action436(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state139(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 101
    //   Grammar = Use+ @L "grammar" @R GrammarParameters "where" (*) ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S140)
    //
    pub fn ___state101<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state140(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 102
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) "where" ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) "where" ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S141)
    //   "where" -> Shift(S142)
    //
    pub fn ___state102<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state141(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state142(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 103
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters ";" (*) [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarTypeParameters, ";" => ActionFn(438);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S143
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state103<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action438(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state143(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 104
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters "where" (*) ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S144)
    //
    pub fn ___state104<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state144(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 105
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, ";", GrammarItem+ => ActionFn(448);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state105<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action448(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 106
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R "where" ";" (*) [EOF]
    //   Grammar = Use+ @L "grammar" @R "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, "where", ";" => ActionFn(408);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S145
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state106<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<&'input str>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action408(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state145(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 107
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters (*) ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters (*) "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters (*) "where" ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S146)
    //   "where" -> Shift(S147)
    //
    pub fn ___state107<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state146(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state147(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 108
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters (*) GrammarParameters "where" ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters (*) ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters (*) "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters (*) "where" ";" GrammarItem+ [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //
    //   "(" -> Shift(S24)
    //   ";" -> Shift(S149)
    //   "where" -> Shift(S150)
    //
    //   GrammarParameters -> S148
    pub fn ___state108<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state149(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state150(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state148(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 109
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R ";" (*) [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, ";" => ActionFn(456);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S151
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state109<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action456(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state151(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 110
    //   Grammar = Use+ Annotation+ @L "grammar" @R "where" (*) ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S152)
    //
    pub fn ___state110<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state152(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 111
    //   Annotation = "#" "[" @L Id @R "]" (*) ["#"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["grammar"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["#"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["Escape"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["Id"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["MacroId"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["pub"]
    //
    //   "#" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => ActionFn(14);)
    //   "Escape" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => ActionFn(14);)
    //   "Id" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => ActionFn(14);)
    //   "MacroId" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => ActionFn(14);)
    //   "grammar" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => ActionFn(14);)
    //   "pub" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => ActionFn(14);)
    //
    pub fn ___state111<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Pub, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action14(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Annotation(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 112
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarParameters, "where", ";", GrammarItem+ => ActionFn(411);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state112<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<Parameter>>,
        ___sym4: &mut Option<Vec<&'input str>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action411(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 113
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, ";", GrammarItem+ => ActionFn(441);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state113<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action441(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 114
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" (*) [EOF]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, "where", ";" => ActionFn(401);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S153
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state114<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action401(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state153(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 115
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarTypeParameters, "where", ";", GrammarItem+ => ActionFn(413);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state115<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<&'input str>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action413(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 116
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ GrammarParameter "," (*) [")"]
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ GrammarParameter "," (*) ["Id"]
    //   (<GrammarParameter> ",")+ = (<GrammarParameter> ",")+ GrammarParameter "," (*) ["MacroId"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",")+ = (<GrammarParameter> ",")+, GrammarParameter, "," => ActionFn(244);)
    //   "Id" -> Reduce((<GrammarParameter> ",")+ = (<GrammarParameter> ",")+, GrammarParameter, "," => ActionFn(244);)
    //   "MacroId" -> Reduce((<GrammarParameter> ",")+ = (<GrammarParameter> ",")+, GrammarParameter, "," => ActionFn(244);)
    //
    pub fn ___state116<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Parameter>>,
        ___sym1: &mut Option<Parameter>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action244(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 117
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (<Id> "::")+ (*) Id [")"]
    //   Path = (<Id> "::")+ (*) Id [","]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (<Id> "::")+ (*) Id [","]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   Path = (<Id> "::")+ (*) Id [">"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   Path = (<Id> "::")+ (*) Id ["="]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   Path = (<Id> "::")+ (*) Id ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (<Id> "::")+ (*) Id [";"]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   Id -> S154
    pub fn ___state117<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state154(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 118
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [")"]
    //   Path = Id (*) [","]
    //   Path = Id (*) ["<"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [","]
    //   Path = Id (*) ["<"]
    //   Path = Id (*) [">"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) ["<"]
    //   Path = Id (*) ["="]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) ["<"]
    //   Path = Id (*) ["{"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [";"]
    //   Path = Id (*) ["<"]
    //
    //   ")" -> Reduce(Path = Id => ActionFn(251);)
    //   "," -> Reduce(Path = Id => ActionFn(251);)
    //   "::" -> Shift(S155)
    //   ";" -> Reduce(Path = Id => ActionFn(251);)
    //   "<" -> Reduce(Path = Id => ActionFn(251);)
    //   "=" -> Reduce(Path = Id => ActionFn(251);)
    //   ">" -> Reduce(Path = Id => ActionFn(251);)
    //   "{" -> Reduce(Path = Id => ActionFn(251);)
    //
    pub fn ___state118<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state155(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action251(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 119
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path (*) ["="]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = Path (*) ["{"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = Path (*) [";"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [";"]
    //
    //   ")" -> Reduce(TypeRef = Path => ActionFn(52);)
    //   "," -> Reduce(TypeRef = Path => ActionFn(52);)
    //   ";" -> Reduce(TypeRef = Path => ActionFn(52);)
    //   "<" -> Shift(S156)
    //   "=" -> Reduce(TypeRef = Path => ActionFn(52);)
    //   ">" -> Reduce(TypeRef = Path => ActionFn(52);)
    //   "{" -> Reduce(TypeRef = Path => ActionFn(52);)
    //
    pub fn ___state119<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state156(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action52(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 120
    //   GrammarParameter = Id ":" TypeRef (*) [")"]
    //   GrammarParameter = Id ":" TypeRef (*) [","]
    //
    //   ")" -> Reduce(GrammarParameter = Id, ":", TypeRef => ActionFn(8);)
    //   "," -> Reduce(GrammarParameter = Id, ":", TypeRef => ActionFn(8);)
    //
    pub fn ___state120<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action8(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarParameter(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 121
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" ["="]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" ["{"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [";"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S157
    //   Symbol -> S158
    //   Symbol0 -> S159
    //   Symbol1 -> S160
    pub fn ___state121<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state157(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state158(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state159(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 122
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = "&" (*) Lifetime TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = "&" (*) TypeRef [")"]
    //   TypeRef = "&" (*) TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = "&" (*) "mut" TypeRef [")"]
    //   TypeRef = "&" (*) "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = "&" (*) Lifetime TypeRef [","]
    //   TypeRef = "&" (*) Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = "&" (*) TypeRef [","]
    //   TypeRef = "&" (*) TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = "&" (*) "mut" TypeRef [","]
    //   TypeRef = "&" (*) "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["="]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["="]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["="]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime TypeRef ["="]
    //   TypeRef = "&" (*) Lifetime TypeRef ["="]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["="]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef ["="]
    //   TypeRef = (*) "&" TypeRef ["="]
    //   TypeRef = "&" (*) TypeRef ["="]
    //   TypeRef = (*) "&" "mut" TypeRef ["="]
    //   TypeRef = "&" (*) "mut" TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["{"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["{"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["{"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime TypeRef ["{"]
    //   TypeRef = "&" (*) Lifetime TypeRef ["{"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["{"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef ["{"]
    //   TypeRef = (*) "&" TypeRef ["{"]
    //   TypeRef = "&" (*) TypeRef ["{"]
    //   TypeRef = (*) "&" "mut" TypeRef ["{"]
    //   TypeRef = "&" (*) "mut" TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id [";"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [";"]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [";"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [";"]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime TypeRef [";"]
    //   TypeRef = "&" (*) Lifetime TypeRef [";"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [";"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [";"]
    //   TypeRef = (*) "&" TypeRef [";"]
    //   TypeRef = "&" (*) TypeRef [";"]
    //   TypeRef = (*) "&" "mut" TypeRef [";"]
    //   TypeRef = "&" (*) "mut" TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "Lifetime" -> Shift(S56)
    //   "MacroId" -> Shift(S33)
    //   "mut" -> Shift(S163)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Lifetime -> S161
    //   Path -> S119
    //   TypeRef -> S162
    pub fn ___state122<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state56(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state163(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state161(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state162(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 123
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" ["="]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" ["{"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   ")" -> Reduce(Comma<TypeRef> =  => ActionFn(394);)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   (<TypeRef> ",")+ -> S164
    //   Comma<TypeRef> -> S165
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S166
    pub fn ___state123<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action394(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state164(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cTypeRef_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state165(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state166(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 124
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [")"]
    //   Path = "::" (*) (<Id> "::")+ Id [","]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) Id [")"]
    //   Path = "::" (*) Id [","]
    //   Path = "::" (*) Id ["<"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::" (*) (<Id> "::")+ Id [","]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [">"]
    //   Path = "::" (*) Id [","]
    //   Path = "::" (*) Id ["<"]
    //   Path = "::" (*) Id [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id ["="]
    //   Path = "::" (*) Id ["<"]
    //   Path = "::" (*) Id ["="]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id ["{"]
    //   Path = "::" (*) Id ["<"]
    //   Path = "::" (*) Id ["{"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [";"]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) Id [";"]
    //   Path = "::" (*) Id ["<"]
    //
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S167
    //   Id -> S168
    pub fn ___state124<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state167(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state168(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 125
    //   (<NotMacroId> ",")+ = (*) (<NotMacroId> ",")+ NotMacroId "," [">"]
    //   (<NotMacroId> ",")+ = (*) (<NotMacroId> ",")+ NotMacroId "," ["Id"]
    //   (<NotMacroId> ",")+ = (*) NotMacroId "," [">"]
    //   (<NotMacroId> ",")+ = (*) NotMacroId "," ["Id"]
    //   Comma<NotMacroId> = (*) [">"]
    //   Comma<NotMacroId> = (*) (<NotMacroId> ",")+ [">"]
    //   Comma<NotMacroId> = (*) (<NotMacroId> ",")+ NotMacroId [">"]
    //   Comma<NotMacroId> = (*) NotMacroId [">"]
    //   NonterminalName = MacroId "<" (*) Comma<NotMacroId> ">" [":"]
    //   NonterminalName = MacroId "<" (*) Comma<NotMacroId> ">" ["="]
    //   NotMacroId = (*) "Id" [","]
    //   NotMacroId = (*) "Id" [">"]
    //
    //   ">" -> Reduce(Comma<NotMacroId> =  => ActionFn(376);)
    //   "Id" -> Shift(S82)
    //
    //   (<NotMacroId> ",")+ -> S169
    //   Comma<NotMacroId> -> S170
    //   NotMacroId -> S171
    pub fn ___state125<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action376(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cNotMacroId_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state169(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cNotMacroId_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state170(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state171(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 126
    //   Nonterminal = @L NonterminalName @R (*) ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = @L NonterminalName @R (*) "=" Alternatives [EOF]
    //   Nonterminal = @L NonterminalName @R (*) "=" Alternatives ["#"]
    //   Nonterminal = @L NonterminalName @R (*) "=" Alternatives ["Escape"]
    //   Nonterminal = @L NonterminalName @R (*) "=" Alternatives ["Id"]
    //   Nonterminal = @L NonterminalName @R (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = @L NonterminalName @R (*) "=" Alternatives ["extern"]
    //   Nonterminal = @L NonterminalName @R (*) "=" Alternatives ["pub"]
    //   Nonterminal = @L NonterminalName @R (*) "=" Alternatives ["use"]
    //
    //   ":" -> Shift(S172)
    //   "=" -> Shift(S173)
    //
    pub fn ___state126<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state172(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state173(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 127
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken "}" ["#"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" EnumToken "}" ["use"]
    //   ExternToken = @L "extern" @R (*) "{" "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" "}" ["#"]
    //   ExternToken = @L "extern" @R (*) "{" "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" "}" ["use"]
    //
    //   "{" -> Shift(S174)
    //
    pub fn ___state127<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state174(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 128
    //   @R = (*) [":"]
    //   @R = (*) ["="]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName (*) @R "=" Alternatives ["use"]
    //
    //   ":" -> Reduce(@R =  => ActionFn(130);)
    //   "=" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S175
    pub fn ___state128<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state175(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 129
    //   MacroId = (*) "MacroId" ["<"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L (*) NonterminalName @R "=" Alternatives ["use"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" ["="]
    //   NonterminalName = (*) NotMacroId [":"]
    //   NonterminalName = (*) NotMacroId ["="]
    //   NonterminalName = (*) "Escape" [":"]
    //   NonterminalName = (*) "Escape" ["="]
    //   NotMacroId = (*) "Id" [":"]
    //   NotMacroId = (*) "Id" ["="]
    //
    //   "Escape" -> Shift(S81)
    //   "Id" -> Shift(S82)
    //   "MacroId" -> Shift(S83)
    //
    //   MacroId -> S78
    //   NonterminalName -> S176
    //   NotMacroId -> S80
    pub fn ___state129<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state83(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state78(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::NonterminalName(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state176(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state80(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 130
    //   @R = (*) [":"]
    //   @R = (*) ["="]
    //   Nonterminal = "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R "=" Alternatives [EOF]
    //   Nonterminal = "pub" @L NonterminalName (*) @R "=" Alternatives ["#"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R "=" Alternatives ["Id"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R "=" Alternatives ["extern"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R "=" Alternatives ["pub"]
    //   Nonterminal = "pub" @L NonterminalName (*) @R "=" Alternatives ["use"]
    //
    //   ":" -> Reduce(@R =  => ActionFn(130);)
    //   "=" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S177
    pub fn ___state130<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state177(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 131
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ TypeParameter "," (*) [">"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ TypeParameter "," (*) ["Id"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ TypeParameter "," (*) ["Lifetime"]
    //   (<TypeParameter> ",")+ = (<TypeParameter> ",")+ TypeParameter "," (*) ["MacroId"]
    //
    //   ">" -> Reduce((<TypeParameter> ",")+ = (<TypeParameter> ",")+, TypeParameter, "," => ActionFn(266);)
    //   "Id" -> Reduce((<TypeParameter> ",")+ = (<TypeParameter> ",")+, TypeParameter, "," => ActionFn(266);)
    //   "Lifetime" -> Reduce((<TypeParameter> ",")+ = (<TypeParameter> ",")+, TypeParameter, "," => ActionFn(266);)
    //   "MacroId" -> Reduce((<TypeParameter> ",")+ = (<TypeParameter> ",")+, TypeParameter, "," => ActionFn(266);)
    //
    pub fn ___state131<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
        ___sym1: &mut Option<TypeParameter>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action266(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 132
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarParameters, ";", GrammarItem+ => ActionFn(459);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state132<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action459(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 133
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters "where" ";" (*) [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarParameters, "where", ";" => ActionFn(419);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S178
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state133<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action419(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state178(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 134
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" (*) [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, ";" => ActionFn(449);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S179
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state134<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action449(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state179(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 135
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" (*) ";" [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S180)
    //
    pub fn ___state135<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state180(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 136
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarTypeParameters, ";", GrammarItem+ => ActionFn(461);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state136<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action461(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 137
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" (*) [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarTypeParameters, "where", ";" => ActionFn(421);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S181
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state137<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action421(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state181(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 138
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, "where", ";", GrammarItem+ => ActionFn(431);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state138<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<&'input str>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action431(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 139
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarParameters, ";", GrammarItem+ => ActionFn(444);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state139<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action444(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 140
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters "where" ";" (*) [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarParameters, "where", ";" => ActionFn(404);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S182
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state140<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action404(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state182(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 141
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" (*) [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, ";" => ActionFn(434);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S183
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state141<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action434(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state183(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 142
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" (*) ";" [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S184)
    //
    pub fn ___state142<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state184(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 143
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarTypeParameters, ";", GrammarItem+ => ActionFn(446);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state143<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action446(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 144
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters "where" ";" (*) [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarTypeParameters, "where", ";" => ActionFn(406);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S185
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state144<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action406(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state185(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 145
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, "where", ";", GrammarItem+ => ActionFn(416);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state145<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<&'input str>>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action416(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 146
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters ";" (*) [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarParameters, ";" => ActionFn(452);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S186
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state146<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action452(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state186(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 147
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters "where" (*) ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S187)
    //
    pub fn ___state147<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state187(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 148
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) ";" GrammarItem+ [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) "where" ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters (*) "where" ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S188)
    //   "where" -> Shift(S189)
    //
    pub fn ___state148<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state188(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state189(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 149
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters ";" (*) [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarTypeParameters, ";" => ActionFn(454);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S190
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state149<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action454(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state190(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 150
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters "where" (*) ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S191)
    //
    pub fn ___state150<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state191(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 151
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, ";", GrammarItem+ => ActionFn(464);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state151<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action464(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 152
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R "where" ";" (*) [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, "where", ";" => ActionFn(424);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S192
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state152<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action424(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state192(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 153
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, "where", ";", GrammarItem+ => ActionFn(409);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state153<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Vec<TypeParameter>>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action409(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 154
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [")"]
    //   Path = (<Id> "::")+ Id (*) [","]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [","]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   Path = (<Id> "::")+ Id (*) [">"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   Path = (<Id> "::")+ Id (*) ["="]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   Path = (<Id> "::")+ Id (*) ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [";"]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //
    //   ")" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "," -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "::" -> Shift(S193)
    //   ";" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "<" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "=" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   ">" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "{" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //
    pub fn ___state154<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state193(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action252(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 155
    //   (<Id> "::")+ = Id "::" (*) ["Id"]
    //   (<Id> "::")+ = Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")+ = Id, "::" => ActionFn(247);)
    //   "MacroId" -> Reduce((<Id> "::")+ = Id, "::" => ActionFn(247);)
    //
    pub fn ___state155<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action247(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 156
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> =  => ActionFn(398);)
    //   "Id" -> Shift(S32)
    //   "Lifetime" -> Shift(S56)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   (<TypeRefOrLifetime> ",")+ -> S194
    //   Comma<TypeRefOrLifetime> -> S195
    //   Id -> S118
    //   Lifetime -> S196
    //   Path -> S119
    //   TypeRef -> S197
    //   TypeRefOrLifetime -> S198
    pub fn ___state156<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state56(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action398(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state194(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state195(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state196(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state197(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state198(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 157
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["#"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["#"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral [")"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" [")"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [";"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["=>"]
    //   Escape = (*) "Escape" ["=>?"]
    //   Escape = (*) "Escape" ["=>@L"]
    //   Escape = (*) "Escape" ["=>@R"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   Escape = (*) "Escape" ["if"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [";"]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["=>"]
    //   QuotedTerminal = (*) RegexLiteral ["=>?"]
    //   QuotedTerminal = (*) RegexLiteral ["=>@L"]
    //   QuotedTerminal = (*) RegexLiteral ["=>@R"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["if"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [";"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["=>"]
    //   QuotedTerminal = (*) StringLiteral ["=>?"]
    //   QuotedTerminal = (*) StringLiteral ["=>@L"]
    //   QuotedTerminal = (*) StringLiteral ["=>@R"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["if"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [";"]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>?"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["if"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [";"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["if"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [";"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [";"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["if"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [";"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["=>"]
    //   SymbolKind1 = (*) Escape ["=>?"]
    //   SymbolKind1 = (*) Escape ["=>@L"]
    //   SymbolKind1 = (*) Escape ["=>@R"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["if"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [";"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [";"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>?"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["if"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [";"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["if"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [";"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["=>"]
    //   SymbolKind1 = (*) "@L" ["=>?"]
    //   SymbolKind1 = (*) "@L" ["=>@L"]
    //   SymbolKind1 = (*) "@L" ["=>@R"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["if"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [";"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["=>"]
    //   SymbolKind1 = (*) "@R" ["=>?"]
    //   SymbolKind1 = (*) "@R" ["=>@L"]
    //   SymbolKind1 = (*) "@R" ["=>@R"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["if"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [";"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["=>"]
    //   SymbolKind1 = (*) "Id" ["=>?"]
    //   SymbolKind1 = (*) "Id" ["=>@L"]
    //   SymbolKind1 = (*) "Id" ["=>@R"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["if"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [","]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [","]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["=>"]
    //   Escape = (*) "Escape" ["=>?"]
    //   Escape = (*) "Escape" ["=>@L"]
    //   Escape = (*) "Escape" ["=>@R"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   Escape = (*) "Escape" ["if"]
    //   Escape = (*) "Escape" ["}"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [","]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["=>"]
    //   QuotedTerminal = (*) RegexLiteral ["=>?"]
    //   QuotedTerminal = (*) RegexLiteral ["=>@L"]
    //   QuotedTerminal = (*) RegexLiteral ["=>@R"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["if"]
    //   QuotedTerminal = (*) RegexLiteral ["}"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["=>"]
    //   QuotedTerminal = (*) StringLiteral ["=>?"]
    //   QuotedTerminal = (*) StringLiteral ["=>@L"]
    //   QuotedTerminal = (*) StringLiteral ["=>@R"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["if"]
    //   QuotedTerminal = (*) StringLiteral ["}"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [","]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>?"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["if"]
    //   RegexLiteral = (*) "RegexLiteral" ["}"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["if"]
    //   StringLiteral = (*) "StringLiteral" ["}"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["}"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["if"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["}"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["}"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["=>"]
    //   SymbolKind1 = (*) Escape ["=>?"]
    //   SymbolKind1 = (*) Escape ["=>@L"]
    //   SymbolKind1 = (*) Escape ["=>@R"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["if"]
    //   SymbolKind1 = (*) Escape ["}"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["}"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>?"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["if"]
    //   SymbolKind1 = (*) QuotedTerminal ["}"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["if"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["}"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["=>"]
    //   SymbolKind1 = (*) "@L" ["=>?"]
    //   SymbolKind1 = (*) "@L" ["=>@L"]
    //   SymbolKind1 = (*) "@L" ["=>@R"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["if"]
    //   SymbolKind1 = (*) "@L" ["}"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["=>"]
    //   SymbolKind1 = (*) "@R" ["=>?"]
    //   SymbolKind1 = (*) "@R" ["=>@L"]
    //   SymbolKind1 = (*) "@R" ["=>@R"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["if"]
    //   SymbolKind1 = (*) "@R" ["}"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["=>"]
    //   SymbolKind1 = (*) "Id" ["=>?"]
    //   SymbolKind1 = (*) "Id" ["=>@L"]
    //   SymbolKind1 = (*) "Id" ["=>@R"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["if"]
    //   SymbolKind1 = (*) "Id" ["}"]
    //
    //   "(" -> Shift(S205)
    //   "<" -> Shift(S206)
    //   "@L" -> Shift(S207)
    //   "@R" -> Shift(S208)
    //   "Escape" -> Shift(S209)
    //   "Id" -> Shift(S210)
    //   "MacroId" -> Shift(S83)
    //   "RegexLiteral" -> Shift(S211)
    //   "StringLiteral" -> Shift(S212)
    //
    //   Escape -> S199
    //   MacroId -> S200
    //   QuotedTerminal -> S201
    //   RegexLiteral -> S202
    //   StringLiteral -> S203
    //   SymbolKind1 -> S204
    pub fn ___state157<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state205(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state206(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state207(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state208(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state209(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state210(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state83(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state211(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state212(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state199(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state200(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state201(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state202(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state203(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state204(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 158
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //   TypeRef = "#" Symbol (*) "#" ["="]
    //   TypeRef = "#" Symbol (*) "#" ["{"]
    //   TypeRef = "#" Symbol (*) "#" [";"]
    //
    //   "#" -> Shift(S213)
    //
    pub fn ___state158<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state213(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 159
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [";"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["=>"]
    //   RepeatOp = (*) "*" ["=>?"]
    //   RepeatOp = (*) "*" ["=>@L"]
    //   RepeatOp = (*) "*" ["=>@R"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "*" ["if"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [";"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["=>"]
    //   RepeatOp = (*) "+" ["=>?"]
    //   RepeatOp = (*) "+" ["=>@L"]
    //   RepeatOp = (*) "+" ["=>@R"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["if"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [";"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["=>"]
    //   RepeatOp = (*) "?" ["=>?"]
    //   RepeatOp = (*) "?" ["=>@L"]
    //   RepeatOp = (*) "?" ["=>@R"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["if"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [";"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["=>"]
    //   Symbol = Symbol0 (*) ["=>?"]
    //   Symbol = Symbol0 (*) ["=>@L"]
    //   Symbol = Symbol0 (*) ["=>@R"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [";"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["if"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["=>"]
    //   RepeatOp = (*) "*" ["=>?"]
    //   RepeatOp = (*) "*" ["=>@L"]
    //   RepeatOp = (*) "*" ["=>@R"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "*" ["if"]
    //   RepeatOp = (*) "*" ["}"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["=>"]
    //   RepeatOp = (*) "+" ["=>?"]
    //   RepeatOp = (*) "+" ["=>@L"]
    //   RepeatOp = (*) "+" ["=>@R"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["if"]
    //   RepeatOp = (*) "+" ["}"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["=>"]
    //   RepeatOp = (*) "?" ["=>?"]
    //   RepeatOp = (*) "?" ["=>@L"]
    //   RepeatOp = (*) "?" ["=>@R"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["if"]
    //   RepeatOp = (*) "?" ["}"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["=>"]
    //   Symbol = Symbol0 (*) ["=>?"]
    //   Symbol = Symbol0 (*) ["=>@L"]
    //   Symbol = Symbol0 (*) ["=>@R"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["if"]
    //   Symbol = Symbol0 (*) ["}"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["}"]
    //
    //   "#" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "(" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   ")" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "*" -> Shift(S215)
    //   "+" -> Shift(S216)
    //   "," -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   ";" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "<" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "=>" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "=>?" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "=>@L" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "=>@R" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   ">" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "?" -> Shift(S217)
    //   "@L" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "@R" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "Escape" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "Id" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "RegexLiteral" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "if" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "}" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //
    //   RepeatOp -> S214
    pub fn ___state159<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state215(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state216(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state217(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action34(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state214(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 160
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [";"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["=>"]
    //   Symbol0 = Symbol1 (*) ["=>?"]
    //   Symbol0 = Symbol1 (*) ["=>@L"]
    //   Symbol0 = Symbol1 (*) ["=>@R"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["if"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["=>"]
    //   Symbol0 = Symbol1 (*) ["=>?"]
    //   Symbol0 = Symbol1 (*) ["=>@L"]
    //   Symbol0 = Symbol1 (*) ["=>@R"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["if"]
    //   Symbol0 = Symbol1 (*) ["}"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "(" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   ")" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "*" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "+" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "," -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   ";" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "<" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "=>" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "=>?" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "=>@L" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "=>@R" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   ">" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "?" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "if" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "}" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //
    pub fn ___state160<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action35(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 161
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = "&" Lifetime (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime (*) TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [")"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = "&" Lifetime (*) TypeRef [","]
    //   TypeRef = "&" Lifetime (*) TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["="]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["="]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["="]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime TypeRef ["="]
    //   TypeRef = "&" Lifetime (*) TypeRef ["="]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["="]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef ["="]
    //   TypeRef = (*) "&" TypeRef ["="]
    //   TypeRef = (*) "&" "mut" TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["{"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["{"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["{"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime TypeRef ["{"]
    //   TypeRef = "&" Lifetime (*) TypeRef ["{"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["{"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef ["{"]
    //   TypeRef = (*) "&" TypeRef ["{"]
    //   TypeRef = (*) "&" "mut" TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [";"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [";"]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [";"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [";"]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime TypeRef [";"]
    //   TypeRef = "&" Lifetime (*) TypeRef [";"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [";"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [";"]
    //   TypeRef = (*) "&" TypeRef [";"]
    //   TypeRef = (*) "&" "mut" TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //   "mut" -> Shift(S219)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S218
    pub fn ___state161<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state219(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state218(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 162
    //   TypeRef = "&" TypeRef (*) [")"]
    //   TypeRef = "&" TypeRef (*) [","]
    //   TypeRef = "&" TypeRef (*) [","]
    //   TypeRef = "&" TypeRef (*) [">"]
    //   TypeRef = "&" TypeRef (*) ["="]
    //   TypeRef = "&" TypeRef (*) ["{"]
    //   TypeRef = "&" TypeRef (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   "," -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   ";" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   "=" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   ">" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   "{" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //
    pub fn ___state162<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action374(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 163
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = "&" "mut" (*) TypeRef [")"]
    //   TypeRef = "&" "mut" (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = "&" "mut" (*) TypeRef [","]
    //   TypeRef = "&" "mut" (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["="]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["="]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["="]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime TypeRef ["="]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["="]
    //   TypeRef = (*) "&" TypeRef ["="]
    //   TypeRef = (*) "&" "mut" TypeRef ["="]
    //   TypeRef = "&" "mut" (*) TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["{"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["{"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["{"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime TypeRef ["{"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["{"]
    //   TypeRef = (*) "&" TypeRef ["{"]
    //   TypeRef = (*) "&" "mut" TypeRef ["{"]
    //   TypeRef = "&" "mut" (*) TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [";"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [";"]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [";"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [";"]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime TypeRef [";"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [";"]
    //   TypeRef = (*) "&" TypeRef [";"]
    //   TypeRef = (*) "&" "mut" TypeRef [";"]
    //   TypeRef = "&" "mut" (*) TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S220
    pub fn ___state163<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state220(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 164
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ (*) [")"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")+ => ActionFn(396);)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S221
    pub fn ___state164<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action396(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state221(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 165
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" ["="]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" ["{"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [";"]
    //
    //   ")" -> Shift(S222)
    //
    pub fn ___state165<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state222(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 166
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["("]
    //   (<TypeRef> ",")+ = TypeRef (*) "," [")"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["MacroId"]
    //   Comma<TypeRef> = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = TypeRef => ActionFn(393);)
    //   "," -> Shift(S223)
    //
    pub fn ___state166<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state223(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action393(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 167
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [")"]
    //   Path = "::" (<Id> "::")+ (*) Id [","]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::" (<Id> "::")+ (*) Id [","]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [">"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id ["="]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [";"]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   Id -> S224
    pub fn ___state167<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state224(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 168
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [")"]
    //   Path = "::" Id (*) [","]
    //   Path = "::" Id (*) ["<"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [","]
    //   Path = "::" Id (*) ["<"]
    //   Path = "::" Id (*) [">"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) ["<"]
    //   Path = "::" Id (*) ["="]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) ["<"]
    //   Path = "::" Id (*) ["{"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [";"]
    //   Path = "::" Id (*) ["<"]
    //
    //   ")" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "," -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "::" -> Shift(S155)
    //   ";" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "<" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "=" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   ">" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "{" -> Reduce(Path = "::", Id => ActionFn(249);)
    //
    pub fn ___state168<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state155(text, ___lookbehind, ___tokens, ___sym1, ___sym2));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action249(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 169
    //   (<NotMacroId> ",")+ = (<NotMacroId> ",")+ (*) NotMacroId "," [">"]
    //   (<NotMacroId> ",")+ = (<NotMacroId> ",")+ (*) NotMacroId "," ["Id"]
    //   Comma<NotMacroId> = (<NotMacroId> ",")+ (*) [">"]
    //   Comma<NotMacroId> = (<NotMacroId> ",")+ (*) NotMacroId [">"]
    //   NotMacroId = (*) "Id" [","]
    //   NotMacroId = (*) "Id" [">"]
    //
    //   ">" -> Reduce(Comma<NotMacroId> = (<NotMacroId> ",")+ => ActionFn(378);)
    //   "Id" -> Shift(S82)
    //
    //   NotMacroId -> S225
    pub fn ___state169<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action378(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cNotMacroId_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state225(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 170
    //   NonterminalName = MacroId "<" Comma<NotMacroId> (*) ">" [":"]
    //   NonterminalName = MacroId "<" Comma<NotMacroId> (*) ">" ["="]
    //
    //   ">" -> Shift(S226)
    //
    pub fn ___state170<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state226(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 171
    //   (<NotMacroId> ",")+ = NotMacroId (*) "," [">"]
    //   (<NotMacroId> ",")+ = NotMacroId (*) "," ["Id"]
    //   Comma<NotMacroId> = NotMacroId (*) [">"]
    //
    //   "," -> Shift(S227)
    //   ">" -> Reduce(Comma<NotMacroId> = NotMacroId => ActionFn(375);)
    //
    pub fn ___state171<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state227(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action375(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cNotMacroId_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 172
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Nonterminal = @L NonterminalName @R ":" (*) TypeRef "=" Alternatives [EOF]
    //   Nonterminal = @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["#"]
    //   Nonterminal = @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["use"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["="]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["="]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["="]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime TypeRef ["="]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["="]
    //   TypeRef = (*) "&" TypeRef ["="]
    //   TypeRef = (*) "&" "mut" TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S228
    pub fn ___state172<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state228(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 173
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [";"]
    //   Alternative = (*) @L Symbol+ @R [";"]
    //   Alternative = (*) @L Symbol+ Action @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [";"]
    //   Alternative = (*) @L "if" Cond Action @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = @L NonterminalName @R "=" (*) Alternatives [EOF]
    //   Nonterminal = @L NonterminalName @R "=" (*) Alternatives ["#"]
    //   Nonterminal = @L NonterminalName @R "=" (*) Alternatives ["Escape"]
    //   Nonterminal = @L NonterminalName @R "=" (*) Alternatives ["Id"]
    //   Nonterminal = @L NonterminalName @R "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = @L NonterminalName @R "=" (*) Alternatives ["extern"]
    //   Nonterminal = @L NonterminalName @R "=" (*) Alternatives ["pub"]
    //   Nonterminal = @L NonterminalName @R "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "{" -> Shift(S232)
    //
    //   @L -> S229
    //   Alternative -> S230
    //   Alternatives -> S231
    pub fn ___state173<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state231(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 174
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType+ = (*) AssociatedType ["enum"]
    //   AssociatedType+ = (*) AssociatedType ["type"]
    //   AssociatedType+ = (*) AssociatedType ["}"]
    //   AssociatedType+ = (*) AssociatedType+ AssociatedType ["enum"]
    //   AssociatedType+ = (*) AssociatedType+ AssociatedType ["type"]
    //   AssociatedType+ = (*) AssociatedType+ AssociatedType ["}"]
    //   EnumToken = (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" ["}"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken "}" ["#"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) EnumToken "}" ["use"]
    //   ExternToken = @L "extern" @R "{" (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) "}" ["#"]
    //   ExternToken = @L "extern" @R "{" (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) "}" ["use"]
    //
    //   "enum" -> Shift(S236)
    //   "type" -> Shift(S237)
    //   "}" -> Shift(S238)
    //
    //   AssociatedType -> S233
    //   AssociatedType+ -> S234
    //   EnumToken -> S235
    pub fn ___state174<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Enum, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state236(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::Type, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state237(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state238(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state233(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::AssociatedType_2b(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state234(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                ___Nonterminal::EnumToken(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state235(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 175
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName @R (*) "=" Alternatives ["use"]
    //
    //   ":" -> Shift(S239)
    //   "=" -> Shift(S240)
    //
    pub fn ___state175<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state239(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state240(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 176
    //   @R = (*) [":"]
    //   @R = (*) ["="]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName (*) @R "=" Alternatives ["use"]
    //
    //   ":" -> Reduce(@R =  => ActionFn(130);)
    //   "=" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S241
    pub fn ___state176<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state241(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 177
    //   Nonterminal = "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) "=" Alternatives [EOF]
    //   Nonterminal = "pub" @L NonterminalName @R (*) "=" Alternatives ["#"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) "=" Alternatives ["Id"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) "=" Alternatives ["extern"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) "=" Alternatives ["pub"]
    //   Nonterminal = "pub" @L NonterminalName @R (*) "=" Alternatives ["use"]
    //
    //   ":" -> Shift(S242)
    //   "=" -> Shift(S243)
    //
    pub fn ___state177<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state242(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state243(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 178
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarParameters, "where", ";", GrammarItem+ => ActionFn(427);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state178<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action427(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 179
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, ";", GrammarItem+ => ActionFn(457);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state179<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action457(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 180
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" (*) [EOF]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, "where", ";" => ActionFn(417);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S244
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state180<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
        ___sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action417(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state244(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 181
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarTypeParameters, "where", ";", GrammarItem+ => ActionFn(429);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state181<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action429(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 182
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarParameters, "where", ";", GrammarItem+ => ActionFn(412);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state182<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<Parameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action412(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 183
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, ";", GrammarItem+ => ActionFn(442);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state183<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action442(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 184
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" (*) [EOF]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, "where", ";" => ActionFn(402);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S245
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state184<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
        ___sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action402(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state245(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 185
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarTypeParameters, "where", ";", GrammarItem+ => ActionFn(414);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state185<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action414(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 186
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarParameters, ";", GrammarItem+ => ActionFn(460);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state186<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action460(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 187
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters "where" ";" (*) [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarParameters, "where", ";" => ActionFn(420);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S246
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state187<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
        ___sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action420(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state246(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 188
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" (*) [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, ";" => ActionFn(450);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S247
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state188<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<Parameter>>,
        ___sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action450(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state247(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 189
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" (*) ";" [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" (*) ";" GrammarItem+ [EOF]
    //
    //   ";" -> Shift(S248)
    //
    pub fn ___state189<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<Parameter>>,
        ___sym7: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state248(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 190
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarTypeParameters, ";", GrammarItem+ => ActionFn(462);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state190<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action462(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 191
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" (*) [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarTypeParameters, "where", ";" => ActionFn(422);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S249
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state191<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
        ___sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action422(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state249(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 192
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, "where", ";", GrammarItem+ => ActionFn(432);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state192<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<&'input str>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action432(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym7, ___sym8));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 193
    //   (<Id> "::")+ = (<Id> "::")+ Id "::" (*) ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")+ = (<Id> "::")+, Id, "::" => ActionFn(248);)
    //   "MacroId" -> Reduce((<Id> "::")+ = (<Id> "::")+, Id, "::" => ActionFn(248);)
    //
    pub fn ___state193<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action248(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 194
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ (*) [">"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ => ActionFn(400);)
    //   "Id" -> Shift(S32)
    //   "Lifetime" -> Shift(S56)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Lifetime -> S196
    //   Path -> S119
    //   TypeRef -> S197
    //   TypeRefOrLifetime -> S250
    pub fn ___state194<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state56(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action400(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state196(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state197(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state250(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 195
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" ["="]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" ["{"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [";"]
    //
    //   ">" -> Shift(S251)
    //
    pub fn ___state195<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state251(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 196
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => ActionFn(54);)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => ActionFn(54);)
    //
    pub fn ___state196<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action54(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 197
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => ActionFn(53);)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => ActionFn(53);)
    //
    pub fn ___state197<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action53(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 198
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S252)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = TypeRefOrLifetime => ActionFn(397);)
    //
    pub fn ___state198<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state252(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action397(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 199
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [";"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["=>"]
    //   SymbolKind1 = Escape (*) ["=>?"]
    //   SymbolKind1 = Escape (*) ["=>@L"]
    //   SymbolKind1 = Escape (*) ["=>@R"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["if"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["=>"]
    //   SymbolKind1 = Escape (*) ["=>?"]
    //   SymbolKind1 = Escape (*) ["=>@L"]
    //   SymbolKind1 = Escape (*) ["=>@R"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["if"]
    //   SymbolKind1 = Escape (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "(" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   ")" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "*" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "+" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "," -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   ";" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "<" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "=>" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "=>?" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "=>@L" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "=>@R" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   ">" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "?" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "@L" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "@R" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "Id" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "if" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "}" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //
    pub fn ___state199<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 200
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [";"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["}"]
    //
    //   "<" -> Shift(S253)
    //
    pub fn ___state200<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state253(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 201
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [";"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>?"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["if"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>?"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["if"]
    //   SymbolKind1 = QuotedTerminal (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   ";" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "=>" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "=>?" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "=>@L" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "=>@R" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "if" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "}" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //
    pub fn ___state201<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action42(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 202
    //   QuotedTerminal = RegexLiteral (*) ["#"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) [")"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [";"]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["=>"]
    //   QuotedTerminal = RegexLiteral (*) ["=>?"]
    //   QuotedTerminal = RegexLiteral (*) ["=>@L"]
    //   QuotedTerminal = RegexLiteral (*) ["=>@R"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["if"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [","]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [","]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["=>"]
    //   QuotedTerminal = RegexLiteral (*) ["=>?"]
    //   QuotedTerminal = RegexLiteral (*) ["=>@L"]
    //   QuotedTerminal = RegexLiteral (*) ["=>@R"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["if"]
    //   QuotedTerminal = RegexLiteral (*) ["}"]
    //   QuotedTerminal = RegexLiteral (*) ["=>"]
    //
    //   "#" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "(" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   ")" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "*" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "+" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "," -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   ";" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "<" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "=>" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "=>?" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "=>@L" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "=>@R" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   ">" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "?" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "@L" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "@R" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "Escape" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "Id" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "MacroId" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "StringLiteral" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "if" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "}" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //
    pub fn ___state202<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action80(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 203
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [";"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["=>"]
    //   QuotedTerminal = StringLiteral (*) ["=>?"]
    //   QuotedTerminal = StringLiteral (*) ["=>@L"]
    //   QuotedTerminal = StringLiteral (*) ["=>@R"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["if"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["=>"]
    //   QuotedTerminal = StringLiteral (*) ["=>?"]
    //   QuotedTerminal = StringLiteral (*) ["=>@L"]
    //   QuotedTerminal = StringLiteral (*) ["=>@R"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["if"]
    //   QuotedTerminal = StringLiteral (*) ["}"]
    //   QuotedTerminal = StringLiteral (*) ["=>"]
    //
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "," -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   ";" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "=>" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "=>?" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "=>@L" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "=>@R" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "if" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "}" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //
    pub fn ___state203<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action79(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 204
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [";"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["if"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["if"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["}"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "*" -> Reduce(@R =  => ActionFn(130);)
    //   "+" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   "=>" -> Reduce(@R =  => ActionFn(130);)
    //   "=>?" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@L" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@R" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "?" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "if" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S254
    pub fn ___state204<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state254(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 205
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [";"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["if"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["if"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(ExprSymbol =  => ActionFn(383);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S157
    //   ExprSymbol -> S255
    //   Symbol -> S256
    //   Symbol+ -> S257
    //   Symbol0 -> S159
    //   Symbol1 -> S160
    pub fn ___state205<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action383(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state157(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::ExprSymbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state255(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state256(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state257(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state159(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 206
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [";"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["}"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["}"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S258
    //   Symbol0 -> S259
    //   Symbol1 -> S160
    pub fn ___state206<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state258(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state259(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 207
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [";"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["=>"]
    //   SymbolKind1 = "@L" (*) ["=>?"]
    //   SymbolKind1 = "@L" (*) ["=>@L"]
    //   SymbolKind1 = "@L" (*) ["=>@R"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["if"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["=>"]
    //   SymbolKind1 = "@L" (*) ["=>?"]
    //   SymbolKind1 = "@L" (*) ["=>@L"]
    //   SymbolKind1 = "@L" (*) ["=>@R"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["if"]
    //   SymbolKind1 = "@L" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "(" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   ")" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "*" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "+" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "," -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   ";" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "<" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "=>" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "=>?" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "=>@L" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "=>@R" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   ">" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "?" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "if" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "}" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //
    pub fn ___state207<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action46(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 208
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [";"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["=>"]
    //   SymbolKind1 = "@R" (*) ["=>?"]
    //   SymbolKind1 = "@R" (*) ["=>@L"]
    //   SymbolKind1 = "@R" (*) ["=>@R"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["if"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["=>"]
    //   SymbolKind1 = "@R" (*) ["=>?"]
    //   SymbolKind1 = "@R" (*) ["=>@L"]
    //   SymbolKind1 = "@R" (*) ["=>@R"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["if"]
    //   SymbolKind1 = "@R" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "(" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   ")" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "*" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "+" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "," -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   ";" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "<" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "=>" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "=>?" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "=>@L" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "=>@R" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   ">" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "?" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "if" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "}" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //
    pub fn ___state208<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action47(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 209
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [";"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["=>"]
    //   Escape = "Escape" (*) ["=>?"]
    //   Escape = "Escape" (*) ["=>@L"]
    //   Escape = "Escape" (*) ["=>@R"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["if"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["=>"]
    //   Escape = "Escape" (*) ["=>?"]
    //   Escape = "Escape" (*) ["=>@L"]
    //   Escape = "Escape" (*) ["=>@R"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["if"]
    //   Escape = "Escape" (*) ["}"]
    //
    //   "#" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "(" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   ")" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "*" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "+" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "," -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   ";" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "<" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "=>" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "=>?" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "=>@L" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "=>@R" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   ">" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "?" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "@L" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "@R" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "Escape" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "Id" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "MacroId" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "RegexLiteral" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "if" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "}" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //
    pub fn ___state209<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Escape(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 210
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [";"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["=>"]
    //   SymbolKind1 = "Id" (*) ["=>?"]
    //   SymbolKind1 = "Id" (*) ["=>@L"]
    //   SymbolKind1 = "Id" (*) ["=>@R"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["if"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["=>"]
    //   SymbolKind1 = "Id" (*) ["=>?"]
    //   SymbolKind1 = "Id" (*) ["=>@L"]
    //   SymbolKind1 = "Id" (*) ["=>@R"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["if"]
    //   SymbolKind1 = "Id" (*) ["}"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "(" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ")" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "*" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "+" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "," -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ";" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "<" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "=>" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "=>?" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "=>@L" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "=>@R" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ">" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "?" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "if" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "}" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //
    pub fn ___state210<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 211
    //   RegexLiteral = "RegexLiteral" (*) ["#"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) [")"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [";"]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>?"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["if"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [","]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [","]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>?"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["if"]
    //   RegexLiteral = "RegexLiteral" (*) ["}"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>"]
    //
    //   "#" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "(" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   ")" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "*" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "+" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "," -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   ";" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "<" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "=>" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "=>?" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "=>@L" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "=>@R" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   ">" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "?" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "@L" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "@R" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "Escape" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "Id" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "MacroId" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "RegexLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "StringLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "if" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "}" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //
    pub fn ___state211<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action82(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RegexLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 212
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [";"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["if"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["if"]
    //   StringLiteral = "StringLiteral" (*) ["}"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) [";"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["}"]
    //
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   ";" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "=>" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "=>?" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "=>@L" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "=>@R" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "RegexLiteral" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "if" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "}" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //
    pub fn ___state212<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action81(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::StringLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 213
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //   TypeRef = "#" Symbol "#" (*) ["="]
    //   TypeRef = "#" Symbol "#" (*) ["{"]
    //   TypeRef = "#" Symbol "#" (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   ";" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   "=" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   "{" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //
    pub fn ___state213<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action49(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 214
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [";"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["if"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["if"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["}"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "*" -> Reduce(@R =  => ActionFn(130);)
    //   "+" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   "=>" -> Reduce(@R =  => ActionFn(130);)
    //   "=>?" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@L" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@R" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "?" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "if" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S260
    pub fn ___state214<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state260(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 215
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [";"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["=>"]
    //   RepeatOp = "*" (*) ["=>?"]
    //   RepeatOp = "*" (*) ["=>@L"]
    //   RepeatOp = "*" (*) ["=>@R"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["if"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["=>"]
    //   RepeatOp = "*" (*) ["=>?"]
    //   RepeatOp = "*" (*) ["=>@L"]
    //   RepeatOp = "*" (*) ["=>@R"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["if"]
    //   RepeatOp = "*" (*) ["}"]
    //
    //   "#" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "(" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   ")" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "*" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "+" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "," -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   ";" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "<" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "=>" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "=>?" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "=>@L" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "=>@R" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   ">" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "?" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "@L" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "@R" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "Escape" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "Id" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "MacroId" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "if" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "}" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //
    pub fn ___state215<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action38(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 216
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [";"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["=>"]
    //   RepeatOp = "+" (*) ["=>?"]
    //   RepeatOp = "+" (*) ["=>@L"]
    //   RepeatOp = "+" (*) ["=>@R"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["if"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["=>"]
    //   RepeatOp = "+" (*) ["=>?"]
    //   RepeatOp = "+" (*) ["=>@L"]
    //   RepeatOp = "+" (*) ["=>@R"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["if"]
    //   RepeatOp = "+" (*) ["}"]
    //
    //   "#" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "(" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   ")" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "*" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "+" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "," -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   ";" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "<" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "=>" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "=>?" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "=>@L" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "=>@R" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   ">" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "?" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "@L" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "@R" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "Escape" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "Id" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "MacroId" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "if" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "}" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //
    pub fn ___state216<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action37(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 217
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [";"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["=>"]
    //   RepeatOp = "?" (*) ["=>?"]
    //   RepeatOp = "?" (*) ["=>@L"]
    //   RepeatOp = "?" (*) ["=>@R"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["if"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["=>"]
    //   RepeatOp = "?" (*) ["=>?"]
    //   RepeatOp = "?" (*) ["=>@L"]
    //   RepeatOp = "?" (*) ["=>@R"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["if"]
    //   RepeatOp = "?" (*) ["}"]
    //
    //   "#" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "(" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   ")" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "*" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "+" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "," -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   ";" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "<" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "=>" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "=>?" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "=>@L" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "=>@R" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   ">" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "?" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "@L" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "@R" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "Escape" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "Id" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "MacroId" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "if" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "}" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //
    pub fn ___state217<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action39(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 218
    //   TypeRef = "&" Lifetime TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime TypeRef (*) [","]
    //   TypeRef = "&" Lifetime TypeRef (*) [","]
    //   TypeRef = "&" Lifetime TypeRef (*) [">"]
    //   TypeRef = "&" Lifetime TypeRef (*) ["="]
    //   TypeRef = "&" Lifetime TypeRef (*) ["{"]
    //   TypeRef = "&" Lifetime TypeRef (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   "," -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   ";" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   "=" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   ">" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   "{" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //
    pub fn ___state218<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action373(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 219
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [","]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["="]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["="]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["="]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime TypeRef ["="]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["="]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef ["="]
    //   TypeRef = (*) "&" TypeRef ["="]
    //   TypeRef = (*) "&" "mut" TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["{"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["{"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["{"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime TypeRef ["{"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["{"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef ["{"]
    //   TypeRef = (*) "&" TypeRef ["{"]
    //   TypeRef = (*) "&" "mut" TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [";"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [";"]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [";"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [";"]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime TypeRef [";"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [";"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [";"]
    //   TypeRef = (*) "&" TypeRef [";"]
    //   TypeRef = (*) "&" "mut" TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S261
    pub fn ___state219<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state261(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 220
    //   TypeRef = "&" "mut" TypeRef (*) [")"]
    //   TypeRef = "&" "mut" TypeRef (*) [","]
    //   TypeRef = "&" "mut" TypeRef (*) [","]
    //   TypeRef = "&" "mut" TypeRef (*) [">"]
    //   TypeRef = "&" "mut" TypeRef (*) ["="]
    //   TypeRef = "&" "mut" TypeRef (*) ["{"]
    //   TypeRef = "&" "mut" TypeRef (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   "," -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   ";" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   "=" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   ">" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   "{" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //
    pub fn ___state220<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action372(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 221
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ TypeRef (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")+, TypeRef => ActionFn(395);)
    //   "," -> Shift(S262)
    //
    pub fn ___state221<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state262(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action395(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 222
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) ["="]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) ["{"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   ";" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   "=" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   "{" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //
    pub fn ___state222<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action48(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 223
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["("]
    //   (<TypeRef> ",")+ = TypeRef "," (*) [")"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "&" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "(" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   ")" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "::" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "Id" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "MacroId" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //
    pub fn ___state223<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action269(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 224
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [")"]
    //   Path = "::" (<Id> "::")+ Id (*) [","]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [","]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   Path = "::" (<Id> "::")+ Id (*) [">"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   Path = "::" (<Id> "::")+ Id (*) ["="]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   Path = "::" (<Id> "::")+ Id (*) ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [";"]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //
    //   ")" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "," -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "::" -> Shift(S193)
    //   ";" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "<" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "=" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   ">" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "{" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //
    pub fn ___state224<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state193(text, ___lookbehind, ___tokens, ___sym1, ___sym2, ___sym3));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action250(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 225
    //   (<NotMacroId> ",")+ = (<NotMacroId> ",")+ NotMacroId (*) "," [">"]
    //   (<NotMacroId> ",")+ = (<NotMacroId> ",")+ NotMacroId (*) "," ["Id"]
    //   Comma<NotMacroId> = (<NotMacroId> ",")+ NotMacroId (*) [">"]
    //
    //   "," -> Shift(S263)
    //   ">" -> Reduce(Comma<NotMacroId> = (<NotMacroId> ",")+, NotMacroId => ActionFn(377);)
    //
    pub fn ___state225<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
        ___sym1: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state263(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action377(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cNotMacroId_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 226
    //   NonterminalName = MacroId "<" Comma<NotMacroId> ">" (*) [":"]
    //   NonterminalName = MacroId "<" Comma<NotMacroId> ">" (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = MacroId, "<", Comma<NotMacroId>, ">" => ActionFn(15);)
    //   "=" -> Reduce(NonterminalName = MacroId, "<", Comma<NotMacroId>, ">" => ActionFn(15);)
    //
    pub fn ___state226<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<NonterminalString>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action15(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NonterminalName(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 227
    //   (<NotMacroId> ",")+ = NotMacroId "," (*) [">"]
    //   (<NotMacroId> ",")+ = NotMacroId "," (*) ["Id"]
    //
    //   ">" -> Reduce((<NotMacroId> ",")+ = NotMacroId, "," => ActionFn(253);)
    //   "Id" -> Reduce((<NotMacroId> ",")+ = NotMacroId, "," => ActionFn(253);)
    //
    pub fn ___state227<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action253(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 228
    //   Nonterminal = @L NonterminalName @R ":" TypeRef (*) "=" Alternatives [EOF]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["#"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["Escape"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["Id"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["extern"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["pub"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["use"]
    //
    //   "=" -> Shift(S264)
    //
    pub fn ___state228<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state264(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 229
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Alternative = @L (*) Action @R [";"]
    //   Alternative = @L (*) Symbol+ @R [";"]
    //   Alternative = @L (*) Symbol+ Action @R [";"]
    //   Alternative = @L (*) Symbol+ "if" Cond @R [";"]
    //   Alternative = @L (*) Symbol+ "if" Cond Action @R [";"]
    //   Alternative = @L (*) "if" Cond Action @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [";"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["=>"]
    //   Symbol+ = (*) Symbol ["=>?"]
    //   Symbol+ = (*) Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["if"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [";"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>?"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Action = (*) "=>" [","]
    //   Action = (*) "=>" ["}"]
    //   Action = (*) "=>?" [","]
    //   Action = (*) "=>?" ["}"]
    //   Action = (*) "=>@L" [","]
    //   Action = (*) "=>@L" ["}"]
    //   Action = (*) "=>@R" [","]
    //   Action = (*) "=>@R" ["}"]
    //   Alternative = @L (*) Action @R [","]
    //   Alternative = @L (*) Action @R ["}"]
    //   Alternative = @L (*) Symbol+ @R [","]
    //   Alternative = @L (*) Symbol+ @R ["}"]
    //   Alternative = @L (*) Symbol+ Action @R [","]
    //   Alternative = @L (*) Symbol+ Action @R ["}"]
    //   Alternative = @L (*) Symbol+ "if" Cond @R [","]
    //   Alternative = @L (*) Symbol+ "if" Cond @R ["}"]
    //   Alternative = @L (*) Symbol+ "if" Cond Action @R [","]
    //   Alternative = @L (*) Symbol+ "if" Cond Action @R ["}"]
    //   Alternative = @L (*) "if" Cond Action @R [","]
    //   Alternative = @L (*) "if" Cond Action @R ["}"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["}"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["}"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol = (*) Symbol0 ["}"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [","]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["=>"]
    //   Symbol+ = (*) Symbol ["=>?"]
    //   Symbol+ = (*) Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["if"]
    //   Symbol+ = (*) Symbol ["}"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [","]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>?"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["if"]
    //   Symbol+ = (*) Symbol+ Symbol ["}"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["}"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol0 = (*) Symbol1 ["}"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Shift(S267)
    //   "=>?" -> Shift(S268)
    //   "=>@L" -> Shift(S269)
    //   "=>@R" -> Shift(S270)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Shift(S271)
    //
    //   @L -> S157
    //   Action -> S265
    //   Symbol -> S256
    //   Symbol+ -> S266
    //   Symbol0 -> S159
    //   Symbol1 -> S160
    pub fn ___state229<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state267(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state268(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state269(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state270(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::If, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state271(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state157(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Action(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state265(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state256(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state266(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state159(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 230
    //   Alternatives = Alternative (*) ";" [EOF]
    //   Alternatives = Alternative (*) ";" ["#"]
    //   Alternatives = Alternative (*) ";" ["Escape"]
    //   Alternatives = Alternative (*) ";" ["Id"]
    //   Alternatives = Alternative (*) ";" ["MacroId"]
    //   Alternatives = Alternative (*) ";" ["extern"]
    //   Alternatives = Alternative (*) ";" ["pub"]
    //   Alternatives = Alternative (*) ";" ["use"]
    //
    //   ";" -> Shift(S272)
    //
    pub fn ___state230<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state272(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 231
    //   Nonterminal = @L NonterminalName @R "=" Alternatives (*) [EOF]
    //   Nonterminal = @L NonterminalName @R "=" Alternatives (*) ["#"]
    //   Nonterminal = @L NonterminalName @R "=" Alternatives (*) ["Escape"]
    //   Nonterminal = @L NonterminalName @R "=" Alternatives (*) ["Id"]
    //   Nonterminal = @L NonterminalName @R "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = @L NonterminalName @R "=" Alternatives (*) ["extern"]
    //   Nonterminal = @L NonterminalName @R "=" Alternatives (*) ["pub"]
    //   Nonterminal = @L NonterminalName @R "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = @L, NonterminalName, @R, "=", Alternatives => ActionFn(295);)
    //   "#" -> Reduce(Nonterminal = @L, NonterminalName, @R, "=", Alternatives => ActionFn(295);)
    //   "Escape" -> Reduce(Nonterminal = @L, NonterminalName, @R, "=", Alternatives => ActionFn(295);)
    //   "Id" -> Reduce(Nonterminal = @L, NonterminalName, @R, "=", Alternatives => ActionFn(295);)
    //   "MacroId" -> Reduce(Nonterminal = @L, NonterminalName, @R, "=", Alternatives => ActionFn(295);)
    //   "extern" -> Reduce(Nonterminal = @L, NonterminalName, @R, "=", Alternatives => ActionFn(295);)
    //   "pub" -> Reduce(Nonterminal = @L, NonterminalName, @R, "=", Alternatives => ActionFn(295);)
    //   "use" -> Reduce(Nonterminal = @L, NonterminalName, @R, "=", Alternatives => ActionFn(295);)
    //
    pub fn ___state231<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action295(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 232
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["("]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["<"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["=>"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["=>?"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["=>@L"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["=>@R"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["@L"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["@R"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["Escape"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["Id"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["MacroId"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["RegexLiteral"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["StringLiteral"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["if"]
    //   (<Alternative> ",")+ = (*) (<Alternative> ",")+ Alternative "," ["}"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["("]
    //   (<Alternative> ",")+ = (*) Alternative "," ["<"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["=>"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["=>?"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["=>@L"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["=>@R"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["@L"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["@R"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["Escape"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["Id"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["MacroId"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["RegexLiteral"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["StringLiteral"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["if"]
    //   (<Alternative> ",")+ = (*) Alternative "," ["}"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [","]
    //   Alternative = (*) @L Action @R ["}"]
    //   Alternative = (*) @L Symbol+ @R [","]
    //   Alternative = (*) @L Symbol+ @R ["}"]
    //   Alternative = (*) @L Symbol+ Action @R [","]
    //   Alternative = (*) @L Symbol+ Action @R ["}"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [","]
    //   Alternative = (*) @L Symbol+ "if" Cond @R ["}"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [","]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R ["}"]
    //   Alternative = (*) @L "if" Cond Action @R [","]
    //   Alternative = (*) @L "if" Cond Action @R ["}"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["use"]
    //   Comma<Alternative> = (*) ["}"]
    //   Comma<Alternative> = (*) (<Alternative> ",")+ ["}"]
    //   Comma<Alternative> = (*) (<Alternative> ",")+ Alternative ["}"]
    //   Comma<Alternative> = (*) Alternative ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "}" -> Reduce(Comma<Alternative> =  => ActionFn(282);)
    //
    //   (<Alternative> ",")+ -> S273
    //   @L -> S229
    //   Alternative -> S274
    //   Comma<Alternative> -> S275
    pub fn ___state232<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action282(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cAlternative_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cAlternative_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state273(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state274(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cAlternative_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state275(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 233
    //   AssociatedType+ = AssociatedType (*) ["enum"]
    //   AssociatedType+ = AssociatedType (*) ["type"]
    //   AssociatedType+ = AssociatedType (*) ["}"]
    //   AssociatedType+ = AssociatedType (*) ["type"]
    //   AssociatedType+ = AssociatedType (*) ["}"]
    //
    //   "enum" -> Reduce(AssociatedType+ = AssociatedType => ActionFn(179);)
    //   "type" -> Reduce(AssociatedType+ = AssociatedType => ActionFn(179);)
    //   "}" -> Reduce(AssociatedType+ = AssociatedType => ActionFn(179);)
    //
    pub fn ___state233<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<AssociatedType>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Enum, _)) |
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action179(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::AssociatedType_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 234
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType+ = AssociatedType+ (*) AssociatedType ["enum"]
    //   AssociatedType+ = AssociatedType+ (*) AssociatedType ["type"]
    //   AssociatedType+ = AssociatedType+ (*) AssociatedType ["}"]
    //   EnumToken = (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) EnumToken "}" ["use"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ (*) "}" ["use"]
    //
    //   "enum" -> Shift(S236)
    //   "type" -> Shift(S237)
    //   "}" -> Shift(S278)
    //
    //   AssociatedType -> S276
    //   EnumToken -> S277
    pub fn ___state234<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Enum, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state236(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Type, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state237(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state278(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state276(text, ___lookbehind, ___tokens, ___lookahead, ___sym4, ___sym5));
                }
                ___Nonterminal::EnumToken(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state277(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 235
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType+ = (*) AssociatedType ["type"]
    //   AssociatedType+ = (*) AssociatedType ["}"]
    //   AssociatedType+ = (*) AssociatedType+ AssociatedType ["type"]
    //   AssociatedType+ = (*) AssociatedType+ AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) "}" ["#"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" EnumToken (*) "}" ["use"]
    //
    //   "type" -> Shift(S237)
    //   "}" -> Shift(S280)
    //
    //   AssociatedType -> S233
    //   AssociatedType+ -> S279
    pub fn ___state235<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<EnumToken>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Type, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state237(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state280(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state233(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::AssociatedType_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state279(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 236
    //   @L = (*) ["#"]
    //   @L = (*) ["&"]
    //   @L = (*) ["("]
    //   @L = (*) ["::"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   EnumToken = "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" ["}"]
    //
    //   "#" -> Reduce(@L =  => ActionFn(131);)
    //   "&" -> Reduce(@L =  => ActionFn(131);)
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "::" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S281
    pub fn ___state236<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state281(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 237
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["}"]
    //
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S282
    pub fn ___state237<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state282(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 238
    //   ExternToken = @L "extern" @R "{" "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" "}" (*) ["#"]
    //   ExternToken = @L "extern" @R "{" "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" "}" (*) ["use"]
    //
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", "}" => ActionFn(301);)
    //   "#" -> Reduce(ExternToken = @L, "extern", @R, "{", "}" => ActionFn(301);)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", "}" => ActionFn(301);)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", "}" => ActionFn(301);)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", "}" => ActionFn(301);)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", "}" => ActionFn(301);)
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", "}" => ActionFn(301);)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", "}" => ActionFn(301);)
    //
    pub fn ___state238<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action301(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExternToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 239
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" (*) TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["use"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["="]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["="]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["="]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime TypeRef ["="]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["="]
    //   TypeRef = (*) "&" TypeRef ["="]
    //   TypeRef = (*) "&" "mut" TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S283
    pub fn ___state239<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state283(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 240
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [";"]
    //   Alternative = (*) @L Symbol+ @R [";"]
    //   Alternative = (*) @L Symbol+ Action @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [";"]
    //   Alternative = (*) @L "if" Cond Action @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" (*) Alternatives [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" (*) Alternatives ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" (*) Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" (*) Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" (*) Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" (*) Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "{" -> Shift(S232)
    //
    //   @L -> S229
    //   Alternative -> S230
    //   Alternatives -> S284
    pub fn ___state240<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state284(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 241
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R (*) "=" Alternatives ["use"]
    //
    //   ":" -> Shift(S285)
    //   "=" -> Shift(S286)
    //
    pub fn ___state241<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state285(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state286(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 242
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Nonterminal = "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives [EOF]
    //   Nonterminal = "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["#"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["use"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["="]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["="]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["="]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime TypeRef ["="]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["="]
    //   TypeRef = (*) "&" TypeRef ["="]
    //   TypeRef = (*) "&" "mut" TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S287
    pub fn ___state242<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state287(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 243
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [";"]
    //   Alternative = (*) @L Symbol+ @R [";"]
    //   Alternative = (*) @L Symbol+ Action @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [";"]
    //   Alternative = (*) @L "if" Cond Action @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" (*) Alternatives [EOF]
    //   Nonterminal = "pub" @L NonterminalName @R "=" (*) Alternatives ["#"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" (*) Alternatives ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" (*) Alternatives ["Id"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" (*) Alternatives ["extern"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" (*) Alternatives ["pub"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "{" -> Shift(S232)
    //
    //   @L -> S229
    //   Alternative -> S230
    //   Alternatives -> S288
    pub fn ___state243<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state288(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 244
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Annotation+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, "where", ";", GrammarItem+ => ActionFn(425);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state244<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
        ___sym7: &mut Option<Tok<'input>>,
        ___sym8: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___nt = super::___action425(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym8.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym8, ___sym9));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 245
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, "where", ";", GrammarItem+ => ActionFn(410);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state245<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Vec<TypeParameter>>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
        ___sym7: &mut Option<Tok<'input>>,
        ___sym8: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___nt = super::___action410(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym8.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym8, ___sym9));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 246
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarParameters, "where", ";", GrammarItem+ => ActionFn(428);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state246<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<Parameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
        ___sym7: &mut Option<Tok<'input>>,
        ___sym8: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___nt = super::___action428(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym8.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym8, ___sym9));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 247
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, ";", GrammarItem+ => ActionFn(458);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state247<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<Parameter>>,
        ___sym7: &mut Option<Tok<'input>>,
        ___sym8: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___nt = super::___action458(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym8.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym8, ___sym9));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 248
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" (*) [EOF]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" (*) GrammarItem+ [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = (*) GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem ["use"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem [EOF]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["#"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Escape"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["Id"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["MacroId"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["extern"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["pub"]
    //   GrammarItem+ = (*) GrammarItem+ GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, "where", ";" => ActionFn(418);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S46
    //   GrammarItem+ -> S289
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state248<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<Parameter>>,
        ___sym7: &mut Option<Vec<&'input str>>,
        ___sym8: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___nt = super::___action418(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym8.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::GrammarItem_2b(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state289(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, ___sym9));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 249
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarTypeParameters, "where", ";", GrammarItem+ => ActionFn(430);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state249<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<&'input str>>,
        ___sym7: &mut Option<Tok<'input>>,
        ___sym8: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym9 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym9));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___nt = super::___action430(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym8.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym8, ___sym9));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym9));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 250
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S290)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime => ActionFn(399);)
    //
    pub fn ___state250<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state290(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action399(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 251
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) ["="]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) ["{"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   ";" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   "=" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   "{" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //
    pub fn ___state251<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action51(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 252
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //
    pub fn ___state252<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action273(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 253
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [";"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["if"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   ">" -> Reduce(Comma<Symbol> =  => ActionFn(386);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   (<Symbol> ",")+ -> S291
    //   @L -> S157
    //   Comma<Symbol> -> S292
    //   Symbol -> S293
    //   Symbol0 -> S159
    //   Symbol1 -> S160
    pub fn ___state253<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action386(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state291(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state157(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cSymbol_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state292(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state293(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state159(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 254
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [";"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["if"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["if"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["}"]
    //
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   ";" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "=>" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "=>?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "=>@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "=>@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "RegexLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "if" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "}" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //
    pub fn ___state254<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action40(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 255
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [";"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["if"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["if"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["}"]
    //
    //   ")" -> Shift(S294)
    //
    pub fn ___state255<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state294(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 256
    //   Symbol+ = Symbol (*) ["("]
    //   Symbol+ = Symbol (*) [")"]
    //   Symbol+ = Symbol (*) ["<"]
    //   Symbol+ = Symbol (*) ["@L"]
    //   Symbol+ = Symbol (*) ["@R"]
    //   Symbol+ = Symbol (*) ["Escape"]
    //   Symbol+ = Symbol (*) ["Id"]
    //   Symbol+ = Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol (*) ["("]
    //   Symbol+ = Symbol (*) [";"]
    //   Symbol+ = Symbol (*) ["<"]
    //   Symbol+ = Symbol (*) ["=>"]
    //   Symbol+ = Symbol (*) ["=>?"]
    //   Symbol+ = Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol (*) ["@L"]
    //   Symbol+ = Symbol (*) ["@R"]
    //   Symbol+ = Symbol (*) ["Escape"]
    //   Symbol+ = Symbol (*) ["Id"]
    //   Symbol+ = Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol (*) ["if"]
    //   Symbol+ = Symbol (*) ["("]
    //   Symbol+ = Symbol (*) [","]
    //   Symbol+ = Symbol (*) ["<"]
    //   Symbol+ = Symbol (*) ["=>"]
    //   Symbol+ = Symbol (*) ["=>?"]
    //   Symbol+ = Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol (*) ["@L"]
    //   Symbol+ = Symbol (*) ["@R"]
    //   Symbol+ = Symbol (*) ["Escape"]
    //   Symbol+ = Symbol (*) ["Id"]
    //   Symbol+ = Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol (*) ["if"]
    //   Symbol+ = Symbol (*) ["}"]
    //
    //   "(" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   ")" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "," -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   ";" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "<" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "=>" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "=>?" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "=>@L" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "=>@R" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "@L" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "@R" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "Escape" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "Id" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "MacroId" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "RegexLiteral" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "if" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "}" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //
    pub fn ___state256<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action111(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 257
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol+ (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [")"]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["RegexLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(ExprSymbol = Symbol+ => ActionFn(384);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S157
    //   Symbol -> S295
    //   Symbol0 -> S159
    //   Symbol1 -> S160
    pub fn ___state257<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action384(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state157(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state295(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state159(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 258
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["}"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S205)
    //   "@L" -> Shift(S207)
    //   "@R" -> Shift(S208)
    //   "Escape" -> Shift(S209)
    //   "Id" -> Shift(S297)
    //   "MacroId" -> Shift(S298)
    //   "RegexLiteral" -> Shift(S211)
    //   "StringLiteral" -> Shift(S212)
    //
    //   Escape -> S199
    //   Id -> S296
    //   MacroId -> S200
    //   QuotedTerminal -> S201
    //   RegexLiteral -> S202
    //   StringLiteral -> S203
    //   SymbolKind1 -> S204
    pub fn ___state258<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state205(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state207(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state208(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state209(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state297(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state298(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state211(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state212(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state199(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state296(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state200(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state201(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state202(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state203(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state204(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 259
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [";"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["if"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["}"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S215)
    //   "+" -> Shift(S216)
    //   ">" -> Shift(S299)
    //   "?" -> Shift(S217)
    //
    //   RepeatOp -> S214
    pub fn ___state259<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state215(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state216(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state299(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state217(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state214(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 260
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [";"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["if"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["if"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["}"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   ";" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "=>" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "=>?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "=>@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "=>@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "if" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "}" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //
    pub fn ___state260<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action36(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 261
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [","]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [","]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [">"]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) ["="]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) ["{"]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   "," -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   ";" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   "=" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   ">" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   "{" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //
    pub fn ___state261<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action371(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 262
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "&" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "(" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   ")" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "::" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "Id" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "MacroId" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //
    pub fn ___state262<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action270(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 263
    //   (<NotMacroId> ",")+ = (<NotMacroId> ",")+ NotMacroId "," (*) [">"]
    //   (<NotMacroId> ",")+ = (<NotMacroId> ",")+ NotMacroId "," (*) ["Id"]
    //
    //   ">" -> Reduce((<NotMacroId> ",")+ = (<NotMacroId> ",")+, NotMacroId, "," => ActionFn(254);)
    //   "Id" -> Reduce((<NotMacroId> ",")+ = (<NotMacroId> ",")+, NotMacroId, "," => ActionFn(254);)
    //
    pub fn ___state263<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
        ___sym1: &mut Option<NonterminalString>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action254(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 264
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [";"]
    //   Alternative = (*) @L Symbol+ @R [";"]
    //   Alternative = (*) @L Symbol+ Action @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [";"]
    //   Alternative = (*) @L "if" Cond Action @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" (*) Alternatives [EOF]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["#"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["Escape"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["Id"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["extern"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["pub"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "{" -> Shift(S232)
    //
    //   @L -> S229
    //   Alternative -> S230
    //   Alternatives -> S300
    pub fn ___state264<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<TypeRef>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state300(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 265
    //   @R = (*) [";"]
    //   Alternative = @L Action (*) @R [";"]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Alternative = @L Action (*) @R [","]
    //   Alternative = @L Action (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S301
    pub fn ___state265<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state301(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 266
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @R = (*) [";"]
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Alternative = @L Symbol+ (*) @R [";"]
    //   Alternative = @L Symbol+ (*) Action @R [";"]
    //   Alternative = @L Symbol+ (*) "if" Cond @R [";"]
    //   Alternative = @L Symbol+ (*) "if" Cond Action @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [";"]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>?"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["RegexLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Action = (*) "=>" [","]
    //   Action = (*) "=>" ["}"]
    //   Action = (*) "=>?" [","]
    //   Action = (*) "=>?" ["}"]
    //   Action = (*) "=>@L" [","]
    //   Action = (*) "=>@L" ["}"]
    //   Action = (*) "=>@R" [","]
    //   Action = (*) "=>@R" ["}"]
    //   Alternative = @L Symbol+ (*) @R [","]
    //   Alternative = @L Symbol+ (*) @R ["}"]
    //   Alternative = @L Symbol+ (*) Action @R [","]
    //   Alternative = @L Symbol+ (*) Action @R ["}"]
    //   Alternative = @L Symbol+ (*) "if" Cond @R [","]
    //   Alternative = @L Symbol+ (*) "if" Cond @R ["}"]
    //   Alternative = @L Symbol+ (*) "if" Cond Action @R [","]
    //   Alternative = @L Symbol+ (*) "if" Cond Action @R ["}"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["}"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["}"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol = (*) Symbol0 ["}"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [","]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>?"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["RegexLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["if"]
    //   Symbol+ = Symbol+ (*) Symbol ["}"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["}"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol0 = (*) Symbol1 ["}"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Shift(S267)
    //   "=>?" -> Shift(S268)
    //   "=>@L" -> Shift(S269)
    //   "=>@R" -> Shift(S270)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Shift(S304)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @L -> S157
    //   @R -> S302
    //   Action -> S303
    //   Symbol -> S295
    //   Symbol0 -> S159
    //   Symbol1 -> S160
    pub fn ___state266<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state267(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state268(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state269(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state270(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::If, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state304(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state157(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state302(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Action(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state303(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state295(text, ___lookbehind, ___tokens, ___lookahead, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state159(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 267
    //   Action = "=>" (*) [";"]
    //   Action = "=>" (*) [","]
    //   Action = "=>" (*) ["}"]
    //
    //   "," -> Reduce(Action = "=>" => ActionFn(24);)
    //   ";" -> Reduce(Action = "=>" => ActionFn(24);)
    //   "}" -> Reduce(Action = "=>" => ActionFn(24);)
    //
    pub fn ___state267<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action24(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 268
    //   Action = "=>?" (*) [";"]
    //   Action = "=>?" (*) [","]
    //   Action = "=>?" (*) ["}"]
    //
    //   "," -> Reduce(Action = "=>?" => ActionFn(25);)
    //   ";" -> Reduce(Action = "=>?" => ActionFn(25);)
    //   "}" -> Reduce(Action = "=>?" => ActionFn(25);)
    //
    pub fn ___state268<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action25(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 269
    //   Action = "=>@L" (*) [";"]
    //   Action = "=>@L" (*) [","]
    //   Action = "=>@L" (*) ["}"]
    //
    //   "," -> Reduce(Action = "=>@L" => ActionFn(22);)
    //   ";" -> Reduce(Action = "=>@L" => ActionFn(22);)
    //   "}" -> Reduce(Action = "=>@L" => ActionFn(22);)
    //
    pub fn ___state269<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action22(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 270
    //   Action = "=>@R" (*) [";"]
    //   Action = "=>@R" (*) [","]
    //   Action = "=>@R" (*) ["}"]
    //
    //   "," -> Reduce(Action = "=>@R" => ActionFn(23);)
    //   ";" -> Reduce(Action = "=>@R" => ActionFn(23);)
    //   "}" -> Reduce(Action = "=>@R" => ActionFn(23);)
    //
    pub fn ___state270<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action23(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 271
    //   @L = (*) ["Id"]
    //   Alternative = @L "if" (*) Cond Action @R [";"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   @L = (*) ["Id"]
    //   Alternative = @L "if" (*) Cond Action @R [","]
    //   Alternative = @L "if" (*) Cond Action @R ["}"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S305
    //   Cond -> S306
    pub fn ___state271<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state305(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Cond(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state306(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 272
    //   Alternatives = Alternative ";" (*) [EOF]
    //   Alternatives = Alternative ";" (*) ["#"]
    //   Alternatives = Alternative ";" (*) ["Escape"]
    //   Alternatives = Alternative ";" (*) ["Id"]
    //   Alternatives = Alternative ";" (*) ["MacroId"]
    //   Alternatives = Alternative ";" (*) ["extern"]
    //   Alternatives = Alternative ";" (*) ["pub"]
    //   Alternatives = Alternative ";" (*) ["use"]
    //
    //   EOF -> Reduce(Alternatives = Alternative, ";" => ActionFn(18);)
    //   "#" -> Reduce(Alternatives = Alternative, ";" => ActionFn(18);)
    //   "Escape" -> Reduce(Alternatives = Alternative, ";" => ActionFn(18);)
    //   "Id" -> Reduce(Alternatives = Alternative, ";" => ActionFn(18);)
    //   "MacroId" -> Reduce(Alternatives = Alternative, ";" => ActionFn(18);)
    //   "extern" -> Reduce(Alternatives = Alternative, ";" => ActionFn(18);)
    //   "pub" -> Reduce(Alternatives = Alternative, ";" => ActionFn(18);)
    //   "use" -> Reduce(Alternatives = Alternative, ";" => ActionFn(18);)
    //
    pub fn ___state272<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Alternative>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action18(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternatives(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 273
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["("]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["<"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["=>"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["=>?"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["=>@L"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["=>@R"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["@L"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["@R"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["Escape"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["Id"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["MacroId"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["RegexLiteral"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["StringLiteral"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["if"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ (*) Alternative "," ["}"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [","]
    //   Alternative = (*) @L Action @R ["}"]
    //   Alternative = (*) @L Symbol+ @R [","]
    //   Alternative = (*) @L Symbol+ @R ["}"]
    //   Alternative = (*) @L Symbol+ Action @R [","]
    //   Alternative = (*) @L Symbol+ Action @R ["}"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [","]
    //   Alternative = (*) @L Symbol+ "if" Cond @R ["}"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [","]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R ["}"]
    //   Alternative = (*) @L "if" Cond Action @R [","]
    //   Alternative = (*) @L "if" Cond Action @R ["}"]
    //   Comma<Alternative> = (<Alternative> ",")+ (*) ["}"]
    //   Comma<Alternative> = (<Alternative> ",")+ (*) Alternative ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "}" -> Reduce(Comma<Alternative> = (<Alternative> ",")+ => ActionFn(284);)
    //
    //   @L -> S229
    //   Alternative -> S307
    pub fn ___state273<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action284(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cAlternative_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state307(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 274
    //   (<Alternative> ",")+ = Alternative (*) "," ["("]
    //   (<Alternative> ",")+ = Alternative (*) "," ["<"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["=>"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["=>?"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["=>@L"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["=>@R"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["@L"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["@R"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["Escape"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["Id"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["MacroId"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["RegexLiteral"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["StringLiteral"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["if"]
    //   (<Alternative> ",")+ = Alternative (*) "," ["}"]
    //   Comma<Alternative> = Alternative (*) ["}"]
    //
    //   "," -> Shift(S308)
    //   "}" -> Reduce(Comma<Alternative> = Alternative => ActionFn(281);)
    //
    pub fn ___state274<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state308(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action281(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cAlternative_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 275
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" [EOF]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["#"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["Escape"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["Id"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["MacroId"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["extern"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["pub"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["use"]
    //
    //   "}" -> Shift(S309)
    //
    pub fn ___state275<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state309(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 276
    //   AssociatedType+ = AssociatedType+ AssociatedType (*) ["enum"]
    //   AssociatedType+ = AssociatedType+ AssociatedType (*) ["type"]
    //   AssociatedType+ = AssociatedType+ AssociatedType (*) ["}"]
    //   AssociatedType+ = AssociatedType+ AssociatedType (*) ["type"]
    //   AssociatedType+ = AssociatedType+ AssociatedType (*) ["}"]
    //
    //   "enum" -> Reduce(AssociatedType+ = AssociatedType+, AssociatedType => ActionFn(180);)
    //   "type" -> Reduce(AssociatedType+ = AssociatedType+, AssociatedType => ActionFn(180);)
    //   "}" -> Reduce(AssociatedType+ = AssociatedType+, AssociatedType => ActionFn(180);)
    //
    pub fn ___state276<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym1: &mut Option<AssociatedType>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Enum, _)) |
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action180(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::AssociatedType_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 277
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType+ = (*) AssociatedType ["type"]
    //   AssociatedType+ = (*) AssociatedType ["}"]
    //   AssociatedType+ = (*) AssociatedType+ AssociatedType ["type"]
    //   AssociatedType+ = (*) AssociatedType+ AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) AssociatedType+ "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) AssociatedType+ "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) AssociatedType+ "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) AssociatedType+ "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) AssociatedType+ "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) AssociatedType+ "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) AssociatedType+ "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) AssociatedType+ "}" ["use"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken (*) "}" ["use"]
    //
    //   "type" -> Shift(S237)
    //   "}" -> Shift(S311)
    //
    //   AssociatedType -> S233
    //   AssociatedType+ -> S310
    pub fn ___state277<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<EnumToken>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Type, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state237(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state311(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state233(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::AssociatedType_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state310(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 278
    //   ExternToken = @L "extern" @R "{" AssociatedType+ "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ "}" (*) ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ "}" (*) ["use"]
    //
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, "}" => ActionFn(302);)
    //   "#" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, "}" => ActionFn(302);)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, "}" => ActionFn(302);)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, "}" => ActionFn(302);)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, "}" => ActionFn(302);)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, "}" => ActionFn(302);)
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, "}" => ActionFn(302);)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, "}" => ActionFn(302);)
    //
    pub fn ___state278<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action302(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExternToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 279
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType+ = AssociatedType+ (*) AssociatedType ["type"]
    //   AssociatedType+ = AssociatedType+ (*) AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ (*) "}" ["#"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ (*) "}" ["use"]
    //
    //   "type" -> Shift(S237)
    //   "}" -> Shift(S312)
    //
    //   AssociatedType -> S276
    pub fn ___state279<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<EnumToken>,
        ___sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Type, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state237(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state312(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state276(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 280
    //   ExternToken = @L "extern" @R "{" EnumToken "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" EnumToken "}" (*) ["#"]
    //   ExternToken = @L "extern" @R "{" EnumToken "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" EnumToken "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" EnumToken "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" EnumToken "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" EnumToken "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" EnumToken "}" (*) ["use"]
    //
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, "}" => ActionFn(297);)
    //   "#" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, "}" => ActionFn(297);)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, "}" => ActionFn(297);)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, "}" => ActionFn(297);)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, "}" => ActionFn(297);)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, "}" => ActionFn(297);)
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, "}" => ActionFn(297);)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, "}" => ActionFn(297);)
    //
    pub fn ___state280<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<EnumToken>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action297(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExternToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 281
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   EnumToken = "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" ["}"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["{"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["{"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["{"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime TypeRef ["{"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["{"]
    //   TypeRef = (*) "&" TypeRef ["{"]
    //   TypeRef = (*) "&" "mut" TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S313
    pub fn ___state281<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state313(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 282
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["}"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["="]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["}"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["="]
    //
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   Id -> S314
    pub fn ___state282<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state314(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 283
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef (*) "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["use"]
    //
    //   "=" -> Shift(S315)
    //
    pub fn ___state283<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state315(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 284
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" Alternatives (*) [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" Alternatives (*) ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" Alternatives (*) ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" Alternatives (*) ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" Alternatives (*) ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" Alternatives (*) ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName @R "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, "=", Alternatives => ActionFn(296);)
    //   "#" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, "=", Alternatives => ActionFn(296);)
    //   "Escape" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, "=", Alternatives => ActionFn(296);)
    //   "Id" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, "=", Alternatives => ActionFn(296);)
    //   "MacroId" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, "=", Alternatives => ActionFn(296);)
    //   "extern" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, "=", Alternatives => ActionFn(296);)
    //   "pub" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, "=", Alternatives => ActionFn(296);)
    //   "use" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, "=", Alternatives => ActionFn(296);)
    //
    pub fn ___state284<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action296(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 285
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" (*) TypeRef "=" Alternatives ["use"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id ["="]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id ["="]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id ["="]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime TypeRef ["="]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef ["="]
    //   TypeRef = (*) "&" TypeRef ["="]
    //   TypeRef = (*) "&" "mut" TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S316
    pub fn ___state285<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state316(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 286
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [";"]
    //   Alternative = (*) @L Symbol+ @R [";"]
    //   Alternative = (*) @L Symbol+ Action @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [";"]
    //   Alternative = (*) @L "if" Cond Action @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" (*) Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" (*) Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" (*) Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" (*) Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" (*) Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" (*) Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "{" -> Shift(S232)
    //
    //   @L -> S229
    //   Alternative -> S230
    //   Alternatives -> S317
    pub fn ___state286<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym6));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state317(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 287
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives [EOF]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["#"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["Id"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["extern"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["pub"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["use"]
    //
    //   "=" -> Shift(S318)
    //
    pub fn ___state287<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state318(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 288
    //   Nonterminal = "pub" @L NonterminalName @R "=" Alternatives (*) [EOF]
    //   Nonterminal = "pub" @L NonterminalName @R "=" Alternatives (*) ["#"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" Alternatives (*) ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" Alternatives (*) ["Id"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" Alternatives (*) ["extern"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" Alternatives (*) ["pub"]
    //   Nonterminal = "pub" @L NonterminalName @R "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(291);)
    //   "#" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(291);)
    //   "Escape" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(291);)
    //   "Id" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(291);)
    //   "MacroId" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(291);)
    //   "extern" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(291);)
    //   "pub" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(291);)
    //   "use" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(291);)
    //
    pub fn ___state288<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action291(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 289
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["extern"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation+ = (*) Annotation ["#"]
    //   Annotation+ = (*) Annotation ["Escape"]
    //   Annotation+ = (*) Annotation ["Id"]
    //   Annotation+ = (*) Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation ["pub"]
    //   Annotation+ = (*) Annotation+ Annotation ["#"]
    //   Annotation+ = (*) Annotation+ Annotation ["Escape"]
    //   Annotation+ = (*) Annotation+ Annotation ["Id"]
    //   Annotation+ = (*) Annotation+ Annotation ["MacroId"]
    //   Annotation+ = (*) Annotation+ Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken AssociatedType+ "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" EnumToken "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" "}" ["use"]
    //   Grammar = Use+ Annotation+ @L "grammar" @R GrammarTypeParameters GrammarParameters "where" ";" GrammarItem+ (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem [EOF]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["#"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Escape"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["Id"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["MacroId"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["extern"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["pub"]
    //   GrammarItem+ = GrammarItem+ (*) GrammarItem ["use"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation+ "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives ["use"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["#"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub" @L NonterminalName @R "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use+, Annotation+, @L, "grammar", @R, GrammarTypeParameters, GrammarParameters, "where", ";", GrammarItem+ => ActionFn(426);)
    //   "#" -> Shift(S7)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "extern" -> Reduce(@L =  => ActionFn(131);)
    //   "pub" -> Shift(S50)
    //   "use" -> Shift(S8)
    //
    //   @L -> S43
    //   Annotation -> S2
    //   Annotation+ -> S44
    //   ExternToken -> S45
    //   GrammarItem -> S87
    //   Nonterminal -> S48
    //   Use -> S49
    pub fn ___state289<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Vec<TypeParameter>>,
        ___sym6: &mut Option<Vec<Parameter>>,
        ___sym7: &mut Option<Vec<&'input str>>,
        ___sym8: &mut Option<Tok<'input>>,
        ___sym9: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym10 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym10));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym10 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym10));
            }
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym10 = &mut Some((___tok0));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym10));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___sym9 = ___sym9.take().unwrap();
                let ___nt = super::___action426(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, ___sym9, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym9.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::Annotation_2b(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym9, ___sym10));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 290
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //
    pub fn ___state290<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action274(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 291
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")+ (*) [">"]
    //   Comma<Symbol> = (<Symbol> ",")+ (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")+ => ActionFn(388);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S157
    //   Symbol -> S319
    //   Symbol0 -> S159
    //   Symbol1 -> S160
    pub fn ___state291<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action388(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state157(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state319(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state159(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 292
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [";"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["if"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["if"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["}"]
    //
    //   ">" -> Shift(S320)
    //
    pub fn ___state292<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state320(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 293
    //   (<Symbol> ",")+ = Symbol (*) "," ["("]
    //   (<Symbol> ",")+ = Symbol (*) "," ["<"]
    //   (<Symbol> ",")+ = Symbol (*) "," [">"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["@L"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["@R"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["Id"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["StringLiteral"]
    //   Comma<Symbol> = Symbol (*) [">"]
    //
    //   "," -> Shift(S321)
    //   ">" -> Reduce(Comma<Symbol> = Symbol => ActionFn(385);)
    //
    pub fn ___state293<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state321(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action385(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 294
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [";"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["if"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["if"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   ";" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "=>" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "=>?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "=>@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "=>@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "if" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "}" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //
    pub fn ___state294<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action45(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 295
    //   Symbol+ = Symbol+ Symbol (*) ["("]
    //   Symbol+ = Symbol+ Symbol (*) [")"]
    //   Symbol+ = Symbol+ Symbol (*) ["<"]
    //   Symbol+ = Symbol+ Symbol (*) ["@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["Escape"]
    //   Symbol+ = Symbol+ Symbol (*) ["Id"]
    //   Symbol+ = Symbol+ Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol+ Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["("]
    //   Symbol+ = Symbol+ Symbol (*) [";"]
    //   Symbol+ = Symbol+ Symbol (*) ["<"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>?"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["Escape"]
    //   Symbol+ = Symbol+ Symbol (*) ["Id"]
    //   Symbol+ = Symbol+ Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol+ Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["if"]
    //   Symbol+ = Symbol+ Symbol (*) ["("]
    //   Symbol+ = Symbol+ Symbol (*) [","]
    //   Symbol+ = Symbol+ Symbol (*) ["<"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>?"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["Escape"]
    //   Symbol+ = Symbol+ Symbol (*) ["Id"]
    //   Symbol+ = Symbol+ Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol+ Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["if"]
    //   Symbol+ = Symbol+ Symbol (*) ["}"]
    //
    //   "(" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   ")" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "," -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   ";" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "<" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "=>" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "=>?" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "=>@L" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "=>@R" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "@L" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "@R" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "Escape" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "Id" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "MacroId" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "RegexLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "if" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "}" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //
    pub fn ___state295<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action112(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 296
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["}"]
    //
    //   ":" -> Shift(S322)
    //
    pub fn ___state296<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state322(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 297
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "+" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ":" -> Reduce(Id = "Id" => ActionFn(73);)
    //   ">" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "?" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //
    pub fn ___state297<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action73(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 298
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "<" -> Reduce(MacroId = "MacroId" => ActionFn(71);)
    //
    pub fn ___state298<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action71(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 299
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [";"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["if"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //   @R = (*) ["("]
    //   @R = (*) [","]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["if"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["}"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   "=>" -> Reduce(@R =  => ActionFn(130);)
    //   "=>?" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@L" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@R" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "if" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S323
    pub fn ___state299<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state323(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 300
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" Alternatives (*) [EOF]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["#"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["Escape"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["Id"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["extern"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["pub"]
    //   Nonterminal = @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(293);)
    //   "#" -> Reduce(Nonterminal = @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(293);)
    //   "Escape" -> Reduce(Nonterminal = @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(293);)
    //   "Id" -> Reduce(Nonterminal = @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(293);)
    //   "MacroId" -> Reduce(Nonterminal = @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(293);)
    //   "extern" -> Reduce(Nonterminal = @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(293);)
    //   "pub" -> Reduce(Nonterminal = @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(293);)
    //   "use" -> Reduce(Nonterminal = @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(293);)
    //
    pub fn ___state300<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<TypeRef>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action293(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 301
    //   Alternative = @L Action @R (*) [";"]
    //   Alternative = @L Action @R (*) [","]
    //   Alternative = @L Action @R (*) ["}"]
    //
    //   "," -> Reduce(Alternative = @L, Action, @R => ActionFn(228);)
    //   ";" -> Reduce(Alternative = @L, Action, @R => ActionFn(228);)
    //   "}" -> Reduce(Alternative = @L, Action, @R => ActionFn(228);)
    //
    pub fn ___state301<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<ActionKind>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action228(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 302
    //   Alternative = @L Symbol+ @R (*) [";"]
    //   Alternative = @L Symbol+ @R (*) [","]
    //   Alternative = @L Symbol+ @R (*) ["}"]
    //
    //   "," -> Reduce(Alternative = @L, Symbol+, @R => ActionFn(280);)
    //   ";" -> Reduce(Alternative = @L, Symbol+, @R => ActionFn(280);)
    //   "}" -> Reduce(Alternative = @L, Symbol+, @R => ActionFn(280);)
    //
    pub fn ___state302<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action280(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 303
    //   @R = (*) [";"]
    //   Alternative = @L Symbol+ Action (*) @R [";"]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Alternative = @L Symbol+ Action (*) @R [","]
    //   Alternative = @L Symbol+ Action (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S324
    pub fn ___state303<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state324(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 304
    //   @L = (*) ["Id"]
    //   Alternative = @L Symbol+ "if" (*) Cond @R [";"]
    //   Alternative = @L Symbol+ "if" (*) Cond Action @R [";"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R [";"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   @L = (*) ["Id"]
    //   Alternative = @L Symbol+ "if" (*) Cond @R [","]
    //   Alternative = @L Symbol+ "if" (*) Cond @R ["}"]
    //   Alternative = @L Symbol+ "if" (*) Cond Action @R [","]
    //   Alternative = @L Symbol+ "if" (*) Cond Action @R ["}"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R [","]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["}"]
    //
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S305
    //   Cond -> S325
    pub fn ___state304<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state305(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Cond(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state325(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 305
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   NotMacroId = (*) "Id" ["!="]
    //   NotMacroId = (*) "Id" ["!~"]
    //   NotMacroId = (*) "Id" ["=="]
    //   NotMacroId = (*) "Id" ["~~"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R [";"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   NotMacroId = (*) "Id" ["!="]
    //   NotMacroId = (*) "Id" ["!~"]
    //   NotMacroId = (*) "Id" ["=="]
    //   NotMacroId = (*) "Id" ["~~"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R [","]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["}"]
    //   NotMacroId = (*) "Id" ["!="]
    //   NotMacroId = (*) "Id" ["!~"]
    //   NotMacroId = (*) "Id" ["=="]
    //   NotMacroId = (*) "Id" ["~~"]
    //
    //   "Id" -> Shift(S82)
    //
    //   NotMacroId -> S326
    pub fn ___state305<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state326(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 306
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Alternative = @L "if" Cond (*) Action @R [";"]
    //   Action = (*) "=>" [","]
    //   Action = (*) "=>" ["}"]
    //   Action = (*) "=>?" [","]
    //   Action = (*) "=>?" ["}"]
    //   Action = (*) "=>@L" [","]
    //   Action = (*) "=>@L" ["}"]
    //   Action = (*) "=>@R" [","]
    //   Action = (*) "=>@R" ["}"]
    //   Alternative = @L "if" Cond (*) Action @R [","]
    //   Alternative = @L "if" Cond (*) Action @R ["}"]
    //
    //   "=>" -> Shift(S267)
    //   "=>?" -> Shift(S268)
    //   "=>@L" -> Shift(S269)
    //   "=>@R" -> Shift(S270)
    //
    //   Action -> S327
    pub fn ___state306<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Condition>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state267(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state268(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state269(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state270(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Action(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state327(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 307
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["("]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["<"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["=>"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["=>?"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["=>@L"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["=>@R"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["@L"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["@R"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["Escape"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["Id"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["MacroId"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["RegexLiteral"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["StringLiteral"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["if"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative (*) "," ["}"]
    //   Comma<Alternative> = (<Alternative> ",")+ Alternative (*) ["}"]
    //
    //   "," -> Shift(S328)
    //   "}" -> Reduce(Comma<Alternative> = (<Alternative> ",")+, Alternative => ActionFn(283);)
    //
    pub fn ___state307<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Alternative>>,
        ___sym1: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state328(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action283(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cAlternative_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 308
    //   (<Alternative> ",")+ = Alternative "," (*) ["("]
    //   (<Alternative> ",")+ = Alternative "," (*) ["<"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["=>"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["=>?"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["=>@L"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["=>@R"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["@L"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["@R"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["Escape"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["Id"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["MacroId"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["RegexLiteral"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["StringLiteral"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["if"]
    //   (<Alternative> ",")+ = Alternative "," (*) ["}"]
    //
    //   "(" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "<" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "=>" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "=>?" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "=>@L" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "=>@R" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "@L" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "@R" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "Escape" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "Id" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "MacroId" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "RegexLiteral" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "StringLiteral" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "if" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //   "}" -> Reduce((<Alternative> ",")+ = Alternative, "," => ActionFn(229);)
    //
    pub fn ___state308<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Alternative>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action229(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cAlternative_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 309
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" [EOF]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["#"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["Escape"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["Id"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["MacroId"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["extern"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["pub"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["use"]
    //
    //   ";" -> Shift(S329)
    //
    pub fn ___state309<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Alternative>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state329(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 310
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType+ = AssociatedType+ (*) AssociatedType ["type"]
    //   AssociatedType+ = AssociatedType+ (*) AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ (*) "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ (*) "}" ["use"]
    //
    //   "type" -> Shift(S237)
    //   "}" -> Shift(S330)
    //
    //   AssociatedType -> S276
    pub fn ___state310<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<EnumToken>,
        ___sym6: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Type, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state237(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state330(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state276(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 311
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken "}" (*) ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken "}" (*) ["use"]
    //
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, "}" => ActionFn(299);)
    //   "#" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, "}" => ActionFn(299);)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, "}" => ActionFn(299);)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, "}" => ActionFn(299);)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, "}" => ActionFn(299);)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, "}" => ActionFn(299);)
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, "}" => ActionFn(299);)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, "}" => ActionFn(299);)
    //
    pub fn ___state311<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<EnumToken>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action299(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExternToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 312
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ "}" (*) ["#"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" EnumToken AssociatedType+ "}" (*) ["use"]
    //
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, AssociatedType+, "}" => ActionFn(298);)
    //   "#" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, AssociatedType+, "}" => ActionFn(298);)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, AssociatedType+, "}" => ActionFn(298);)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, AssociatedType+, "}" => ActionFn(298);)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, AssociatedType+, "}" => ActionFn(298);)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, AssociatedType+, "}" => ActionFn(298);)
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, AssociatedType+, "}" => ActionFn(298);)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", EnumToken, AssociatedType+, "}" => ActionFn(298);)
    //
    pub fn ___state312<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<EnumToken>,
        ___sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action298(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExternToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 313
    //   @R = (*) ["{"]
    //   EnumToken = "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" ["}"]
    //
    //   "{" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S331
    pub fn ___state313<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state331(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 314
    //   @R = (*) ["="]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["}"]
    //   @R = (*) ["="]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["}"]
    //
    //   "=" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S332
    pub fn ___state314<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Equals, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state332(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 315
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [";"]
    //   Alternative = (*) @L Symbol+ @R [";"]
    //   Alternative = (*) @L Symbol+ Action @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [";"]
    //   Alternative = (*) @L "if" Cond Action @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" (*) Alternatives [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "{" -> Shift(S232)
    //
    //   @L -> S229
    //   Alternative -> S230
    //   Alternatives -> S333
    pub fn ___state315<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state333(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 316
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef (*) "=" Alternatives ["use"]
    //
    //   "=" -> Shift(S334)
    //
    pub fn ___state316<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state334(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 317
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" Alternatives (*) [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" Alternatives (*) ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" Alternatives (*) ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" Alternatives (*) ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" Alternatives (*) ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" Alternatives (*) ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(292);)
    //   "#" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(292);)
    //   "Escape" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(292);)
    //   "Id" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(292);)
    //   "MacroId" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(292);)
    //   "extern" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(292);)
    //   "pub" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(292);)
    //   "use" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, "=", Alternatives => ActionFn(292);)
    //
    pub fn ___state317<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action292(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 318
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [";"]
    //   Alternative = (*) @L Symbol+ @R [";"]
    //   Alternative = (*) @L Symbol+ Action @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [";"]
    //   Alternative = (*) @L "if" Cond Action @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives [EOF]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["#"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["Id"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["extern"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["pub"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "{" -> Shift(S232)
    //
    //   @L -> S229
    //   Alternative -> S230
    //   Alternatives -> S335
    pub fn ___state318<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state335(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 319
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")+ Symbol (*) [">"]
    //
    //   "," -> Shift(S336)
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")+, Symbol => ActionFn(387);)
    //
    pub fn ___state319<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state336(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action387(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 320
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [";"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["if"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["if"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   ";" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "=>" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "=>?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "=>@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "=>@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "if" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "}" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //
    pub fn ___state320<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action41(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 321
    //   (<Symbol> ",")+ = Symbol "," (*) ["("]
    //   (<Symbol> ",")+ = Symbol "," (*) ["<"]
    //   (<Symbol> ",")+ = Symbol "," (*) [">"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["@L"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["@R"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["Id"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "<" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   ">" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "@L" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "@R" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "Escape" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "Id" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "MacroId" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "StringLiteral" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //
    pub fn ___state321<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action261(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 322
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["}"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S337
    //   Symbol0 -> S338
    //   Symbol1 -> S160
    pub fn ___state322<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state337(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state338(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 323
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [";"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["if"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["if"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["}"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   ";" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "=>" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "=>?" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "=>@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "=>@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "if" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "}" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //
    pub fn ___state323<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action33(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 324
    //   Alternative = @L Symbol+ Action @R (*) [";"]
    //   Alternative = @L Symbol+ Action @R (*) [","]
    //   Alternative = @L Symbol+ Action @R (*) ["}"]
    //
    //   "," -> Reduce(Alternative = @L, Symbol+, Action, @R => ActionFn(279);)
    //   ";" -> Reduce(Alternative = @L, Symbol+, Action, @R => ActionFn(279);)
    //   "}" -> Reduce(Alternative = @L, Symbol+, Action, @R => ActionFn(279);)
    //
    pub fn ___state324<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<ActionKind>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action279(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 325
    //   @R = (*) [";"]
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Alternative = @L Symbol+ "if" Cond (*) @R [";"]
    //   Alternative = @L Symbol+ "if" Cond (*) Action @R [";"]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Action = (*) "=>" [","]
    //   Action = (*) "=>" ["}"]
    //   Action = (*) "=>?" [","]
    //   Action = (*) "=>?" ["}"]
    //   Action = (*) "=>@L" [","]
    //   Action = (*) "=>@L" ["}"]
    //   Action = (*) "=>@R" [","]
    //   Action = (*) "=>@R" ["}"]
    //   Alternative = @L Symbol+ "if" Cond (*) @R [","]
    //   Alternative = @L Symbol+ "if" Cond (*) @R ["}"]
    //   Alternative = @L Symbol+ "if" Cond (*) Action @R [","]
    //   Alternative = @L Symbol+ "if" Cond (*) Action @R ["}"]
    //
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "=>" -> Shift(S267)
    //   "=>?" -> Shift(S268)
    //   "=>@L" -> Shift(S269)
    //   "=>@R" -> Shift(S270)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S339
    //   Action -> S340
    pub fn ___state325<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<Condition>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state267(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok0));
                ___result = try!(___state268(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state269(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state270(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state339(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                ___Nonterminal::Action(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state340(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 326
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@R"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R [";"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@R"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R [","]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@R"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["}"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //
    //   "!=" -> Shift(S342)
    //   "!~" -> Shift(S343)
    //   "==" -> Shift(S344)
    //   "~~" -> Shift(S345)
    //
    //   CondOp -> S341
    pub fn ___state326<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::BangEquals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state342(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::BangTilde, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state343(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::EqualsEquals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state344(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::TildeTilde, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state345(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::CondOp(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state341(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 327
    //   @R = (*) [";"]
    //   Alternative = @L "if" Cond Action (*) @R [";"]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Alternative = @L "if" Cond Action (*) @R [","]
    //   Alternative = @L "if" Cond Action (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S346
    pub fn ___state327<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Condition>,
        ___sym3: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state346(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 328
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["("]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["<"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["=>"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["=>?"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["=>@L"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["=>@R"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["@L"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["@R"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["Escape"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["Id"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["MacroId"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["RegexLiteral"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["StringLiteral"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["if"]
    //   (<Alternative> ",")+ = (<Alternative> ",")+ Alternative "," (*) ["}"]
    //
    //   "(" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "<" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "=>" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "=>?" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "=>@L" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "=>@R" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "@L" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "@R" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "Escape" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "Id" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "MacroId" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "RegexLiteral" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "StringLiteral" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "if" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //   "}" -> Reduce((<Alternative> ",")+ = (<Alternative> ",")+, Alternative, "," => ActionFn(230);)
    //
    pub fn ___state328<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Alternative>>,
        ___sym1: &mut Option<Alternative>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action230(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cAlternative_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 329
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) [EOF]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["#"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["Escape"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["Id"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["MacroId"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["extern"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["pub"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["use"]
    //
    //   EOF -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => ActionFn(19);)
    //   "#" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => ActionFn(19);)
    //   "Escape" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => ActionFn(19);)
    //   "Id" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => ActionFn(19);)
    //   "MacroId" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => ActionFn(19);)
    //   "extern" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => ActionFn(19);)
    //   "pub" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => ActionFn(19);)
    //   "use" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => ActionFn(19);)
    //
    pub fn ___state329<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Alternative>>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action19(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternatives(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 330
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" (*) ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType+ EnumToken AssociatedType+ "}" (*) ["use"]
    //
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, AssociatedType+, "}" => ActionFn(300);)
    //   "#" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, AssociatedType+, "}" => ActionFn(300);)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, AssociatedType+, "}" => ActionFn(300);)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, AssociatedType+, "}" => ActionFn(300);)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, AssociatedType+, "}" => ActionFn(300);)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, AssociatedType+, "}" => ActionFn(300);)
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, AssociatedType+, "}" => ActionFn(300);)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType+, EnumToken, AssociatedType+, "}" => ActionFn(300);)
    //
    pub fn ___state330<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<EnumToken>,
        ___sym6: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action300(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExternToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 331
    //   EnumToken = "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" ["}"]
    //
    //   "{" -> Shift(S347)
    //
    pub fn ___state331<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state347(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 332
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["}"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["}"]
    //
    //   "=" -> Shift(S348)
    //
    pub fn ___state332<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state348(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 333
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives (*) [EOF]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["#"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["Escape"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["Id"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["extern"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["pub"]
    //   Nonterminal = Annotation+ @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(294);)
    //   "#" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(294);)
    //   "Escape" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(294);)
    //   "Id" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(294);)
    //   "MacroId" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(294);)
    //   "extern" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(294);)
    //   "pub" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(294);)
    //   "use" -> Reduce(Nonterminal = Annotation+, @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(294);)
    //
    pub fn ___state333<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action294(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 334
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Action @R [";"]
    //   Alternative = (*) @L Symbol+ @R [";"]
    //   Alternative = (*) @L Symbol+ Action @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond @R [";"]
    //   Alternative = (*) @L Symbol+ "if" Cond Action @R [";"]
    //   Alternative = (*) @L "if" Cond Action @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //   "=>?" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@L" -> Reduce(@L =  => ActionFn(131);)
    //   "=>@R" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "if" -> Reduce(@L =  => ActionFn(131);)
    //   "{" -> Shift(S232)
    //
    //   @L -> S229
    //   Alternative -> S230
    //   Alternatives -> S349
    pub fn ___state334<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<TypeRef>,
        ___sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym8));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym7.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state229(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym8));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym8 = &mut Some(___nt);
                    ___result = try!(___state349(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 335
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) [EOF]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["#"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["Escape"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["Id"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["extern"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["pub"]
    //   Nonterminal = "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(289);)
    //   "#" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(289);)
    //   "Escape" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(289);)
    //   "Id" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(289);)
    //   "MacroId" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(289);)
    //   "extern" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(289);)
    //   "pub" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(289);)
    //   "use" -> Reduce(Nonterminal = "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(289);)
    //
    pub fn ___state335<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action289(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 336
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "<" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   ">" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "@L" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "@R" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "Escape" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "Id" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "MacroId" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "StringLiteral" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //
    pub fn ___state336<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action262(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 337
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S205)
    //   "@L" -> Shift(S207)
    //   "@R" -> Shift(S208)
    //   "Escape" -> Shift(S209)
    //   "Id" -> Shift(S210)
    //   "MacroId" -> Shift(S83)
    //   "RegexLiteral" -> Shift(S211)
    //   "StringLiteral" -> Shift(S212)
    //
    //   Escape -> S199
    //   MacroId -> S200
    //   QuotedTerminal -> S201
    //   RegexLiteral -> S202
    //   StringLiteral -> S203
    //   SymbolKind1 -> S204
    pub fn ___state337<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state205(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state207(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state208(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state209(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state210(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state83(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state211(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state212(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state199(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state200(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state201(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state202(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state203(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state204(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 338
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["}"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S215)
    //   "+" -> Shift(S216)
    //   ">" -> Shift(S350)
    //   "?" -> Shift(S217)
    //
    //   RepeatOp -> S214
    pub fn ___state338<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state215(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state216(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state350(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state217(text, ___lookbehind, ___tokens, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state214(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 339
    //   Alternative = @L Symbol+ "if" Cond @R (*) [";"]
    //   Alternative = @L Symbol+ "if" Cond @R (*) [","]
    //   Alternative = @L Symbol+ "if" Cond @R (*) ["}"]
    //
    //   "," -> Reduce(Alternative = @L, Symbol+, "if", Cond, @R => ActionFn(278);)
    //   ";" -> Reduce(Alternative = @L, Symbol+, "if", Cond, @R => ActionFn(278);)
    //   "}" -> Reduce(Alternative = @L, Symbol+, "if", Cond, @R => ActionFn(278);)
    //
    pub fn ___state339<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<Condition>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action278(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 340
    //   @R = (*) [";"]
    //   Alternative = @L Symbol+ "if" Cond Action (*) @R [";"]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Alternative = @L Symbol+ "if" Cond Action (*) @R [","]
    //   Alternative = @L Symbol+ "if" Cond Action (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S351
    pub fn ___state340<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<Condition>,
        ___sym4: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state351(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 341
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R [";"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" [";"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R [","]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@R"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["}"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["}"]
    //
    //   "StringLiteral" -> Shift(S212)
    //
    //   StringLiteral -> S352
    pub fn ___state341<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<NonterminalString>,
        ___sym2: &mut Option<ConditionOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state212(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state352(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 342
    //   CondOp = "!=" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "!=" => ActionFn(28);)
    //
    pub fn ___state342<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action28(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::CondOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 343
    //   CondOp = "!~" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "!~" => ActionFn(30);)
    //
    pub fn ___state343<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action30(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::CondOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 344
    //   CondOp = "==" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "==" => ActionFn(27);)
    //
    pub fn ___state344<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action27(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::CondOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 345
    //   CondOp = "~~" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "~~" => ActionFn(29);)
    //
    pub fn ___state345<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action29(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::CondOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 346
    //   Alternative = @L "if" Cond Action @R (*) [";"]
    //   Alternative = @L "if" Cond Action @R (*) [","]
    //   Alternative = @L "if" Cond Action @R (*) ["}"]
    //
    //   "," -> Reduce(Alternative = @L, "if", Cond, Action, @R => ActionFn(227);)
    //   ";" -> Reduce(Alternative = @L, "if", Cond, Action, @R => ActionFn(227);)
    //   "}" -> Reduce(Alternative = @L, "if", Cond, Action, @R => ActionFn(227);)
    //
    pub fn ___state346<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Condition>,
        ___sym3: &mut Option<ActionKind>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action227(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 347
    //   (<Conversion> ",")+ = (*) (<Conversion> ",")+ Conversion "," ["Id"]
    //   (<Conversion> ",")+ = (*) (<Conversion> ",")+ Conversion "," ["RegexLiteral"]
    //   (<Conversion> ",")+ = (*) (<Conversion> ",")+ Conversion "," ["StringLiteral"]
    //   (<Conversion> ",")+ = (*) (<Conversion> ",")+ Conversion "," ["}"]
    //   (<Conversion> ",")+ = (*) Conversion "," ["Id"]
    //   (<Conversion> ",")+ = (*) Conversion "," ["RegexLiteral"]
    //   (<Conversion> ",")+ = (*) Conversion "," ["StringLiteral"]
    //   (<Conversion> ",")+ = (*) Conversion "," ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Conversion> = (*) ["}"]
    //   Comma<Conversion> = (*) (<Conversion> ",")+ ["}"]
    //   Comma<Conversion> = (*) (<Conversion> ",")+ Conversion ["}"]
    //   Comma<Conversion> = (*) Conversion ["}"]
    //   Conversion = (*) @L Terminal @L "=>" @R [","]
    //   Conversion = (*) @L Terminal @L "=>" @R ["}"]
    //   EnumToken = "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" ["}"]
    //
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "}" -> Reduce(Comma<Conversion> =  => ActionFn(304);)
    //
    //   (<Conversion> ",")+ -> S353
    //   @L -> S354
    //   Comma<Conversion> -> S355
    //   Conversion -> S356
    pub fn ___state347<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action304(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cConversion_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state353(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state354(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Comma_3cConversion_3e(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state355(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Conversion(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state356(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 348
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["}"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [";"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [";"]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [";"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [";"]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime TypeRef [";"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [";"]
    //   TypeRef = (*) "&" TypeRef [";"]
    //   TypeRef = (*) "&" "mut" TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["}"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [";"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [";"]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [";"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [";"]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime TypeRef [";"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [";"]
    //   TypeRef = (*) "&" TypeRef [";"]
    //   TypeRef = (*) "&" "mut" TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Shift(S121)
    //   "&" -> Shift(S122)
    //   "(" -> Shift(S123)
    //   "::" -> Shift(S124)
    //   "Id" -> Shift(S32)
    //   "MacroId" -> Shift(S33)
    //
    //   (<Id> "::")+ -> S117
    //   Id -> S118
    //   Path -> S119
    //   TypeRef -> S357
    pub fn ___state348<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state121(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state122(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok0));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state357(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 349
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) [EOF]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["#"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["Escape"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["Id"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["extern"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["pub"]
    //   Nonterminal = Annotation+ "pub" @L NonterminalName @R ":" TypeRef "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(290);)
    //   "#" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(290);)
    //   "Escape" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(290);)
    //   "Id" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(290);)
    //   "MacroId" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(290);)
    //   "extern" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(290);)
    //   "pub" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(290);)
    //   "use" -> Reduce(Nonterminal = Annotation+, "pub", @L, NonterminalName, @R, ":", TypeRef, "=", Alternatives => ActionFn(290);)
    //
    pub fn ___state349<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
        ___sym6: &mut Option<TypeRef>,
        ___sym7: &mut Option<Tok<'input>>,
        ___sym8: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___nt = super::___action290(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 350
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["if"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //   @R = (*) ["("]
    //   @R = (*) [","]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["}"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   "=>" -> Reduce(@R =  => ActionFn(130);)
    //   "=>?" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@L" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@R" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "if" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S358
    pub fn ___state350<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state358(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 351
    //   Alternative = @L Symbol+ "if" Cond Action @R (*) [";"]
    //   Alternative = @L Symbol+ "if" Cond Action @R (*) [","]
    //   Alternative = @L Symbol+ "if" Cond Action @R (*) ["}"]
    //
    //   "," -> Reduce(Alternative = @L, Symbol+, "if", Cond, Action, @R => ActionFn(277);)
    //   ";" -> Reduce(Alternative = @L, Symbol+, "if", Cond, Action, @R => ActionFn(277);)
    //   "}" -> Reduce(Alternative = @L, Symbol+, "if", Cond, Action, @R => ActionFn(277);)
    //
    pub fn ___state351<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<Condition>,
        ___sym4: &mut Option<ActionKind>,
        ___sym5: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action277(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 352
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@R"]
    //   @R = (*) [";"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R [";"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@R"]
    //   @R = (*) [","]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["}"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R [","]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   ";" -> Reduce(@R =  => ActionFn(130);)
    //   "=>" -> Reduce(@R =  => ActionFn(130);)
    //   "=>?" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@L" -> Reduce(@R =  => ActionFn(130);)
    //   "=>@R" -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S359
    pub fn ___state352<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<NonterminalString>,
        ___sym2: &mut Option<ConditionOp>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state359(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 353
    //   (<Conversion> ",")+ = (<Conversion> ",")+ (*) Conversion "," ["Id"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ (*) Conversion "," ["RegexLiteral"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ (*) Conversion "," ["StringLiteral"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ (*) Conversion "," ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Conversion> = (<Conversion> ",")+ (*) ["}"]
    //   Comma<Conversion> = (<Conversion> ",")+ (*) Conversion ["}"]
    //   Conversion = (*) @L Terminal @L "=>" @R [","]
    //   Conversion = (*) @L Terminal @L "=>" @R ["}"]
    //
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "}" -> Reduce(Comma<Conversion> = (<Conversion> ",")+ => ActionFn(306);)
    //
    //   @L -> S354
    //   Conversion -> S360
    pub fn ___state353<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action306(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cConversion_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state354(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Conversion(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state360(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 354
    //   Conversion = @L (*) Terminal @L "=>" @R [","]
    //   Conversion = @L (*) Terminal @L "=>" @R ["}"]
    //   QuotedTerminal = (*) RegexLiteral ["=>"]
    //   QuotedTerminal = (*) StringLiteral ["=>"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   Terminal = (*) QuotedTerminal ["=>"]
    //   Terminal = (*) "Id" ["=>"]
    //
    //   "Id" -> Shift(S363)
    //   "RegexLiteral" -> Shift(S211)
    //   "StringLiteral" -> Shift(S212)
    //
    //   QuotedTerminal -> S361
    //   RegexLiteral -> S202
    //   StringLiteral -> S203
    //   Terminal -> S362
    pub fn ___state354<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state363(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state211(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state212(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state361(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state202(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state203(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Terminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state362(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 355
    //   EnumToken = "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" ["type"]
    //   EnumToken = "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" ["}"]
    //
    //   "}" -> Shift(S364)
    //
    pub fn ___state355<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Vec<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state364(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 356
    //   (<Conversion> ",")+ = Conversion (*) "," ["Id"]
    //   (<Conversion> ",")+ = Conversion (*) "," ["RegexLiteral"]
    //   (<Conversion> ",")+ = Conversion (*) "," ["StringLiteral"]
    //   (<Conversion> ",")+ = Conversion (*) "," ["}"]
    //   Comma<Conversion> = Conversion (*) ["}"]
    //
    //   "," -> Shift(S365)
    //   "}" -> Reduce(Comma<Conversion> = Conversion => ActionFn(303);)
    //
    pub fn ___state356<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Conversion>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state365(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action303(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cConversion_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 357
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["enum"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["}"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["}"]
    //
    //   ";" -> Shift(S366)
    //
    pub fn ___state357<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state366(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 358
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["}"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   ";" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "=>" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "=>?" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "=>@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "=>@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "if" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "}" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //
    pub fn ___state358<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action32(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 359
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) [";"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) [","]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["}"]
    //
    //   "," -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => ActionFn(26);)
    //   ";" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => ActionFn(26);)
    //   "=>" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => ActionFn(26);)
    //   "=>?" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => ActionFn(26);)
    //   "=>@L" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => ActionFn(26);)
    //   "=>@R" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => ActionFn(26);)
    //   "}" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => ActionFn(26);)
    //
    pub fn ___state359<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<NonterminalString>,
        ___sym2: &mut Option<ConditionOp>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action26(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Cond(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 360
    //   (<Conversion> ",")+ = (<Conversion> ",")+ Conversion (*) "," ["Id"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ Conversion (*) "," ["RegexLiteral"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ Conversion (*) "," ["StringLiteral"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ Conversion (*) "," ["}"]
    //   Comma<Conversion> = (<Conversion> ",")+ Conversion (*) ["}"]
    //
    //   "," -> Shift(S367)
    //   "}" -> Reduce(Comma<Conversion> = (<Conversion> ",")+, Conversion => ActionFn(305);)
    //
    pub fn ___state360<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Conversion>>,
        ___sym1: &mut Option<Conversion>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state367(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action305(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cConversion_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 361
    //   Terminal = QuotedTerminal (*) ["=>"]
    //
    //   "=>" -> Reduce(Terminal = QuotedTerminal => ActionFn(77);)
    //
    pub fn ___state361<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action77(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Terminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 362
    //   @L = (*) ["=>"]
    //   Conversion = @L Terminal (*) @L "=>" @R [","]
    //   Conversion = @L Terminal (*) @L "=>" @R ["}"]
    //
    //   "=>" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S368
    pub fn ___state362<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state368(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 363
    //   Terminal = "Id" (*) ["=>"]
    //
    //   "=>" -> Reduce(Terminal = "Id" => ActionFn(78);)
    //
    pub fn ___state363<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action78(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Terminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 364
    //   EnumToken = "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) ["type"]
    //   EnumToken = "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) ["}"]
    //
    //   "type" -> Reduce(EnumToken = "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}" => ActionFn(58);)
    //   "}" -> Reduce(EnumToken = "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}" => ActionFn(58);)
    //
    pub fn ___state364<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Vec<Conversion>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action58(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::EnumToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 365
    //   (<Conversion> ",")+ = Conversion "," (*) ["Id"]
    //   (<Conversion> ",")+ = Conversion "," (*) ["RegexLiteral"]
    //   (<Conversion> ",")+ = Conversion "," (*) ["StringLiteral"]
    //   (<Conversion> ",")+ = Conversion "," (*) ["}"]
    //
    //   "Id" -> Reduce((<Conversion> ",")+ = Conversion, "," => ActionFn(233);)
    //   "RegexLiteral" -> Reduce((<Conversion> ",")+ = Conversion, "," => ActionFn(233);)
    //   "StringLiteral" -> Reduce((<Conversion> ",")+ = Conversion, "," => ActionFn(233);)
    //   "}" -> Reduce((<Conversion> ",")+ = Conversion, "," => ActionFn(233);)
    //
    pub fn ___state365<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Conversion>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action233(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 366
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["enum"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["}"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["}"]
    //
    //   "enum" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => ActionFn(59);)
    //   "type" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => ActionFn(59);)
    //   "}" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => ActionFn(59);)
    //
    pub fn ___state366<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Enum, _)) |
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action59(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::AssociatedType(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 367
    //   (<Conversion> ",")+ = (<Conversion> ",")+ Conversion "," (*) ["Id"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ Conversion "," (*) ["RegexLiteral"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ Conversion "," (*) ["StringLiteral"]
    //   (<Conversion> ",")+ = (<Conversion> ",")+ Conversion "," (*) ["}"]
    //
    //   "Id" -> Reduce((<Conversion> ",")+ = (<Conversion> ",")+, Conversion, "," => ActionFn(234);)
    //   "RegexLiteral" -> Reduce((<Conversion> ",")+ = (<Conversion> ",")+, Conversion, "," => ActionFn(234);)
    //   "StringLiteral" -> Reduce((<Conversion> ",")+ = (<Conversion> ",")+, Conversion, "," => ActionFn(234);)
    //   "}" -> Reduce((<Conversion> ",")+ = (<Conversion> ",")+, Conversion, "," => ActionFn(234);)
    //
    pub fn ___state367<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Conversion>>,
        ___sym1: &mut Option<Conversion>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action234(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 368
    //   Conversion = @L Terminal @L (*) "=>" @R [","]
    //   Conversion = @L Terminal @L (*) "=>" @R ["}"]
    //
    //   "=>" -> Shift(S369)
    //
    pub fn ___state368<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<TerminalString>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state369(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 369
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Conversion = @L Terminal @L "=>" (*) @R [","]
    //   Conversion = @L Terminal @L "=>" (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S370
    pub fn ___state369<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<TerminalString>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state370(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 370
    //   Conversion = @L Terminal @L "=>" @R (*) [","]
    //   Conversion = @L Terminal @L "=>" @R (*) ["}"]
    //
    //   "," -> Reduce(Conversion = @L, Terminal, @L, "=>", @R => ActionFn(60);)
    //   "}" -> Reduce(Conversion = @L, Terminal, @L, "=>", @R => ActionFn(60);)
    //
    pub fn ___state370<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<TerminalString>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<&'input str>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = try!(super::___action60(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead));
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Conversion(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
pub use self::___parse___Grammar::parse_Grammar;

mod ___parse___Pattern {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as ___lalrpop_util;
    use self::___lalrpop_util::ParseError as ___ParseError;
    use super::___ToTriple;
    pub fn parse_Pattern<
        'input,
        ___TOKEN: ___ToTriple<'input, Error=tok::Error>,
        ___TOKENS: IntoIterator<Item=___TOKEN>,
    >(
        text: &'input str,
        ___tokens: ___TOKENS,
    ) -> Result<Pattern<TypeRef>, ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let ___tokens = ___tokens.into_iter();
        let mut ___tokens = ___tokens.map(|t| ___ToTriple::to_triple(t));
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match try!(___state0(text, None, &mut ___tokens, ___lookahead)) {
            (_, Some(___lookahead), _) => {
                Err(___ParseError::ExtraToken { token: ___lookahead })
            }
            (_, None, ___Nonterminal::______Pattern(___nt)) => {
                Ok(___nt)
            }
            _ => unreachable!(),
        }
    }

    #[allow(dead_code)]
    pub enum ___Nonterminal<'input> {
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        _28_22if_22_20_3cCond_3e_29(Condition),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        _28_3cAlternative_3e_20_22_2c_22_29(Alternative),
        _28_3cAlternative_3e_20_22_2c_22_29_2a(::std::vec::Vec<Alternative>),
        _28_3cAlternative_3e_20_22_2c_22_29_2b(::std::vec::Vec<Alternative>),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        _28_3cConversion_3e_20_22_2c_22_29_2b(::std::vec::Vec<Conversion>),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2b(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2b(::std::vec::Vec<Parameter>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        _28_3cId_3e_20_22_3a_3a_22_29_2b(::std::vec::Vec<InternedString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2b(::std::vec::Vec<NonterminalString>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cPattern_3e_20_22_2c_22_29_2b(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        _28_3cSymbol_3e_20_22_2c_22_29_2b(::std::vec::Vec<Symbol>),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeParameter>),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRef_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeRef>),
        _40L(usize),
        _40R(usize),
        Action(ActionKind),
        Action_3f(::std::option::Option<ActionKind>),
        Alternative(Alternative),
        Alternative_3f(::std::option::Option<Alternative>),
        Alternatives(Vec<Alternative>),
        Annotation(Annotation),
        Annotation_2a(::std::vec::Vec<Annotation>),
        Annotation_2b(::std::vec::Vec<Annotation>),
        AssociatedType(AssociatedType),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        AssociatedType_2b(::std::vec::Vec<AssociatedType>),
        Comma_3cAlternative_3e(Vec<Alternative>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        Cond(Condition),
        CondOp(ConditionOp),
        Conversion(Conversion),
        Conversion_3f(::std::option::Option<Conversion>),
        EnumToken(EnumToken),
        Escape(InternedString),
        ExprSymbol(ExprSymbol),
        ExternToken(GrammarItem),
        FieldPattern(FieldPattern<TypeRef>),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        Grammar(Grammar),
        GrammarItem(GrammarItem),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        GrammarItem_2b(::std::vec::Vec<GrammarItem>),
        GrammarParameter(Parameter),
        GrammarParameter_3f(::std::option::Option<Parameter>),
        GrammarParameters(Vec<Parameter>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        GrammarTypeParameters(Vec<TypeParameter>),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        Id(InternedString),
        Lifetime(InternedString),
        Lifetime_3f(::std::option::Option<InternedString>),
        MacroId(NonterminalString),
        Nonterminal(GrammarItem),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        NotMacroId(NonterminalString),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        Path(Path),
        Pattern(Pattern<TypeRef>),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        QuotedTerminal(TerminalString),
        RegexLiteral(InternedString),
        RepeatOp(RepeatOp),
        StringLiteral(InternedString),
        Symbol(Symbol),
        Symbol_2a(::std::vec::Vec<Symbol>),
        Symbol_2b(::std::vec::Vec<Symbol>),
        Symbol0(Symbol),
        Symbol1(Symbol),
        Symbol_3f(::std::option::Option<Symbol>),
        SymbolKind1(SymbolKind),
        Terminal(TerminalString),
        TypeParameter(TypeParameter),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        TypeRef(TypeRef),
        TypeRef_3f(::std::option::Option<TypeRef>),
        TypeRefOrLifetime(TypeRef),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        Use(GrammarItem),
        Use_2a(::std::vec::Vec<GrammarItem>),
        Use_2b(::std::vec::Vec<GrammarItem>),
        ______Grammar(Grammar),
        ______Pattern(Pattern<TypeRef>),
        ______TypeRef(TypeRef),
    }

    // State 0
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Pattern = (*) @L PatternKind @R [EOF]
    //   ___Pattern = (*) Pattern [EOF]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ".." -> Reduce(@L =  => ActionFn(131);)
    //   "::" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "_" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S1
    //   Pattern -> S2
    pub fn ___state0<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Pattern(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
    }

    // State 1
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (*) (<Id> "::")+ Id [EOF]
    //   Path = (*) (<Id> "::")+ Id ["("]
    //   Path = (*) (<Id> "::")+ Id ["{"]
    //   Path = (*) Id [EOF]
    //   Path = (*) Id ["("]
    //   Path = (*) Id ["{"]
    //   Path = (*) "::" (<Id> "::")+ Id [EOF]
    //   Path = (*) "::" (<Id> "::")+ Id ["("]
    //   Path = (*) "::" (<Id> "::")+ Id ["{"]
    //   Path = (*) "::" Id [EOF]
    //   Path = (*) "::" Id ["("]
    //   Path = (*) "::" Id ["{"]
    //   Pattern = @L (*) PatternKind @R [EOF]
    //   PatternKind = (*) Path [EOF]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ FieldPattern "}" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ ".." "}" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ "}" [EOF]
    //   PatternKind = (*) Path "{" FieldPattern "}" [EOF]
    //   PatternKind = (*) Path "{" ".." "}" [EOF]
    //   PatternKind = (*) Path "{" "}" [EOF]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = (*) ".." [EOF]
    //   PatternKind = (*) "<" TypeRef ">" [EOF]
    //   PatternKind = (*) "_" [EOF]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (*) (<Id> "::")+ Id ["("]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["{"]
    //   Path = (*) Id ["("]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["{"]
    //   Path = (*) "::" (<Id> "::")+ Id ["("]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["{"]
    //   Path = (*) "::" Id ["("]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["{"]
    //   Pattern = @L (*) PatternKind @R [")"]
    //   Pattern = @L (*) PatternKind @R [","]
    //   PatternKind = (*) Path [")"]
    //   PatternKind = (*) Path [","]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [")"]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ FieldPattern "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ FieldPattern "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ ".." "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ ".." "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ "}" [","]
    //   PatternKind = (*) Path "{" FieldPattern "}" [")"]
    //   PatternKind = (*) Path "{" FieldPattern "}" [","]
    //   PatternKind = (*) Path "{" ".." "}" [")"]
    //   PatternKind = (*) Path "{" ".." "}" [","]
    //   PatternKind = (*) Path "{" "}" [")"]
    //   PatternKind = (*) Path "{" "}" [","]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [")"]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) ".." [")"]
    //   PatternKind = (*) ".." [","]
    //   PatternKind = (*) "<" TypeRef ">" [")"]
    //   PatternKind = (*) "<" TypeRef ">" [","]
    //   PatternKind = (*) "_" [")"]
    //   PatternKind = (*) "_" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "Id" ["}"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Id = (*) "MacroId" ["}"]
    //   Path = (*) (<Id> "::")+ Id ["("]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["{"]
    //   Path = (*) (<Id> "::")+ Id ["}"]
    //   Path = (*) Id ["("]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["{"]
    //   Path = (*) Id ["}"]
    //   Path = (*) "::" (<Id> "::")+ Id ["("]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["{"]
    //   Path = (*) "::" (<Id> "::")+ Id ["}"]
    //   Path = (*) "::" Id ["("]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["{"]
    //   Path = (*) "::" Id ["}"]
    //   Pattern = @L (*) PatternKind @R [","]
    //   Pattern = @L (*) PatternKind @R ["}"]
    //   PatternKind = (*) Path [","]
    //   PatternKind = (*) Path ["}"]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ FieldPattern "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ FieldPattern "}" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ ".." "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ ".." "}" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")+ "}" ["}"]
    //   PatternKind = (*) Path "{" FieldPattern "}" [","]
    //   PatternKind = (*) Path "{" FieldPattern "}" ["}"]
    //   PatternKind = (*) Path "{" ".." "}" [","]
    //   PatternKind = (*) Path "{" ".." "}" ["}"]
    //   PatternKind = (*) Path "{" "}" [","]
    //   PatternKind = (*) Path "{" "}" ["}"]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = (*) ".." [","]
    //   PatternKind = (*) ".." ["}"]
    //   PatternKind = (*) "<" TypeRef ">" [","]
    //   PatternKind = (*) "<" TypeRef ">" ["}"]
    //   PatternKind = (*) "_" [","]
    //   PatternKind = (*) "_" ["}"]
    //
    //   "(" -> Shift(S7)
    //   ".." -> Shift(S8)
    //   "::" -> Shift(S9)
    //   "<" -> Shift(S10)
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //   "_" -> Shift(S13)
    //
    //   (<Id> "::")+ -> S3
    //   Id -> S4
    //   Path -> S5
    //   PatternKind -> S6
    pub fn ___state1<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::DotDot, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Underscore, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state13(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state5(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::PatternKind(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state6(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 2
    //   ___Pattern = Pattern (*) [EOF]
    //
    //   EOF -> Reduce(___Pattern = Pattern => ActionFn(2);)
    //
    pub fn ___state2<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action2(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::______Pattern(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 3
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (<Id> "::")+ (*) Id [EOF]
    //   Path = (<Id> "::")+ (*) Id ["("]
    //   Path = (<Id> "::")+ (*) Id ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   Path = (<Id> "::")+ (*) Id [">"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = (<Id> "::")+ (*) Id ["("]
    //   Path = (<Id> "::")+ (*) Id [")"]
    //   Path = (<Id> "::")+ (*) Id [","]
    //   Path = (<Id> "::")+ (*) Id ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (<Id> "::")+ (*) Id [")"]
    //   Path = (<Id> "::")+ (*) Id [","]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (<Id> "::")+ (*) Id [","]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   Path = (<Id> "::")+ (*) Id [">"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "Id" ["}"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Id = (*) "MacroId" ["}"]
    //   Path = (<Id> "::")+ (*) Id ["("]
    //   Path = (<Id> "::")+ (*) Id [","]
    //   Path = (<Id> "::")+ (*) Id ["{"]
    //   Path = (<Id> "::")+ (*) Id ["}"]
    //
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   Id -> S14
    pub fn ___state3<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 4
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [EOF]
    //   Path = Id (*) ["("]
    //   Path = Id (*) ["{"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) ["<"]
    //   Path = Id (*) [">"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) ["("]
    //   Path = Id (*) [")"]
    //   Path = Id (*) [","]
    //   Path = Id (*) ["{"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [")"]
    //   Path = Id (*) [","]
    //   Path = Id (*) ["<"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [","]
    //   Path = Id (*) ["<"]
    //   Path = Id (*) [">"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) ["("]
    //   Path = Id (*) [","]
    //   Path = Id (*) ["{"]
    //   Path = Id (*) ["}"]
    //
    //   EOF -> Reduce(Path = Id => ActionFn(251);)
    //   "(" -> Reduce(Path = Id => ActionFn(251);)
    //   ")" -> Reduce(Path = Id => ActionFn(251);)
    //   "," -> Reduce(Path = Id => ActionFn(251);)
    //   "::" -> Shift(S15)
    //   "<" -> Reduce(Path = Id => ActionFn(251);)
    //   ">" -> Reduce(Path = Id => ActionFn(251);)
    //   "{" -> Reduce(Path = Id => ActionFn(251);)
    //   "}" -> Reduce(Path = Id => ActionFn(251);)
    //
    pub fn ___state4<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state15(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action251(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 5
    //   PatternKind = Path (*) [EOF]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ FieldPattern "}" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ ".." "}" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ "}" [EOF]
    //   PatternKind = Path (*) "{" FieldPattern "}" [EOF]
    //   PatternKind = Path (*) "{" ".." "}" [EOF]
    //   PatternKind = Path (*) "{" "}" [EOF]
    //   PatternKind = Path (*) [")"]
    //   PatternKind = Path (*) [","]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [")"]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ FieldPattern "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ FieldPattern "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ ".." "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ ".." "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ "}" [","]
    //   PatternKind = Path (*) "{" FieldPattern "}" [")"]
    //   PatternKind = Path (*) "{" FieldPattern "}" [","]
    //   PatternKind = Path (*) "{" ".." "}" [")"]
    //   PatternKind = Path (*) "{" ".." "}" [","]
    //   PatternKind = Path (*) "{" "}" [")"]
    //   PatternKind = Path (*) "{" "}" [","]
    //   PatternKind = Path (*) [","]
    //   PatternKind = Path (*) ["}"]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ FieldPattern "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ FieldPattern "}" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ ".." "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ ".." "}" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")+ "}" ["}"]
    //   PatternKind = Path (*) "{" FieldPattern "}" [","]
    //   PatternKind = Path (*) "{" FieldPattern "}" ["}"]
    //   PatternKind = Path (*) "{" ".." "}" [","]
    //   PatternKind = Path (*) "{" ".." "}" ["}"]
    //   PatternKind = Path (*) "{" "}" [","]
    //   PatternKind = Path (*) "{" "}" ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path => ActionFn(69);)
    //   "(" -> Shift(S16)
    //   ")" -> Reduce(PatternKind = Path => ActionFn(69);)
    //   "," -> Reduce(PatternKind = Path => ActionFn(69);)
    //   "{" -> Shift(S17)
    //   "}" -> Reduce(PatternKind = Path => ActionFn(69);)
    //
    pub fn ___state5<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state16(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state17(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action69(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 6
    //   @R = (*) [EOF]
    //   Pattern = @L PatternKind (*) @R [EOF]
    //   @R = (*) [")"]
    //   @R = (*) [","]
    //   Pattern = @L PatternKind (*) @R [")"]
    //   Pattern = @L PatternKind (*) @R [","]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Pattern = @L PatternKind (*) @R [","]
    //   Pattern = @L PatternKind (*) @R ["}"]
    //
    //   EOF -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "}" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S18
    pub fn ___state6<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<PatternKind<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state18(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 7
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["_"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (*) [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ Pattern [")"]
    //   Comma<Pattern> = (*) Pattern [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [EOF]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["_"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (*) [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ Pattern [")"]
    //   Comma<Pattern> = (*) Pattern [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [","]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["_"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (*) [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ Pattern [")"]
    //   Comma<Pattern> = (*) Pattern [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [","]
    //   PatternKind = "(" (*) Comma<Pattern> ")" ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(Comma<Pattern> =  => ActionFn(380);)
    //   ".." -> Reduce(@L =  => ActionFn(131);)
    //   "::" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "_" -> Reduce(@L =  => ActionFn(131);)
    //
    //   (<Pattern> ",")+ -> S19
    //   @L -> S1
    //   Comma<Pattern> -> S20
    //   Pattern -> S21
    pub fn ___state7<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action380(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cPattern_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state19(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cPattern_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state20(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Pattern(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state21(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 8
    //   PatternKind = ".." (*) [EOF]
    //   PatternKind = ".." (*) [")"]
    //   PatternKind = ".." (*) [","]
    //   PatternKind = ".." (*) [","]
    //   PatternKind = ".." (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = ".." => ActionFn(66);)
    //   ")" -> Reduce(PatternKind = ".." => ActionFn(66);)
    //   "," -> Reduce(PatternKind = ".." => ActionFn(66);)
    //   "}" -> Reduce(PatternKind = ".." => ActionFn(66);)
    //
    pub fn ___state8<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action66(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 9
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::" (*) (<Id> "::")+ Id [EOF]
    //   Path = "::" (*) (<Id> "::")+ Id ["("]
    //   Path = "::" (*) (<Id> "::")+ Id ["{"]
    //   Path = "::" (*) Id [EOF]
    //   Path = "::" (*) Id ["("]
    //   Path = "::" (*) Id ["{"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [">"]
    //   Path = "::" (*) Id ["<"]
    //   Path = "::" (*) Id [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::" (*) (<Id> "::")+ Id ["("]
    //   Path = "::" (*) (<Id> "::")+ Id [")"]
    //   Path = "::" (*) (<Id> "::")+ Id [","]
    //   Path = "::" (*) (<Id> "::")+ Id ["{"]
    //   Path = "::" (*) Id ["("]
    //   Path = "::" (*) Id [")"]
    //   Path = "::" (*) Id [","]
    //   Path = "::" (*) Id ["{"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [")"]
    //   Path = "::" (*) (<Id> "::")+ Id [","]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) Id [")"]
    //   Path = "::" (*) Id [","]
    //   Path = "::" (*) Id ["<"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::" (*) (<Id> "::")+ Id [","]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [">"]
    //   Path = "::" (*) Id [","]
    //   Path = "::" (*) Id ["<"]
    //   Path = "::" (*) Id [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "Id" ["}"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Id = (*) "MacroId" ["}"]
    //   Path = "::" (*) (<Id> "::")+ Id ["("]
    //   Path = "::" (*) (<Id> "::")+ Id [","]
    //   Path = "::" (*) (<Id> "::")+ Id ["{"]
    //   Path = "::" (*) (<Id> "::")+ Id ["}"]
    //   Path = "::" (*) Id ["("]
    //   Path = "::" (*) Id [","]
    //   Path = "::" (*) Id ["{"]
    //   Path = "::" (*) Id ["}"]
    //
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   (<Id> "::")+ -> S22
    //   Id -> S23
    pub fn ___state9<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state22(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state23(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 10
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [EOF]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [")"]
    //   PatternKind = "<" (*) TypeRef ">" [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [","]
    //   PatternKind = "<" (*) TypeRef ">" ["}"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   "::" -> Shift(S9)
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   (<Id> "::")+ -> S3
    //   Id -> S4
    //   Path -> S24
    //   TypeRef -> S25
    pub fn ___state10<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state25(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 11
    //   Id = "Id" (*) [EOF]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [":"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["}"]
    //
    //   EOF -> Reduce(Id = "Id" => ActionFn(73);)
    //   "(" -> Reduce(Id = "Id" => ActionFn(73);)
    //   ")" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "," -> Reduce(Id = "Id" => ActionFn(73);)
    //   ":" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "::" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "<" -> Reduce(Id = "Id" => ActionFn(73);)
    //   ">" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "{" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "}" -> Reduce(Id = "Id" => ActionFn(73);)
    //
    pub fn ___state11<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action73(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 12
    //   Id = "MacroId" (*) [EOF]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [":"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["}"]
    //
    //   EOF -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "(" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   ")" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "," -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   ":" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "::" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "<" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   ">" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "{" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "}" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //
    pub fn ___state12<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 13
    //   PatternKind = "_" (*) [EOF]
    //   PatternKind = "_" (*) [")"]
    //   PatternKind = "_" (*) [","]
    //   PatternKind = "_" (*) [","]
    //   PatternKind = "_" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = "_" => ActionFn(65);)
    //   ")" -> Reduce(PatternKind = "_" => ActionFn(65);)
    //   "," -> Reduce(PatternKind = "_" => ActionFn(65);)
    //   "}" -> Reduce(PatternKind = "_" => ActionFn(65);)
    //
    pub fn ___state13<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action65(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 14
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [EOF]
    //   Path = (<Id> "::")+ Id (*) ["("]
    //   Path = (<Id> "::")+ Id (*) ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   Path = (<Id> "::")+ Id (*) [">"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) ["("]
    //   Path = (<Id> "::")+ Id (*) [")"]
    //   Path = (<Id> "::")+ Id (*) [","]
    //   Path = (<Id> "::")+ Id (*) ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [")"]
    //   Path = (<Id> "::")+ Id (*) [","]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [","]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   Path = (<Id> "::")+ Id (*) [">"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) ["("]
    //   Path = (<Id> "::")+ Id (*) [","]
    //   Path = (<Id> "::")+ Id (*) ["{"]
    //   Path = (<Id> "::")+ Id (*) ["}"]
    //
    //   EOF -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "(" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   ")" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "," -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "::" -> Shift(S29)
    //   "<" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   ">" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "{" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "}" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //
    pub fn ___state14<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state29(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action252(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 15
    //   (<Id> "::")+ = Id "::" (*) ["Id"]
    //   (<Id> "::")+ = Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")+ = Id, "::" => ActionFn(247);)
    //   "MacroId" -> Reduce((<Id> "::")+ = Id, "::" => ActionFn(247);)
    //
    pub fn ___state15<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action247(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 16
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["_"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (*) [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ Pattern [")"]
    //   Comma<Pattern> = (*) Pattern [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [EOF]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["_"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (*) [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ Pattern [")"]
    //   Comma<Pattern> = (*) Pattern [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [","]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) (<Pattern> ",")+ Pattern "," ["_"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["("]
    //   (<Pattern> ",")+ = (*) Pattern "," [")"]
    //   (<Pattern> ",")+ = (*) Pattern "," [".."]
    //   (<Pattern> ",")+ = (*) Pattern "," ["::"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["<"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (*) Pattern "," ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (*) [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ [")"]
    //   Comma<Pattern> = (*) (<Pattern> ",")+ Pattern [")"]
    //   Comma<Pattern> = (*) Pattern [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [","]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(Comma<Pattern> =  => ActionFn(380);)
    //   ".." -> Reduce(@L =  => ActionFn(131);)
    //   "::" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "_" -> Reduce(@L =  => ActionFn(131);)
    //
    //   (<Pattern> ",")+ -> S19
    //   @L -> S1
    //   Comma<Pattern> -> S30
    //   Pattern -> S21
    pub fn ___state16<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action380(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cPattern_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state19(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cPattern_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state30(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Pattern(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state21(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 17
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["}"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ FieldPattern "}" [EOF]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ ".." "}" [EOF]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ "}" [EOF]
    //   PatternKind = Path "{" (*) FieldPattern "}" [EOF]
    //   PatternKind = Path "{" (*) ".." "}" [EOF]
    //   PatternKind = Path "{" (*) "}" [EOF]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["}"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ FieldPattern "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ FieldPattern "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ ".." "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ ".." "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ "}" [","]
    //   PatternKind = Path "{" (*) FieldPattern "}" [")"]
    //   PatternKind = Path "{" (*) FieldPattern "}" [","]
    //   PatternKind = Path "{" (*) ".." "}" [")"]
    //   PatternKind = Path "{" (*) ".." "}" [","]
    //   PatternKind = Path "{" (*) "}" [")"]
    //   PatternKind = Path "{" (*) "}" [","]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (*) (<FieldPattern> ",")+ FieldPattern "," ["}"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (*) FieldPattern "," ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ FieldPattern "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ FieldPattern "}" ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ ".." "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ ".." "}" ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")+ "}" ["}"]
    //   PatternKind = Path "{" (*) FieldPattern "}" [","]
    //   PatternKind = Path "{" (*) FieldPattern "}" ["}"]
    //   PatternKind = Path "{" (*) ".." "}" [","]
    //   PatternKind = Path "{" (*) ".." "}" ["}"]
    //   PatternKind = Path "{" (*) "}" [","]
    //   PatternKind = Path "{" (*) "}" ["}"]
    //
    //   ".." -> Shift(S34)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "}" -> Shift(S35)
    //
    //   (<FieldPattern> ",")+ -> S31
    //   @L -> S32
    //   FieldPattern -> S33
    pub fn ___state17<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::DotDot, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state34(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state35(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state31(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state32(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::FieldPattern(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state33(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 18
    //   Pattern = @L PatternKind @R (*) [EOF]
    //   Pattern = @L PatternKind @R (*) [")"]
    //   Pattern = @L PatternKind @R (*) [","]
    //   Pattern = @L PatternKind @R (*) [","]
    //   Pattern = @L PatternKind @R (*) ["}"]
    //
    //   EOF -> Reduce(Pattern = @L, PatternKind, @R => ActionFn(61);)
    //   ")" -> Reduce(Pattern = @L, PatternKind, @R => ActionFn(61);)
    //   "," -> Reduce(Pattern = @L, PatternKind, @R => ActionFn(61);)
    //   "}" -> Reduce(Pattern = @L, PatternKind, @R => ActionFn(61);)
    //
    pub fn ___state18<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<PatternKind<TypeRef>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action61(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Pattern(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 19
    //   (<Pattern> ",")+ = (<Pattern> ",")+ (*) Pattern "," ["("]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ (*) Pattern "," [")"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ (*) Pattern "," [".."]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ (*) Pattern "," ["::"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ (*) Pattern "," ["<"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ (*) Pattern "," ["Id"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ (*) Pattern "," ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (<Pattern> ",")+ (*) [")"]
    //   Comma<Pattern> = (<Pattern> ",")+ (*) Pattern [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(Comma<Pattern> = (<Pattern> ",")+ => ActionFn(382);)
    //   ".." -> Reduce(@L =  => ActionFn(131);)
    //   "::" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "_" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S1
    //   Pattern -> S36
    pub fn ___state19<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action382(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cPattern_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Pattern(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 20
    //   PatternKind = "(" Comma<Pattern> (*) ")" [EOF]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [")"]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = "(" Comma<Pattern> (*) ")" ["}"]
    //
    //   ")" -> Shift(S37)
    //
    pub fn ___state20<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state37(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 21
    //   (<Pattern> ",")+ = Pattern (*) "," ["("]
    //   (<Pattern> ",")+ = Pattern (*) "," [")"]
    //   (<Pattern> ",")+ = Pattern (*) "," [".."]
    //   (<Pattern> ",")+ = Pattern (*) "," ["::"]
    //   (<Pattern> ",")+ = Pattern (*) "," ["<"]
    //   (<Pattern> ",")+ = Pattern (*) "," ["Id"]
    //   (<Pattern> ",")+ = Pattern (*) "," ["MacroId"]
    //   (<Pattern> ",")+ = Pattern (*) "," ["_"]
    //   Comma<Pattern> = Pattern (*) [")"]
    //
    //   ")" -> Reduce(Comma<Pattern> = Pattern => ActionFn(379);)
    //   "," -> Shift(S38)
    //
    pub fn ___state21<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state38(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action379(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cPattern_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 22
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::" (<Id> "::")+ (*) Id [EOF]
    //   Path = "::" (<Id> "::")+ (*) Id ["("]
    //   Path = "::" (<Id> "::")+ (*) Id ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [">"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::" (<Id> "::")+ (*) Id ["("]
    //   Path = "::" (<Id> "::")+ (*) Id [")"]
    //   Path = "::" (<Id> "::")+ (*) Id [","]
    //   Path = "::" (<Id> "::")+ (*) Id ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [")"]
    //   Path = "::" (<Id> "::")+ (*) Id [","]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::" (<Id> "::")+ (*) Id [","]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [">"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "Id" ["}"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Id = (*) "MacroId" ["}"]
    //   Path = "::" (<Id> "::")+ (*) Id ["("]
    //   Path = "::" (<Id> "::")+ (*) Id [","]
    //   Path = "::" (<Id> "::")+ (*) Id ["{"]
    //   Path = "::" (<Id> "::")+ (*) Id ["}"]
    //
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   Id -> S39
    pub fn ___state22<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state39(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 23
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [EOF]
    //   Path = "::" Id (*) ["("]
    //   Path = "::" Id (*) ["{"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) ["<"]
    //   Path = "::" Id (*) [">"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) ["("]
    //   Path = "::" Id (*) [")"]
    //   Path = "::" Id (*) [","]
    //   Path = "::" Id (*) ["{"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [")"]
    //   Path = "::" Id (*) [","]
    //   Path = "::" Id (*) ["<"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [","]
    //   Path = "::" Id (*) ["<"]
    //   Path = "::" Id (*) [">"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) ["("]
    //   Path = "::" Id (*) [","]
    //   Path = "::" Id (*) ["{"]
    //   Path = "::" Id (*) ["}"]
    //
    //   EOF -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "(" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   ")" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "," -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "::" -> Shift(S15)
    //   "<" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   ">" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "{" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "}" -> Reduce(Path = "::", Id => ActionFn(249);)
    //
    pub fn ___state23<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state15(text, ___lookbehind, ___tokens, ___sym1, ___sym2));
            }
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action249(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 24
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   ")" -> Reduce(TypeRef = Path => ActionFn(52);)
    //   "," -> Reduce(TypeRef = Path => ActionFn(52);)
    //   "<" -> Shift(S40)
    //   ">" -> Reduce(TypeRef = Path => ActionFn(52);)
    //
    pub fn ___state24<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state40(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action52(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 25
    //   PatternKind = "<" TypeRef (*) ">" [EOF]
    //   PatternKind = "<" TypeRef (*) ">" [")"]
    //   PatternKind = "<" TypeRef (*) ">" [","]
    //   PatternKind = "<" TypeRef (*) ">" [","]
    //   PatternKind = "<" TypeRef (*) ">" ["}"]
    //
    //   ">" -> Shift(S41)
    //
    pub fn ___state25<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state41(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 26
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S42
    //   Symbol -> S43
    //   Symbol0 -> S44
    //   Symbol1 -> S45
    pub fn ___state26<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state42(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 27
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = "&" (*) Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = "&" (*) TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = "&" (*) "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = "&" (*) Lifetime TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = "&" (*) TypeRef [")"]
    //   TypeRef = "&" (*) TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = "&" (*) "mut" TypeRef [")"]
    //   TypeRef = "&" (*) "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = "&" (*) Lifetime TypeRef [","]
    //   TypeRef = "&" (*) Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = "&" (*) TypeRef [","]
    //   TypeRef = "&" (*) TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = "&" (*) "mut" TypeRef [","]
    //   TypeRef = "&" (*) "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   "::" -> Shift(S9)
    //   "Id" -> Shift(S11)
    //   "Lifetime" -> Shift(S48)
    //   "MacroId" -> Shift(S12)
    //   "mut" -> Shift(S49)
    //
    //   (<Id> "::")+ -> S3
    //   Id -> S4
    //   Lifetime -> S46
    //   Path -> S24
    //   TypeRef -> S47
    pub fn ___state27<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state48(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 28
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   ")" -> Reduce(Comma<TypeRef> =  => ActionFn(394);)
    //   "::" -> Shift(S9)
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   (<Id> "::")+ -> S3
    //   (<TypeRef> ",")+ -> S50
    //   Comma<TypeRef> -> S51
    //   Id -> S4
    //   Path -> S24
    //   TypeRef -> S52
    pub fn ___state28<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action394(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state50(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cTypeRef_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state51(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state52(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 29
    //   (<Id> "::")+ = (<Id> "::")+ Id "::" (*) ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")+ = (<Id> "::")+, Id, "::" => ActionFn(248);)
    //   "MacroId" -> Reduce((<Id> "::")+ = (<Id> "::")+, Id, "::" => ActionFn(248);)
    //
    pub fn ___state29<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action248(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 30
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [EOF]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [")"]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" ["}"]
    //
    //   ")" -> Shift(S53)
    //
    pub fn ___state30<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state53(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 31
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) FieldPattern "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) ".." "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) "}" [EOF]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) FieldPattern "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) FieldPattern "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) ".." "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) ".." "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) "}" [","]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ (*) FieldPattern "," ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) FieldPattern "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) FieldPattern "}" ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) ".." "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) ".." "}" ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ (*) "}" ["}"]
    //
    //   ".." -> Shift(S55)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "}" -> Shift(S56)
    //
    //   @L -> S32
    //   FieldPattern -> S54
    pub fn ___state31<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::DotDot, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state55(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state56(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state32(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::FieldPattern(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state54(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 32
    //   FieldPattern = @L (*) Id @R ":" Pattern [","]
    //   FieldPattern = @L (*) Id @R ":" Pattern ["}"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   Id -> S57
    pub fn ___state32<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state57(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 33
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["MacroId"]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["}"]
    //   PatternKind = Path "{" FieldPattern (*) "}" [EOF]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["MacroId"]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["}"]
    //   PatternKind = Path "{" FieldPattern (*) "}" [")"]
    //   PatternKind = Path "{" FieldPattern (*) "}" [","]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["MacroId"]
    //   (<FieldPattern> ",")+ = FieldPattern (*) "," ["}"]
    //   PatternKind = Path "{" FieldPattern (*) "}" [","]
    //   PatternKind = Path "{" FieldPattern (*) "}" ["}"]
    //
    //   "," -> Shift(S58)
    //   "}" -> Shift(S59)
    //
    pub fn ___state33<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<FieldPattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state58(text, ___lookbehind, ___tokens, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state59(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 34
    //   PatternKind = Path "{" ".." (*) "}" [EOF]
    //   PatternKind = Path "{" ".." (*) "}" [")"]
    //   PatternKind = Path "{" ".." (*) "}" [","]
    //   PatternKind = Path "{" ".." (*) "}" [","]
    //   PatternKind = Path "{" ".." (*) "}" ["}"]
    //
    //   "}" -> Shift(S60)
    //
    pub fn ___state34<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state60(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 35
    //   PatternKind = Path "{" "}" (*) [EOF]
    //   PatternKind = Path "{" "}" (*) [")"]
    //   PatternKind = Path "{" "}" (*) [","]
    //   PatternKind = Path "{" "}" (*) [","]
    //   PatternKind = Path "{" "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", "}" => ActionFn(308);)
    //   ")" -> Reduce(PatternKind = Path, "{", "}" => ActionFn(308);)
    //   "," -> Reduce(PatternKind = Path, "{", "}" => ActionFn(308);)
    //   "}" -> Reduce(PatternKind = Path, "{", "}" => ActionFn(308);)
    //
    pub fn ___state35<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action308(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 36
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern (*) "," ["("]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern (*) "," [")"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern (*) "," [".."]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern (*) "," ["::"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern (*) "," ["<"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern (*) "," ["Id"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern (*) "," ["MacroId"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern (*) "," ["_"]
    //   Comma<Pattern> = (<Pattern> ",")+ Pattern (*) [")"]
    //
    //   ")" -> Reduce(Comma<Pattern> = (<Pattern> ",")+, Pattern => ActionFn(381);)
    //   "," -> Shift(S61)
    //
    pub fn ___state36<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
        ___sym1: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state61(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action381(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cPattern_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 37
    //   PatternKind = "(" Comma<Pattern> ")" (*) [EOF]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [")"]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = "(" Comma<Pattern> ")" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => ActionFn(68);)
    //   ")" -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => ActionFn(68);)
    //   "," -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => ActionFn(68);)
    //   "}" -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => ActionFn(68);)
    //
    pub fn ___state37<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Pattern<TypeRef>>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action68(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 38
    //   (<Pattern> ",")+ = Pattern "," (*) ["("]
    //   (<Pattern> ",")+ = Pattern "," (*) [")"]
    //   (<Pattern> ",")+ = Pattern "," (*) [".."]
    //   (<Pattern> ",")+ = Pattern "," (*) ["::"]
    //   (<Pattern> ",")+ = Pattern "," (*) ["<"]
    //   (<Pattern> ",")+ = Pattern "," (*) ["Id"]
    //   (<Pattern> ",")+ = Pattern "," (*) ["MacroId"]
    //   (<Pattern> ",")+ = Pattern "," (*) ["_"]
    //
    //   "(" -> Reduce((<Pattern> ",")+ = Pattern, "," => ActionFn(257);)
    //   ")" -> Reduce((<Pattern> ",")+ = Pattern, "," => ActionFn(257);)
    //   ".." -> Reduce((<Pattern> ",")+ = Pattern, "," => ActionFn(257);)
    //   "::" -> Reduce((<Pattern> ",")+ = Pattern, "," => ActionFn(257);)
    //   "<" -> Reduce((<Pattern> ",")+ = Pattern, "," => ActionFn(257);)
    //   "Id" -> Reduce((<Pattern> ",")+ = Pattern, "," => ActionFn(257);)
    //   "MacroId" -> Reduce((<Pattern> ",")+ = Pattern, "," => ActionFn(257);)
    //   "_" -> Reduce((<Pattern> ",")+ = Pattern, "," => ActionFn(257);)
    //
    pub fn ___state38<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Pattern<TypeRef>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action257(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 39
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [EOF]
    //   Path = "::" (<Id> "::")+ Id (*) ["("]
    //   Path = "::" (<Id> "::")+ Id (*) ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   Path = "::" (<Id> "::")+ Id (*) [">"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) ["("]
    //   Path = "::" (<Id> "::")+ Id (*) [")"]
    //   Path = "::" (<Id> "::")+ Id (*) [","]
    //   Path = "::" (<Id> "::")+ Id (*) ["{"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [")"]
    //   Path = "::" (<Id> "::")+ Id (*) [","]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [","]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   Path = "::" (<Id> "::")+ Id (*) [">"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) ["("]
    //   Path = "::" (<Id> "::")+ Id (*) [","]
    //   Path = "::" (<Id> "::")+ Id (*) ["{"]
    //   Path = "::" (<Id> "::")+ Id (*) ["}"]
    //
    //   EOF -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "(" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   ")" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "," -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "::" -> Shift(S29)
    //   "<" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   ">" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "{" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "}" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //
    pub fn ___state39<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state29(text, ___lookbehind, ___tokens, ___sym1, ___sym2, ___sym3));
            }
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action250(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 40
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   "::" -> Shift(S9)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> =  => ActionFn(398);)
    //   "Id" -> Shift(S11)
    //   "Lifetime" -> Shift(S48)
    //   "MacroId" -> Shift(S12)
    //
    //   (<Id> "::")+ -> S3
    //   (<TypeRefOrLifetime> ",")+ -> S62
    //   Comma<TypeRefOrLifetime> -> S63
    //   Id -> S4
    //   Lifetime -> S64
    //   Path -> S24
    //   TypeRef -> S65
    //   TypeRefOrLifetime -> S66
    pub fn ___state40<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state48(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action398(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state62(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state63(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state66(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 41
    //   PatternKind = "<" TypeRef ">" (*) [EOF]
    //   PatternKind = "<" TypeRef ">" (*) [")"]
    //   PatternKind = "<" TypeRef ">" (*) [","]
    //   PatternKind = "<" TypeRef ">" (*) [","]
    //   PatternKind = "<" TypeRef ">" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = "<", TypeRef, ">" => ActionFn(67);)
    //   ")" -> Reduce(PatternKind = "<", TypeRef, ">" => ActionFn(67);)
    //   "," -> Reduce(PatternKind = "<", TypeRef, ">" => ActionFn(67);)
    //   "}" -> Reduce(PatternKind = "<", TypeRef, ">" => ActionFn(67);)
    //
    pub fn ___state41<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<TypeRef>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action67(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 42
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["#"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["#"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral [")"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" [")"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [","]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [","]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S73)
    //   "<" -> Shift(S74)
    //   "@L" -> Shift(S75)
    //   "@R" -> Shift(S76)
    //   "Escape" -> Shift(S77)
    //   "Id" -> Shift(S78)
    //   "MacroId" -> Shift(S79)
    //   "RegexLiteral" -> Shift(S80)
    //   "StringLiteral" -> Shift(S81)
    //
    //   Escape -> S67
    //   MacroId -> S68
    //   QuotedTerminal -> S69
    //   RegexLiteral -> S70
    //   StringLiteral -> S71
    //   SymbolKind1 -> S72
    pub fn ___state42<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state73(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state74(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state75(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state76(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state77(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state78(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state79(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state80(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state67(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state68(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state70(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state71(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state72(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 43
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //
    //   "#" -> Shift(S82)
    //
    pub fn ___state43<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 44
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "#" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "(" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   ")" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "*" -> Shift(S84)
    //   "+" -> Shift(S85)
    //   "," -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "<" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   ">" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "?" -> Shift(S86)
    //   "@L" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "@R" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "Escape" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "Id" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "RegexLiteral" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //
    //   RepeatOp -> S83
    pub fn ___state44<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state84(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state85(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state86(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action34(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 45
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "(" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   ")" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "*" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "+" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "," -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "<" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   ">" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "?" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //
    pub fn ___state45<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action35(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 46
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = "&" Lifetime (*) TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = "&" Lifetime (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime (*) TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [")"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = "&" Lifetime (*) TypeRef [","]
    //   TypeRef = "&" Lifetime (*) TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   "::" -> Shift(S9)
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //   "mut" -> Shift(S88)
    //
    //   (<Id> "::")+ -> S3
    //   Id -> S4
    //   Path -> S24
    //   TypeRef -> S87
    pub fn ___state46<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state88(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 47
    //   TypeRef = "&" TypeRef (*) [">"]
    //   TypeRef = "&" TypeRef (*) [")"]
    //   TypeRef = "&" TypeRef (*) [","]
    //   TypeRef = "&" TypeRef (*) [","]
    //   TypeRef = "&" TypeRef (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   "," -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   ">" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //
    pub fn ___state47<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action374(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 48
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //
    //   "#" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "&" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "(" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "," -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "::" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   ">" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //
    pub fn ___state48<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action76(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 49
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = "&" "mut" (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = "&" "mut" (*) TypeRef [")"]
    //   TypeRef = "&" "mut" (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = "&" "mut" (*) TypeRef [","]
    //   TypeRef = "&" "mut" (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   "::" -> Shift(S9)
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   (<Id> "::")+ -> S3
    //   Id -> S4
    //   Path -> S24
    //   TypeRef -> S89
    pub fn ___state49<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state89(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 50
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ (*) [")"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")+ => ActionFn(396);)
    //   "::" -> Shift(S9)
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   (<Id> "::")+ -> S3
    //   Id -> S4
    //   Path -> S24
    //   TypeRef -> S90
    pub fn ___state50<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action396(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state90(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 51
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S91)
    //
    pub fn ___state51<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state91(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 52
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["("]
    //   (<TypeRef> ",")+ = TypeRef (*) "," [")"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["MacroId"]
    //   Comma<TypeRef> = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = TypeRef => ActionFn(393);)
    //   "," -> Shift(S92)
    //
    pub fn ___state52<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state92(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action393(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 53
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [EOF]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [")"]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => ActionFn(62);)
    //   ")" -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => ActionFn(62);)
    //   "," -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => ActionFn(62);)
    //   "}" -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => ActionFn(62);)
    //
    pub fn ___state53<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Pattern<TypeRef>>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action62(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 54
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern (*) "}" [EOF]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern (*) "}" [","]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["MacroId"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern (*) "," ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern (*) "}" ["}"]
    //
    //   "," -> Shift(S93)
    //   "}" -> Shift(S94)
    //
    pub fn ___state54<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<FieldPattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state93(text, ___lookbehind, ___tokens, ___sym2, ___sym3, ___sym4));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state94(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 55
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." (*) "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." (*) "}" ["}"]
    //
    //   "}" -> Shift(S95)
    //
    pub fn ___state55<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state95(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 56
    //   PatternKind = Path "{" (<FieldPattern> ",")+ "}" (*) [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, "}" => ActionFn(310);)
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, "}" => ActionFn(310);)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, "}" => ActionFn(310);)
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, "}" => ActionFn(310);)
    //
    pub fn ___state56<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action310(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 57
    //   @R = (*) [":"]
    //   FieldPattern = @L Id (*) @R ":" Pattern [","]
    //   FieldPattern = @L Id (*) @R ":" Pattern ["}"]
    //
    //   ":" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S96
    pub fn ___state57<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state96(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 58
    //   (<FieldPattern> ",")+ = FieldPattern "," (*) [".."]
    //   (<FieldPattern> ",")+ = FieldPattern "," (*) ["Id"]
    //   (<FieldPattern> ",")+ = FieldPattern "," (*) ["MacroId"]
    //   (<FieldPattern> ",")+ = FieldPattern "," (*) ["}"]
    //
    //   ".." -> Reduce((<FieldPattern> ",")+ = FieldPattern, "," => ActionFn(237);)
    //   "Id" -> Reduce((<FieldPattern> ",")+ = FieldPattern, "," => ActionFn(237);)
    //   "MacroId" -> Reduce((<FieldPattern> ",")+ = FieldPattern, "," => ActionFn(237);)
    //   "}" -> Reduce((<FieldPattern> ",")+ = FieldPattern, "," => ActionFn(237);)
    //
    pub fn ___state58<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<FieldPattern<TypeRef>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action237(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 59
    //   PatternKind = Path "{" FieldPattern "}" (*) [EOF]
    //   PatternKind = Path "{" FieldPattern "}" (*) [")"]
    //   PatternKind = Path "{" FieldPattern "}" (*) [","]
    //   PatternKind = Path "{" FieldPattern "}" (*) [","]
    //   PatternKind = Path "{" FieldPattern "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", FieldPattern, "}" => ActionFn(307);)
    //   ")" -> Reduce(PatternKind = Path, "{", FieldPattern, "}" => ActionFn(307);)
    //   "," -> Reduce(PatternKind = Path, "{", FieldPattern, "}" => ActionFn(307);)
    //   "}" -> Reduce(PatternKind = Path, "{", FieldPattern, "}" => ActionFn(307);)
    //
    pub fn ___state59<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<FieldPattern<TypeRef>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action307(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 60
    //   PatternKind = Path "{" ".." "}" (*) [EOF]
    //   PatternKind = Path "{" ".." "}" (*) [")"]
    //   PatternKind = Path "{" ".." "}" (*) [","]
    //   PatternKind = Path "{" ".." "}" (*) [","]
    //   PatternKind = Path "{" ".." "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", "..", "}" => ActionFn(241);)
    //   ")" -> Reduce(PatternKind = Path, "{", "..", "}" => ActionFn(241);)
    //   "," -> Reduce(PatternKind = Path, "{", "..", "}" => ActionFn(241);)
    //   "}" -> Reduce(PatternKind = Path, "{", "..", "}" => ActionFn(241);)
    //
    pub fn ___state60<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action241(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 61
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern "," (*) ["("]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern "," (*) [")"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern "," (*) [".."]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern "," (*) ["::"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern "," (*) ["<"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern "," (*) ["Id"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern "," (*) ["MacroId"]
    //   (<Pattern> ",")+ = (<Pattern> ",")+ Pattern "," (*) ["_"]
    //
    //   "(" -> Reduce((<Pattern> ",")+ = (<Pattern> ",")+, Pattern, "," => ActionFn(258);)
    //   ")" -> Reduce((<Pattern> ",")+ = (<Pattern> ",")+, Pattern, "," => ActionFn(258);)
    //   ".." -> Reduce((<Pattern> ",")+ = (<Pattern> ",")+, Pattern, "," => ActionFn(258);)
    //   "::" -> Reduce((<Pattern> ",")+ = (<Pattern> ",")+, Pattern, "," => ActionFn(258);)
    //   "<" -> Reduce((<Pattern> ",")+ = (<Pattern> ",")+, Pattern, "," => ActionFn(258);)
    //   "Id" -> Reduce((<Pattern> ",")+ = (<Pattern> ",")+, Pattern, "," => ActionFn(258);)
    //   "MacroId" -> Reduce((<Pattern> ",")+ = (<Pattern> ",")+, Pattern, "," => ActionFn(258);)
    //   "_" -> Reduce((<Pattern> ",")+ = (<Pattern> ",")+, Pattern, "," => ActionFn(258);)
    //
    pub fn ___state61<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
        ___sym1: &mut Option<Pattern<TypeRef>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action258(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 62
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ (*) [">"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   "::" -> Shift(S9)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ => ActionFn(400);)
    //   "Id" -> Shift(S11)
    //   "Lifetime" -> Shift(S48)
    //   "MacroId" -> Shift(S12)
    //
    //   (<Id> "::")+ -> S3
    //   Id -> S4
    //   Lifetime -> S64
    //   Path -> S24
    //   TypeRef -> S65
    //   TypeRefOrLifetime -> S97
    pub fn ___state62<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state48(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action400(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state97(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 63
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S98)
    //
    pub fn ___state63<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state98(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 64
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => ActionFn(54);)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => ActionFn(54);)
    //
    pub fn ___state64<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action54(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 65
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => ActionFn(53);)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => ActionFn(53);)
    //
    pub fn ___state65<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action53(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 66
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S99)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = TypeRefOrLifetime => ActionFn(397);)
    //
    pub fn ___state66<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state99(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action397(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 67
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "(" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   ")" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "*" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "+" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "," -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "<" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   ">" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "?" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "@L" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "@R" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "Id" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //
    pub fn ___state67<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 68
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Shift(S100)
    //
    pub fn ___state68<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state100(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 69
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //
    pub fn ___state69<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action42(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 70
    //   QuotedTerminal = RegexLiteral (*) ["#"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) [")"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [","]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //
    //   "#" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "(" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   ")" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "*" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "+" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "," -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "<" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   ">" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "?" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "@L" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "@R" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "Escape" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "Id" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "MacroId" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "StringLiteral" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //
    pub fn ___state70<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action80(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 71
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "," -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //
    pub fn ___state71<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action79(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 72
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "*" -> Reduce(@R =  => ActionFn(130);)
    //   "+" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "?" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S101
    pub fn ___state72<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state101(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 73
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(ExprSymbol =  => ActionFn(383);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S42
    //   ExprSymbol -> S102
    //   Symbol -> S103
    //   Symbol+ -> S104
    //   Symbol0 -> S44
    //   Symbol1 -> S45
    pub fn ___state73<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action383(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state42(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::ExprSymbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state102(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state103(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state104(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 74
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S105
    //   Symbol0 -> S106
    //   Symbol1 -> S45
    pub fn ___state74<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state105(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state106(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 75
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "(" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   ")" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "*" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "+" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "," -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "<" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   ">" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "?" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //
    pub fn ___state75<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action46(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 76
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "(" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   ")" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "*" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "+" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "," -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "<" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   ">" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "?" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //
    pub fn ___state76<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action47(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 77
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //
    //   "#" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "(" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   ")" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "*" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "+" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "," -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "<" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   ">" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "?" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "@L" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "@R" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "Escape" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "Id" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "MacroId" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "RegexLiteral" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //
    pub fn ___state77<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Escape(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 78
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "(" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ")" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "*" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "+" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "," -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "<" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ">" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "?" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //
    pub fn ___state78<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 79
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => ActionFn(71);)
    //
    pub fn ___state79<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action71(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 80
    //   RegexLiteral = "RegexLiteral" (*) ["#"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) [")"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [","]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "(" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   ")" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "*" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "+" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "," -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "<" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   ">" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "?" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "@L" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "@R" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "Escape" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "Id" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "MacroId" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "RegexLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "StringLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //
    pub fn ___state80<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action82(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RegexLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 81
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "RegexLiteral" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //
    pub fn ___state81<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action81(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::StringLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 82
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //
    pub fn ___state82<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action49(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 83
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "*" -> Reduce(@R =  => ActionFn(130);)
    //   "+" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "?" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S107
    pub fn ___state83<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state107(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 84
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "(" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   ")" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "*" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "+" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "," -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "<" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   ">" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "?" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "@L" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "@R" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "Escape" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "Id" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "MacroId" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //
    pub fn ___state84<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action38(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 85
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "(" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   ")" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "*" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "+" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "," -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "<" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   ">" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "?" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "@L" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "@R" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "Escape" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "Id" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "MacroId" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //
    pub fn ___state85<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action37(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 86
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "(" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   ")" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "*" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "+" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "," -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "<" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   ">" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "?" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "@L" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "@R" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "Escape" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "Id" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "MacroId" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //
    pub fn ___state86<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action39(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 87
    //   TypeRef = "&" Lifetime TypeRef (*) [">"]
    //   TypeRef = "&" Lifetime TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime TypeRef (*) [","]
    //   TypeRef = "&" Lifetime TypeRef (*) [","]
    //   TypeRef = "&" Lifetime TypeRef (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   "," -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   ">" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //
    pub fn ___state87<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action373(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 88
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [","]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S26)
    //   "&" -> Shift(S27)
    //   "(" -> Shift(S28)
    //   "::" -> Shift(S9)
    //   "Id" -> Shift(S11)
    //   "MacroId" -> Shift(S12)
    //
    //   (<Id> "::")+ -> S3
    //   Id -> S4
    //   Path -> S24
    //   TypeRef -> S108
    pub fn ___state88<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state108(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 89
    //   TypeRef = "&" "mut" TypeRef (*) [">"]
    //   TypeRef = "&" "mut" TypeRef (*) [")"]
    //   TypeRef = "&" "mut" TypeRef (*) [","]
    //   TypeRef = "&" "mut" TypeRef (*) [","]
    //   TypeRef = "&" "mut" TypeRef (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   "," -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   ">" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //
    pub fn ___state89<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action372(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 90
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ TypeRef (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")+, TypeRef => ActionFn(395);)
    //   "," -> Shift(S109)
    //
    pub fn ___state90<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state109(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action395(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 91
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //
    pub fn ___state91<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action48(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 92
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["("]
    //   (<TypeRef> ",")+ = TypeRef "," (*) [")"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "&" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "(" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   ")" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "::" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "Id" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "MacroId" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //
    pub fn ___state92<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action269(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 93
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern "," (*) [".."]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern "," (*) ["Id"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern "," (*) ["MacroId"]
    //   (<FieldPattern> ",")+ = (<FieldPattern> ",")+ FieldPattern "," (*) ["}"]
    //
    //   ".." -> Reduce((<FieldPattern> ",")+ = (<FieldPattern> ",")+, FieldPattern, "," => ActionFn(238);)
    //   "Id" -> Reduce((<FieldPattern> ",")+ = (<FieldPattern> ",")+, FieldPattern, "," => ActionFn(238);)
    //   "MacroId" -> Reduce((<FieldPattern> ",")+ = (<FieldPattern> ",")+, FieldPattern, "," => ActionFn(238);)
    //   "}" -> Reduce((<FieldPattern> ",")+ = (<FieldPattern> ",")+, FieldPattern, "," => ActionFn(238);)
    //
    pub fn ___state93<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym1: &mut Option<FieldPattern<TypeRef>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action238(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 94
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern "}" (*) [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ FieldPattern "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, FieldPattern, "}" => ActionFn(309);)
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, FieldPattern, "}" => ActionFn(309);)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, FieldPattern, "}" => ActionFn(309);)
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, FieldPattern, "}" => ActionFn(309);)
    //
    pub fn ___state94<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<FieldPattern<TypeRef>>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action309(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 95
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." "}" (*) [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")+ ".." "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, "..", "}" => ActionFn(242);)
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, "..", "}" => ActionFn(242);)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, "..", "}" => ActionFn(242);)
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")+, "..", "}" => ActionFn(242);)
    //
    pub fn ___state95<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action242(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 96
    //   FieldPattern = @L Id @R (*) ":" Pattern [","]
    //   FieldPattern = @L Id @R (*) ":" Pattern ["}"]
    //
    //   ":" -> Shift(S110)
    //
    pub fn ___state96<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state110(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 97
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S111)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime => ActionFn(399);)
    //
    pub fn ___state97<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state111(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action399(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 98
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //
    pub fn ___state98<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action51(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 99
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //
    pub fn ___state99<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action273(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 100
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   ">" -> Reduce(Comma<Symbol> =  => ActionFn(386);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   (<Symbol> ",")+ -> S112
    //   @L -> S42
    //   Comma<Symbol> -> S113
    //   Symbol -> S114
    //   Symbol0 -> S44
    //   Symbol1 -> S45
    pub fn ___state100<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action386(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state112(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state42(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cSymbol_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state113(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state114(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 101
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "RegexLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //
    pub fn ___state101<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action40(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 102
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //
    //   ")" -> Shift(S115)
    //
    pub fn ___state102<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state115(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 103
    //   Symbol+ = Symbol (*) ["("]
    //   Symbol+ = Symbol (*) [")"]
    //   Symbol+ = Symbol (*) ["<"]
    //   Symbol+ = Symbol (*) ["@L"]
    //   Symbol+ = Symbol (*) ["@R"]
    //   Symbol+ = Symbol (*) ["Escape"]
    //   Symbol+ = Symbol (*) ["Id"]
    //   Symbol+ = Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   ")" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "<" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "@L" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "@R" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "Escape" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "Id" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "MacroId" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "RegexLiteral" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //
    pub fn ___state103<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action111(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 104
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol+ (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [")"]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["RegexLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(ExprSymbol = Symbol+ => ActionFn(384);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S42
    //   Symbol -> S116
    //   Symbol0 -> S44
    //   Symbol1 -> S45
    pub fn ___state104<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action384(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state42(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state116(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 105
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S73)
    //   "@L" -> Shift(S75)
    //   "@R" -> Shift(S76)
    //   "Escape" -> Shift(S77)
    //   "Id" -> Shift(S118)
    //   "MacroId" -> Shift(S119)
    //   "RegexLiteral" -> Shift(S80)
    //   "StringLiteral" -> Shift(S81)
    //
    //   Escape -> S67
    //   Id -> S117
    //   MacroId -> S68
    //   QuotedTerminal -> S69
    //   RegexLiteral -> S70
    //   StringLiteral -> S71
    //   SymbolKind1 -> S72
    pub fn ___state105<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state73(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state75(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state76(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state77(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state118(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state119(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state80(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state67(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state68(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state70(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state71(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state72(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 106
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S84)
    //   "+" -> Shift(S85)
    //   ">" -> Shift(S120)
    //   "?" -> Shift(S86)
    //
    //   RepeatOp -> S83
    pub fn ___state106<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state84(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state85(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state120(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state86(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 107
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //
    pub fn ___state107<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action36(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 108
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [">"]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [","]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [","]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   "," -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   ">" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //
    pub fn ___state108<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action371(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 109
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "&" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "(" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   ")" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "::" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "Id" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "MacroId" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //
    pub fn ___state109<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action270(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 110
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   FieldPattern = @L Id @R ":" (*) Pattern [","]
    //   FieldPattern = @L Id @R ":" (*) Pattern ["}"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   Pattern = (*) @L PatternKind @R ["}"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ".." -> Reduce(@L =  => ActionFn(131);)
    //   "::" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "_" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S1
    //   Pattern -> S121
    pub fn ___state110<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Pattern(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state121(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 111
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //
    pub fn ___state111<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action274(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 112
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")+ (*) [">"]
    //   Comma<Symbol> = (<Symbol> ",")+ (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")+ => ActionFn(388);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S42
    //   Symbol -> S122
    //   Symbol0 -> S44
    //   Symbol1 -> S45
    pub fn ___state112<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action388(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state42(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state122(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 113
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //
    //   ">" -> Shift(S123)
    //
    pub fn ___state113<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 114
    //   (<Symbol> ",")+ = Symbol (*) "," ["("]
    //   (<Symbol> ",")+ = Symbol (*) "," ["<"]
    //   (<Symbol> ",")+ = Symbol (*) "," [">"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["@L"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["@R"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["Id"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["StringLiteral"]
    //   Comma<Symbol> = Symbol (*) [">"]
    //
    //   "," -> Shift(S124)
    //   ">" -> Reduce(Comma<Symbol> = Symbol => ActionFn(385);)
    //
    pub fn ___state114<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action385(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 115
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //
    pub fn ___state115<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action45(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 116
    //   Symbol+ = Symbol+ Symbol (*) ["("]
    //   Symbol+ = Symbol+ Symbol (*) [")"]
    //   Symbol+ = Symbol+ Symbol (*) ["<"]
    //   Symbol+ = Symbol+ Symbol (*) ["@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["Escape"]
    //   Symbol+ = Symbol+ Symbol (*) ["Id"]
    //   Symbol+ = Symbol+ Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol+ Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   ")" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "<" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "@L" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "@R" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "Escape" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "Id" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "MacroId" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "RegexLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //
    pub fn ___state116<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action112(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 117
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //
    //   ":" -> Shift(S125)
    //
    pub fn ___state117<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state125(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 118
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "+" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ":" -> Reduce(Id = "Id" => ActionFn(73);)
    //   ">" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "?" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //
    pub fn ___state118<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action73(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 119
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "<" -> Reduce(MacroId = "MacroId" => ActionFn(71);)
    //
    pub fn ___state119<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action71(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 120
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S126
    pub fn ___state120<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state126(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 121
    //   FieldPattern = @L Id @R ":" Pattern (*) [","]
    //   FieldPattern = @L Id @R ":" Pattern (*) ["}"]
    //
    //   "," -> Reduce(FieldPattern = @L, Id, @R, ":", Pattern => ActionFn(70);)
    //   "}" -> Reduce(FieldPattern = @L, Id, @R, ":", Pattern => ActionFn(70);)
    //
    pub fn ___state121<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action70(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::FieldPattern(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 122
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")+ Symbol (*) [">"]
    //
    //   "," -> Shift(S127)
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")+, Symbol => ActionFn(387);)
    //
    pub fn ___state122<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state127(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action387(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 123
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //
    pub fn ___state123<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action41(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 124
    //   (<Symbol> ",")+ = Symbol "," (*) ["("]
    //   (<Symbol> ",")+ = Symbol "," (*) ["<"]
    //   (<Symbol> ",")+ = Symbol "," (*) [">"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["@L"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["@R"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["Id"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "<" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   ">" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "@L" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "@R" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "Escape" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "Id" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "MacroId" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "StringLiteral" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //
    pub fn ___state124<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action261(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 125
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S128
    //   Symbol0 -> S129
    //   Symbol1 -> S45
    pub fn ___state125<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state128(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state129(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 126
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //
    pub fn ___state126<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action33(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 127
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "<" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   ">" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "@L" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "@R" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "Escape" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "Id" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "MacroId" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "StringLiteral" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //
    pub fn ___state127<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action262(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 128
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S73)
    //   "@L" -> Shift(S75)
    //   "@R" -> Shift(S76)
    //   "Escape" -> Shift(S77)
    //   "Id" -> Shift(S78)
    //   "MacroId" -> Shift(S79)
    //   "RegexLiteral" -> Shift(S80)
    //   "StringLiteral" -> Shift(S81)
    //
    //   Escape -> S67
    //   MacroId -> S68
    //   QuotedTerminal -> S69
    //   RegexLiteral -> S70
    //   StringLiteral -> S71
    //   SymbolKind1 -> S72
    pub fn ___state128<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state73(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state75(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state76(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state77(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state78(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state79(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state80(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state67(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state68(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state70(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state71(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state72(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 129
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S84)
    //   "+" -> Shift(S85)
    //   ">" -> Shift(S130)
    //   "?" -> Shift(S86)
    //
    //   RepeatOp -> S83
    pub fn ___state129<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state84(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state85(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state130(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state86(text, ___lookbehind, ___tokens, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 130
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S131
    pub fn ___state130<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state131(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 131
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //
    pub fn ___state131<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action32(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
pub use self::___parse___Pattern::parse_Pattern;

mod ___parse___TypeRef {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as ___lalrpop_util;
    use self::___lalrpop_util::ParseError as ___ParseError;
    use super::___ToTriple;
    pub fn parse_TypeRef<
        'input,
        ___TOKEN: ___ToTriple<'input, Error=tok::Error>,
        ___TOKENS: IntoIterator<Item=___TOKEN>,
    >(
        text: &'input str,
        ___tokens: ___TOKENS,
    ) -> Result<TypeRef, ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let ___tokens = ___tokens.into_iter();
        let mut ___tokens = ___tokens.map(|t| ___ToTriple::to_triple(t));
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match try!(___state0(text, None, &mut ___tokens, ___lookahead)) {
            (_, Some(___lookahead), _) => {
                Err(___ParseError::ExtraToken { token: ___lookahead })
            }
            (_, None, ___Nonterminal::______TypeRef(___nt)) => {
                Ok(___nt)
            }
            _ => unreachable!(),
        }
    }

    #[allow(dead_code)]
    pub enum ___Nonterminal<'input> {
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        _28_22if_22_20_3cCond_3e_29(Condition),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        _28_3cAlternative_3e_20_22_2c_22_29(Alternative),
        _28_3cAlternative_3e_20_22_2c_22_29_2a(::std::vec::Vec<Alternative>),
        _28_3cAlternative_3e_20_22_2c_22_29_2b(::std::vec::Vec<Alternative>),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        _28_3cConversion_3e_20_22_2c_22_29_2b(::std::vec::Vec<Conversion>),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2b(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2b(::std::vec::Vec<Parameter>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        _28_3cId_3e_20_22_3a_3a_22_29_2b(::std::vec::Vec<InternedString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2b(::std::vec::Vec<NonterminalString>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cPattern_3e_20_22_2c_22_29_2b(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        _28_3cSymbol_3e_20_22_2c_22_29_2b(::std::vec::Vec<Symbol>),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeParameter>),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRef_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(::std::vec::Vec<TypeRef>),
        _40L(usize),
        _40R(usize),
        Action(ActionKind),
        Action_3f(::std::option::Option<ActionKind>),
        Alternative(Alternative),
        Alternative_3f(::std::option::Option<Alternative>),
        Alternatives(Vec<Alternative>),
        Annotation(Annotation),
        Annotation_2a(::std::vec::Vec<Annotation>),
        Annotation_2b(::std::vec::Vec<Annotation>),
        AssociatedType(AssociatedType),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        AssociatedType_2b(::std::vec::Vec<AssociatedType>),
        Comma_3cAlternative_3e(Vec<Alternative>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        Cond(Condition),
        CondOp(ConditionOp),
        Conversion(Conversion),
        Conversion_3f(::std::option::Option<Conversion>),
        EnumToken(EnumToken),
        Escape(InternedString),
        ExprSymbol(ExprSymbol),
        ExternToken(GrammarItem),
        FieldPattern(FieldPattern<TypeRef>),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        Grammar(Grammar),
        GrammarItem(GrammarItem),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        GrammarItem_2b(::std::vec::Vec<GrammarItem>),
        GrammarParameter(Parameter),
        GrammarParameter_3f(::std::option::Option<Parameter>),
        GrammarParameters(Vec<Parameter>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        GrammarTypeParameters(Vec<TypeParameter>),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        Id(InternedString),
        Lifetime(InternedString),
        Lifetime_3f(::std::option::Option<InternedString>),
        MacroId(NonterminalString),
        Nonterminal(GrammarItem),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        NotMacroId(NonterminalString),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        Path(Path),
        Pattern(Pattern<TypeRef>),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        QuotedTerminal(TerminalString),
        RegexLiteral(InternedString),
        RepeatOp(RepeatOp),
        StringLiteral(InternedString),
        Symbol(Symbol),
        Symbol_2a(::std::vec::Vec<Symbol>),
        Symbol_2b(::std::vec::Vec<Symbol>),
        Symbol0(Symbol),
        Symbol1(Symbol),
        Symbol_3f(::std::option::Option<Symbol>),
        SymbolKind1(SymbolKind),
        Terminal(TerminalString),
        TypeParameter(TypeParameter),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        TypeRef(TypeRef),
        TypeRef_3f(::std::option::Option<TypeRef>),
        TypeRefOrLifetime(TypeRef),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        Use(GrammarItem),
        Use_2a(::std::vec::Vec<GrammarItem>),
        Use_2b(::std::vec::Vec<GrammarItem>),
        ______Grammar(Grammar),
        ______Pattern(Pattern<TypeRef>),
        ______TypeRef(TypeRef),
    }

    // State 0
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [EOF]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [EOF]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [EOF]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [EOF]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime TypeRef [EOF]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [EOF]
    //   TypeRef = (*) "&" TypeRef [EOF]
    //   TypeRef = (*) "&" "mut" TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   ___TypeRef = (*) TypeRef [EOF]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   "::" -> Shift(S8)
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //
    //   (<Id> "::")+ -> S1
    //   Id -> S2
    //   Path -> S3
    //   TypeRef -> S4
    pub fn ___state0<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym0));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
    }

    // State 1
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (<Id> "::")+ (*) Id [EOF]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (<Id> "::")+ (*) Id [")"]
    //   Path = (<Id> "::")+ (*) Id [","]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (<Id> "::")+ (*) Id [","]
    //   Path = (<Id> "::")+ (*) Id ["<"]
    //   Path = (<Id> "::")+ (*) Id [">"]
    //
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //
    //   Id -> S11
    pub fn ___state1<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state11(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 2
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [EOF]
    //   Path = Id (*) ["<"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [")"]
    //   Path = Id (*) [","]
    //   Path = Id (*) ["<"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = Id (*) [","]
    //   Path = Id (*) ["<"]
    //   Path = Id (*) [">"]
    //
    //   EOF -> Reduce(Path = Id => ActionFn(251);)
    //   ")" -> Reduce(Path = Id => ActionFn(251);)
    //   "," -> Reduce(Path = Id => ActionFn(251);)
    //   "::" -> Shift(S12)
    //   "<" -> Reduce(Path = Id => ActionFn(251);)
    //   ">" -> Reduce(Path = Id => ActionFn(251);)
    //
    pub fn ___state2<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action251(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 3
    //   TypeRef = Path (*) [EOF]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   EOF -> Reduce(TypeRef = Path => ActionFn(52);)
    //   ")" -> Reduce(TypeRef = Path => ActionFn(52);)
    //   "," -> Reduce(TypeRef = Path => ActionFn(52);)
    //   "<" -> Shift(S13)
    //   ">" -> Reduce(TypeRef = Path => ActionFn(52);)
    //
    pub fn ___state3<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state13(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action52(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 4
    //   ___TypeRef = TypeRef (*) [EOF]
    //
    //   EOF -> Reduce(___TypeRef = TypeRef => ActionFn(1);)
    //
    pub fn ___state4<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action1(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::______TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 5
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [EOF]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S14
    //   Symbol -> S15
    //   Symbol0 -> S16
    //   Symbol1 -> S17
    pub fn ___state5<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state15(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state16(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 6
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id [EOF]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [EOF]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [EOF]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [EOF]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime TypeRef [EOF]
    //   TypeRef = "&" (*) Lifetime TypeRef [EOF]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [EOF]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [EOF]
    //   TypeRef = (*) "&" TypeRef [EOF]
    //   TypeRef = "&" (*) TypeRef [EOF]
    //   TypeRef = (*) "&" "mut" TypeRef [EOF]
    //   TypeRef = "&" (*) "mut" TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = "&" (*) Lifetime TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = "&" (*) TypeRef [")"]
    //   TypeRef = "&" (*) TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = "&" (*) "mut" TypeRef [")"]
    //   TypeRef = "&" (*) "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = "&" (*) Lifetime TypeRef [","]
    //   TypeRef = "&" (*) Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" (*) Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = "&" (*) TypeRef [","]
    //   TypeRef = "&" (*) TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = "&" (*) "mut" TypeRef [","]
    //   TypeRef = "&" (*) "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   "::" -> Shift(S8)
    //   "Id" -> Shift(S9)
    //   "Lifetime" -> Shift(S20)
    //   "MacroId" -> Shift(S10)
    //   "mut" -> Shift(S21)
    //
    //   (<Id> "::")+ -> S1
    //   Id -> S2
    //   Lifetime -> S18
    //   Path -> S3
    //   TypeRef -> S19
    pub fn ___state6<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state20(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state21(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state18(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state19(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 7
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [EOF]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) (<TypeRef> ",")+ TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (*) [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ [")"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")+ TypeRef [")"]
    //   Comma<TypeRef> = (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   ")" -> Reduce(Comma<TypeRef> =  => ActionFn(394);)
    //   "::" -> Shift(S8)
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //
    //   (<Id> "::")+ -> S1
    //   (<TypeRef> ",")+ -> S22
    //   Comma<TypeRef> -> S23
    //   Id -> S2
    //   Path -> S3
    //   TypeRef -> S24
    pub fn ___state7<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action394(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state22(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cTypeRef_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state23(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 8
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [EOF]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) Id [EOF]
    //   Path = "::" (*) Id ["<"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [")"]
    //   Path = "::" (*) (<Id> "::")+ Id [","]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) Id [")"]
    //   Path = "::" (*) Id [","]
    //   Path = "::" (*) Id ["<"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::" (*) (<Id> "::")+ Id [","]
    //   Path = "::" (*) (<Id> "::")+ Id ["<"]
    //   Path = "::" (*) (<Id> "::")+ Id [">"]
    //   Path = "::" (*) Id [","]
    //   Path = "::" (*) Id ["<"]
    //   Path = "::" (*) Id [">"]
    //
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //
    //   (<Id> "::")+ -> S25
    //   Id -> S26
    pub fn ___state8<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state25(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state26(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 9
    //   Id = "Id" (*) [EOF]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //
    //   EOF -> Reduce(Id = "Id" => ActionFn(73);)
    //   ")" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "," -> Reduce(Id = "Id" => ActionFn(73);)
    //   "::" -> Reduce(Id = "Id" => ActionFn(73);)
    //   "<" -> Reduce(Id = "Id" => ActionFn(73);)
    //   ">" -> Reduce(Id = "Id" => ActionFn(73);)
    //
    pub fn ___state9<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action73(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 10
    //   Id = "MacroId" (*) [EOF]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //
    //   EOF -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   ")" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "," -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "::" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "<" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   ">" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //
    pub fn ___state10<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 11
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [EOF]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [")"]
    //   Path = (<Id> "::")+ Id (*) [","]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = (<Id> "::")+ Id (*) [","]
    //   Path = (<Id> "::")+ Id (*) ["<"]
    //   Path = (<Id> "::")+ Id (*) [">"]
    //
    //   EOF -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   ")" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "," -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   "::" -> Shift(S27)
    //   "<" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //   ">" -> Reduce(Path = (<Id> "::")+, Id => ActionFn(252);)
    //
    pub fn ___state11<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action252(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 12
    //   (<Id> "::")+ = Id "::" (*) ["Id"]
    //   (<Id> "::")+ = Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")+ = Id, "::" => ActionFn(247);)
    //   "MacroId" -> Reduce((<Id> "::")+ = Id, "::" => ActionFn(247);)
    //
    pub fn ___state12<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action247(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 13
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ [">"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime [">"]
    //   Comma<TypeRefOrLifetime> = (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   "::" -> Shift(S8)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> =  => ActionFn(398);)
    //   "Id" -> Shift(S9)
    //   "Lifetime" -> Shift(S20)
    //   "MacroId" -> Shift(S10)
    //
    //   (<Id> "::")+ -> S1
    //   (<TypeRefOrLifetime> ",")+ -> S28
    //   Comma<TypeRefOrLifetime> -> S29
    //   Id -> S2
    //   Lifetime -> S30
    //   Path -> S3
    //   TypeRef -> S31
    //   TypeRefOrLifetime -> S32
    pub fn ___state13<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state20(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action398(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state28(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state29(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state30(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state31(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state32(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 14
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["#"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["#"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral [")"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" [")"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [","]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [","]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S39)
    //   "<" -> Shift(S40)
    //   "@L" -> Shift(S41)
    //   "@R" -> Shift(S42)
    //   "Escape" -> Shift(S43)
    //   "Id" -> Shift(S44)
    //   "MacroId" -> Shift(S45)
    //   "RegexLiteral" -> Shift(S46)
    //   "StringLiteral" -> Shift(S47)
    //
    //   Escape -> S33
    //   MacroId -> S34
    //   QuotedTerminal -> S35
    //   RegexLiteral -> S36
    //   StringLiteral -> S37
    //   SymbolKind1 -> S38
    pub fn ___state14<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state39(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state40(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state41(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state42(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state43(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state44(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state45(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state46(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state47(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state33(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state34(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state35(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state37(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state38(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 15
    //   TypeRef = "#" Symbol (*) "#" [EOF]
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //
    //   "#" -> Shift(S48)
    //
    pub fn ___state15<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state48(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 16
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "#" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "(" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   ")" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "*" -> Shift(S50)
    //   "+" -> Shift(S51)
    //   "," -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "<" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   ">" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "?" -> Shift(S52)
    //   "@L" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "@R" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "Escape" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "Id" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "RegexLiteral" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => ActionFn(34);)
    //
    //   RepeatOp -> S49
    pub fn ___state16<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action34(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 17
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "(" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   ")" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "*" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "+" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "," -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "<" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   ">" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "?" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => ActionFn(35);)
    //
    pub fn ___state17<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action35(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 18
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [EOF]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [EOF]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [EOF]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [EOF]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime TypeRef [EOF]
    //   TypeRef = "&" Lifetime (*) TypeRef [EOF]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [EOF]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [EOF]
    //   TypeRef = (*) "&" TypeRef [EOF]
    //   TypeRef = (*) "&" "mut" TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = "&" Lifetime (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime (*) TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [")"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = "&" Lifetime (*) TypeRef [","]
    //   TypeRef = "&" Lifetime (*) TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime (*) "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   "::" -> Shift(S8)
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //   "mut" -> Shift(S54)
    //
    //   (<Id> "::")+ -> S1
    //   Id -> S2
    //   Path -> S3
    //   TypeRef -> S53
    pub fn ___state18<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state54(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state53(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 19
    //   TypeRef = "&" TypeRef (*) [EOF]
    //   TypeRef = "&" TypeRef (*) [")"]
    //   TypeRef = "&" TypeRef (*) [","]
    //   TypeRef = "&" TypeRef (*) [","]
    //   TypeRef = "&" TypeRef (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   ")" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   "," -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //   ">" -> Reduce(TypeRef = "&", TypeRef => ActionFn(374);)
    //
    pub fn ___state19<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action374(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 20
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //
    //   "#" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "&" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "(" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "," -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "::" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   ">" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => ActionFn(76);)
    //
    pub fn ___state20<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action76(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 21
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [EOF]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [EOF]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [EOF]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [EOF]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime TypeRef [EOF]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [EOF]
    //   TypeRef = (*) "&" TypeRef [EOF]
    //   TypeRef = (*) "&" "mut" TypeRef [EOF]
    //   TypeRef = "&" "mut" (*) TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = "&" "mut" (*) TypeRef [")"]
    //   TypeRef = "&" "mut" (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = "&" "mut" (*) TypeRef [","]
    //   TypeRef = "&" "mut" (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   "::" -> Shift(S8)
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //
    //   (<Id> "::")+ -> S1
    //   Id -> S2
    //   Path -> S3
    //   TypeRef -> S55
    pub fn ___state21<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state55(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 22
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ (*) TypeRef "," ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ (*) [")"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ (*) TypeRef [")"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")+ => ActionFn(396);)
    //   "::" -> Shift(S8)
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //
    //   (<Id> "::")+ -> S1
    //   Id -> S2
    //   Path -> S3
    //   TypeRef -> S56
    pub fn ___state22<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action396(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state56(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 23
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [EOF]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S57)
    //
    pub fn ___state23<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state57(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 24
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["("]
    //   (<TypeRef> ",")+ = TypeRef (*) "," [")"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",")+ = TypeRef (*) "," ["MacroId"]
    //   Comma<TypeRef> = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = TypeRef => ActionFn(393);)
    //   "," -> Shift(S58)
    //
    pub fn ___state24<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state58(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action393(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 25
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [EOF]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [")"]
    //   Path = "::" (<Id> "::")+ (*) Id [","]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::" (<Id> "::")+ (*) Id [","]
    //   Path = "::" (<Id> "::")+ (*) Id ["<"]
    //   Path = "::" (<Id> "::")+ (*) Id [">"]
    //
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //
    //   Id -> S59
    pub fn ___state25<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state59(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 26
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [EOF]
    //   Path = "::" Id (*) ["<"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [")"]
    //   Path = "::" Id (*) [","]
    //   Path = "::" Id (*) ["<"]
    //   (<Id> "::")+ = Id (*) "::" ["Id"]
    //   (<Id> "::")+ = Id (*) "::" ["MacroId"]
    //   Path = "::" Id (*) [","]
    //   Path = "::" Id (*) ["<"]
    //   Path = "::" Id (*) [">"]
    //
    //   EOF -> Reduce(Path = "::", Id => ActionFn(249);)
    //   ")" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "," -> Reduce(Path = "::", Id => ActionFn(249);)
    //   "::" -> Shift(S12)
    //   "<" -> Reduce(Path = "::", Id => ActionFn(249);)
    //   ">" -> Reduce(Path = "::", Id => ActionFn(249);)
    //
    pub fn ___state26<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym1, ___sym2));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action249(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 27
    //   (<Id> "::")+ = (<Id> "::")+ Id "::" (*) ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")+ = (<Id> "::")+, Id, "::" => ActionFn(248);)
    //   "MacroId" -> Reduce((<Id> "::")+ = (<Id> "::")+, Id, "::" => ActionFn(248);)
    //
    pub fn ___state27<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action248(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 28
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ (*) [">"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ (*) TypeRefOrLifetime [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   "::" -> Shift(S8)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ => ActionFn(400);)
    //   "Id" -> Shift(S9)
    //   "Lifetime" -> Shift(S20)
    //   "MacroId" -> Shift(S10)
    //
    //   (<Id> "::")+ -> S1
    //   Id -> S2
    //   Lifetime -> S30
    //   Path -> S3
    //   TypeRef -> S31
    //   TypeRefOrLifetime -> S60
    pub fn ___state28<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state20(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action400(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state30(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state31(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state60(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 29
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [EOF]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S61)
    //
    pub fn ___state29<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state61(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 30
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => ActionFn(54);)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => ActionFn(54);)
    //
    pub fn ___state30<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action54(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 31
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => ActionFn(53);)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => ActionFn(53);)
    //
    pub fn ___state31<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action53(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 32
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime (*) "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S62)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = TypeRefOrLifetime => ActionFn(397);)
    //
    pub fn ___state32<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state62(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action397(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 33
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "(" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   ")" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "*" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "+" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "," -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "<" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   ">" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "?" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "@L" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "@R" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "Id" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => ActionFn(44);)
    //
    pub fn ___state33<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 34
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Shift(S63)
    //
    pub fn ___state34<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state63(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 35
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => ActionFn(42);)
    //
    pub fn ___state35<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action42(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 36
    //   QuotedTerminal = RegexLiteral (*) ["#"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) [")"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [","]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //
    //   "#" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "(" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   ")" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "*" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "+" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "," -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "<" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   ">" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "?" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "@L" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "@R" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "Escape" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "Id" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "MacroId" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //   "StringLiteral" -> Reduce(QuotedTerminal = RegexLiteral => ActionFn(80);)
    //
    pub fn ___state36<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action80(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 37
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "," -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => ActionFn(79);)
    //
    pub fn ___state37<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action79(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 38
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "*" -> Reduce(@R =  => ActionFn(130);)
    //   "+" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "?" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S64
    pub fn ___state38<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 39
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = (*) [")"]
    //   ExprSymbol = (*) Symbol+ [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [")"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [")"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(ExprSymbol =  => ActionFn(383);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S14
    //   ExprSymbol -> S65
    //   Symbol -> S66
    //   Symbol+ -> S67
    //   Symbol0 -> S16
    //   Symbol1 -> S17
    pub fn ___state39<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action383(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::ExprSymbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state66(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state67(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state16(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 40
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S68
    //   Symbol0 -> S69
    //   Symbol1 -> S17
    pub fn ___state40<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state68(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 41
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "(" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   ")" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "*" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "+" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "," -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "<" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   ">" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "?" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => ActionFn(46);)
    //
    pub fn ___state41<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action46(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 42
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "(" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   ")" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "*" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "+" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "," -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "<" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   ">" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "?" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => ActionFn(47);)
    //
    pub fn ___state42<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action47(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 43
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //
    //   "#" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "(" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   ")" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "*" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "+" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "," -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "<" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   ">" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "?" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "@L" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "@R" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "Escape" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "Id" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "MacroId" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "RegexLiteral" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => ActionFn(75);)
    //
    pub fn ___state43<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Escape(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 44
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "(" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ")" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "*" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "+" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "," -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "<" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ">" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "?" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //
    pub fn ___state44<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 45
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => ActionFn(71);)
    //
    pub fn ___state45<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action71(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 46
    //   RegexLiteral = "RegexLiteral" (*) ["#"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) [")"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [","]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "(" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   ")" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "*" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "+" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "," -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "<" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   ">" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "?" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "@L" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "@R" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "Escape" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "Id" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "MacroId" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "RegexLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //   "StringLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => ActionFn(82);)
    //
    pub fn ___state46<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action82(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RegexLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 47
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "RegexLiteral" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => ActionFn(81);)
    //
    pub fn ___state47<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action81(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::StringLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 48
    //   TypeRef = "#" Symbol "#" (*) [EOF]
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => ActionFn(49);)
    //
    pub fn ___state48<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action49(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 49
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "*" -> Reduce(@R =  => ActionFn(130);)
    //   "+" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "?" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S70
    pub fn ___state49<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state70(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 50
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "(" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   ")" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "*" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "+" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "," -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "<" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   ">" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "?" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "@L" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "@R" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "Escape" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "Id" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "MacroId" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => ActionFn(38);)
    //
    pub fn ___state50<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action38(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 51
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "(" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   ")" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "*" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "+" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "," -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "<" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   ">" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "?" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "@L" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "@R" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "Escape" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "Id" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "MacroId" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => ActionFn(37);)
    //
    pub fn ___state51<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action37(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 52
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "(" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   ")" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "*" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "+" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "," -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "<" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   ">" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "?" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "@L" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "@R" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "Escape" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "Id" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "MacroId" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "RegexLiteral" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => ActionFn(39);)
    //
    pub fn ___state52<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action39(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 53
    //   TypeRef = "&" Lifetime TypeRef (*) [EOF]
    //   TypeRef = "&" Lifetime TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime TypeRef (*) [","]
    //   TypeRef = "&" Lifetime TypeRef (*) [","]
    //   TypeRef = "&" Lifetime TypeRef (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   ")" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   "," -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //   ">" -> Reduce(TypeRef = "&", Lifetime, TypeRef => ActionFn(373);)
    //
    pub fn ___state53<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action373(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 54
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [EOF]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [EOF]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [EOF]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [EOF]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime TypeRef [EOF]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [EOF]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [EOF]
    //   TypeRef = (*) "&" TypeRef [EOF]
    //   TypeRef = (*) "&" "mut" TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = (*) (<Id> "::")+ Id [")"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) Id [")"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [")"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" Id [")"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [")"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [")"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["Id"]
    //   (<Id> "::")+ = (*) (<Id> "::")+ Id "::" ["MacroId"]
    //   (<Id> "::")+ = (*) Id "::" ["Id"]
    //   (<Id> "::")+ = (*) Id "::" ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = (*) (<Id> "::")+ Id [","]
    //   Path = (*) (<Id> "::")+ Id ["<"]
    //   Path = (*) (<Id> "::")+ Id [">"]
    //   Path = (*) Id [","]
    //   Path = (*) Id ["<"]
    //   Path = (*) Id [">"]
    //   Path = (*) "::" (<Id> "::")+ Id [","]
    //   Path = (*) "::" (<Id> "::")+ Id ["<"]
    //   Path = (*) "::" (<Id> "::")+ Id [">"]
    //   Path = (*) "::" Id [","]
    //   Path = (*) "::" Id ["<"]
    //   Path = (*) "::" Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime TypeRef [","]
    //   TypeRef = (*) "&" Lifetime TypeRef [">"]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [","]
    //   TypeRef = (*) "&" Lifetime "mut" TypeRef [">"]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [","]
    //   TypeRef = "&" Lifetime "mut" (*) TypeRef [">"]
    //   TypeRef = (*) "&" TypeRef [","]
    //   TypeRef = (*) "&" TypeRef [">"]
    //   TypeRef = (*) "&" "mut" TypeRef [","]
    //   TypeRef = (*) "&" "mut" TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S5)
    //   "&" -> Shift(S6)
    //   "(" -> Shift(S7)
    //   "::" -> Shift(S8)
    //   "Id" -> Shift(S9)
    //   "MacroId" -> Shift(S10)
    //
    //   (<Id> "::")+ -> S1
    //   Id -> S2
    //   Path -> S3
    //   TypeRef -> S71
    pub fn ___state54<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2b(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state71(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 55
    //   TypeRef = "&" "mut" TypeRef (*) [EOF]
    //   TypeRef = "&" "mut" TypeRef (*) [")"]
    //   TypeRef = "&" "mut" TypeRef (*) [","]
    //   TypeRef = "&" "mut" TypeRef (*) [","]
    //   TypeRef = "&" "mut" TypeRef (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   ")" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   "," -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //   ">" -> Reduce(TypeRef = "&", "mut", TypeRef => ActionFn(372);)
    //
    pub fn ___state55<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action372(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 56
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef (*) "," ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")+ TypeRef (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")+, TypeRef => ActionFn(395);)
    //   "," -> Shift(S72)
    //
    pub fn ___state56<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state72(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action395(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 57
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [EOF]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => ActionFn(48);)
    //
    pub fn ___state57<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action48(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 58
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["("]
    //   (<TypeRef> ",")+ = TypeRef "," (*) [")"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",")+ = TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "&" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "(" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   ")" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "::" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "Id" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //   "MacroId" -> Reduce((<TypeRef> ",")+ = TypeRef, "," => ActionFn(269);)
    //
    pub fn ___state58<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action269(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 59
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [EOF]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [")"]
    //   Path = "::" (<Id> "::")+ Id (*) [","]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["Id"]
    //   (<Id> "::")+ = (<Id> "::")+ Id (*) "::" ["MacroId"]
    //   Path = "::" (<Id> "::")+ Id (*) [","]
    //   Path = "::" (<Id> "::")+ Id (*) ["<"]
    //   Path = "::" (<Id> "::")+ Id (*) [">"]
    //
    //   EOF -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   ")" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "," -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   "::" -> Shift(S27)
    //   "<" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //   ">" -> Reduce(Path = "::", (<Id> "::")+, Id => ActionFn(250);)
    //
    pub fn ___state59<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1, ___sym2, ___sym3));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action250(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 60
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) "," ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S73)
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime => ActionFn(399);)
    //
    pub fn ___state60<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state73(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action399(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 61
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [EOF]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => ActionFn(51);)
    //
    pub fn ___state61<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action51(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 62
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")+ = TypeRefOrLifetime, "," => ActionFn(273);)
    //
    pub fn ___state62<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action273(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 63
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) (<Symbol> ",")+ Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (*) [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ [">"]
    //   Comma<Symbol> = (*) (<Symbol> ",")+ Symbol [">"]
    //   Comma<Symbol> = (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   ">" -> Reduce(Comma<Symbol> =  => ActionFn(386);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   (<Symbol> ",")+ -> S74
    //   @L -> S14
    //   Comma<Symbol> -> S75
    //   Symbol -> S76
    //   Symbol0 -> S16
    //   Symbol1 -> S17
    pub fn ___state63<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action386(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state74(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cSymbol_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state75(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state76(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state16(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 64
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "RegexLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => ActionFn(40);)
    //
    pub fn ___state64<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action40(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 65
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //
    //   ")" -> Shift(S77)
    //
    pub fn ___state65<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state77(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 66
    //   Symbol+ = Symbol (*) ["("]
    //   Symbol+ = Symbol (*) [")"]
    //   Symbol+ = Symbol (*) ["<"]
    //   Symbol+ = Symbol (*) ["@L"]
    //   Symbol+ = Symbol (*) ["@R"]
    //   Symbol+ = Symbol (*) ["Escape"]
    //   Symbol+ = Symbol (*) ["Id"]
    //   Symbol+ = Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   ")" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "<" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "@L" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "@R" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "Escape" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "Id" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "MacroId" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "RegexLiteral" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol => ActionFn(111);)
    //
    pub fn ___state66<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action111(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 67
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol+ (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [")"]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["RegexLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   ")" -> Reduce(ExprSymbol = Symbol+ => ActionFn(384);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S14
    //   Symbol -> S78
    //   Symbol0 -> S16
    //   Symbol1 -> S17
    pub fn ___state67<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action384(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state78(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state16(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 68
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S39)
    //   "@L" -> Shift(S41)
    //   "@R" -> Shift(S42)
    //   "Escape" -> Shift(S43)
    //   "Id" -> Shift(S80)
    //   "MacroId" -> Shift(S81)
    //   "RegexLiteral" -> Shift(S46)
    //   "StringLiteral" -> Shift(S47)
    //
    //   Escape -> S33
    //   Id -> S79
    //   MacroId -> S34
    //   QuotedTerminal -> S35
    //   RegexLiteral -> S36
    //   StringLiteral -> S37
    //   SymbolKind1 -> S38
    pub fn ___state68<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state39(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state41(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state42(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state43(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state80(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state46(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state47(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state33(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state79(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state34(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state35(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state37(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state38(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 69
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S50)
    //   "+" -> Shift(S51)
    //   ">" -> Shift(S82)
    //   "?" -> Shift(S52)
    //
    //   RepeatOp -> S49
    pub fn ___state69<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 70
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => ActionFn(36);)
    //
    pub fn ___state70<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action36(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 71
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [EOF]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [","]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [","]
    //   TypeRef = "&" Lifetime "mut" TypeRef (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   ")" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   "," -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //   ">" -> Reduce(TypeRef = "&", Lifetime, "mut", TypeRef => ActionFn(371);)
    //
    pub fn ___state71<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action371(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 72
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["#"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["&"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["("]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) [")"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["::"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",")+ = (<TypeRef> ",")+ TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "&" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "(" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   ")" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "::" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "Id" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //   "MacroId" -> Reduce((<TypeRef> ",")+ = (<TypeRef> ",")+, TypeRef, "," => ActionFn(270);)
    //
    pub fn ___state72<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action270(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 73
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+ TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")+ = (<TypeRefOrLifetime> ",")+, TypeRefOrLifetime, "," => ActionFn(274);)
    //
    pub fn ___state73<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action274(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 74
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ (*) Symbol "," ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")+ (*) [">"]
    //   Comma<Symbol> = (<Symbol> ",")+ (*) Symbol [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "<" -> Reduce(@L =  => ActionFn(131);)
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")+ => ActionFn(388);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S14
    //   Symbol -> S83
    //   Symbol0 -> S16
    //   Symbol1 -> S17
    pub fn ___state74<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action388(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state16(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 75
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //
    //   ">" -> Shift(S84)
    //
    pub fn ___state75<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state84(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 76
    //   (<Symbol> ",")+ = Symbol (*) "," ["("]
    //   (<Symbol> ",")+ = Symbol (*) "," ["<"]
    //   (<Symbol> ",")+ = Symbol (*) "," [">"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["@L"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["@R"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["Id"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = Symbol (*) "," ["StringLiteral"]
    //   Comma<Symbol> = Symbol (*) [">"]
    //
    //   "," -> Shift(S85)
    //   ">" -> Reduce(Comma<Symbol> = Symbol => ActionFn(385);)
    //
    pub fn ___state76<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state85(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action385(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 77
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => ActionFn(45);)
    //
    pub fn ___state77<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action45(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 78
    //   Symbol+ = Symbol+ Symbol (*) ["("]
    //   Symbol+ = Symbol+ Symbol (*) [")"]
    //   Symbol+ = Symbol+ Symbol (*) ["<"]
    //   Symbol+ = Symbol+ Symbol (*) ["@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["Escape"]
    //   Symbol+ = Symbol+ Symbol (*) ["Id"]
    //   Symbol+ = Symbol+ Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol+ Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   ")" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "<" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "@L" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "@R" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "Escape" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "Id" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "MacroId" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "RegexLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => ActionFn(112);)
    //
    pub fn ___state78<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action112(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 79
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //
    //   ":" -> Shift(S86)
    //
    pub fn ___state79<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state86(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 80
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "+" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   ":" -> Reduce(Id = "Id" => ActionFn(73);)
    //   ">" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //   "?" -> Reduce(SymbolKind1 = "Id" => ActionFn(43);)
    //
    pub fn ___state80<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action73(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 81
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "MacroId" => ActionFn(74);)
    //   "<" -> Reduce(MacroId = "MacroId" => ActionFn(71);)
    //
    pub fn ___state81<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action71(text, ___sym0, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 82
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S87
    pub fn ___state82<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 83
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol (*) "," ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")+ Symbol (*) [">"]
    //
    //   "," -> Shift(S88)
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")+, Symbol => ActionFn(387);)
    //
    pub fn ___state83<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state88(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action387(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 84
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => ActionFn(41);)
    //
    pub fn ___state84<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action41(text, ___sym0, ___sym1, ___sym2, ___sym3, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 85
    //   (<Symbol> ",")+ = Symbol "," (*) ["("]
    //   (<Symbol> ",")+ = Symbol "," (*) ["<"]
    //   (<Symbol> ",")+ = Symbol "," (*) [">"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["@L"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["@R"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["Id"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",")+ = Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "<" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   ">" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "@L" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "@R" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "Escape" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "Id" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "MacroId" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //   "StringLiteral" -> Reduce((<Symbol> ",")+ = Symbol, "," => ActionFn(261);)
    //
    pub fn ___state85<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action261(text, ___sym0, ___sym1, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 86
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => ActionFn(131);)
    //   "@L" -> Reduce(@L =  => ActionFn(131);)
    //   "@R" -> Reduce(@L =  => ActionFn(131);)
    //   "Escape" -> Reduce(@L =  => ActionFn(131);)
    //   "Id" -> Reduce(@L =  => ActionFn(131);)
    //   "MacroId" -> Reduce(@L =  => ActionFn(131);)
    //   "RegexLiteral" -> Reduce(@L =  => ActionFn(131);)
    //   "StringLiteral" -> Reduce(@L =  => ActionFn(131);)
    //
    //   @L -> S89
    //   Symbol0 -> S90
    //   Symbol1 -> S17
    pub fn ___state86<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action131(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state89(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state90(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 87
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => ActionFn(33);)
    //
    pub fn ___state87<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action33(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 88
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["("]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["<"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) [">"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["@L"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["@R"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["Escape"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["Id"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",")+ = (<Symbol> ",")+ Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "<" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   ">" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "@L" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "@R" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "Escape" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "Id" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "MacroId" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //   "StringLiteral" -> Reduce((<Symbol> ",")+ = (<Symbol> ",")+, Symbol, "," => ActionFn(262);)
    //
    pub fn ___state88<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action262(text, ___sym0, ___sym1, ___sym2, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 89
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S39)
    //   "@L" -> Shift(S41)
    //   "@R" -> Shift(S42)
    //   "Escape" -> Shift(S43)
    //   "Id" -> Shift(S44)
    //   "MacroId" -> Shift(S45)
    //   "RegexLiteral" -> Shift(S46)
    //   "StringLiteral" -> Shift(S47)
    //
    //   Escape -> S33
    //   MacroId -> S34
    //   QuotedTerminal -> S35
    //   RegexLiteral -> S36
    //   StringLiteral -> S37
    //   SymbolKind1 -> S38
    pub fn ___state89<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state39(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state41(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state42(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state43(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state44(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state45(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state46(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state47(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state33(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state34(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state35(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state37(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state38(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 90
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S50)
    //   "+" -> Shift(S51)
    //   ">" -> Shift(S91)
    //   "?" -> Shift(S52)
    //
    //   RepeatOp -> S49
    pub fn ___state90<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state91(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 91
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => ActionFn(130);)
    //   "(" -> Reduce(@R =  => ActionFn(130);)
    //   ")" -> Reduce(@R =  => ActionFn(130);)
    //   "," -> Reduce(@R =  => ActionFn(130);)
    //   "<" -> Reduce(@R =  => ActionFn(130);)
    //   ">" -> Reduce(@R =  => ActionFn(130);)
    //   "@L" -> Reduce(@R =  => ActionFn(130);)
    //   "@R" -> Reduce(@R =  => ActionFn(130);)
    //   "Escape" -> Reduce(@R =  => ActionFn(130);)
    //   "Id" -> Reduce(@R =  => ActionFn(130);)
    //   "MacroId" -> Reduce(@R =  => ActionFn(130);)
    //   "RegexLiteral" -> Reduce(@R =  => ActionFn(130);)
    //   "StringLiteral" -> Reduce(@R =  => ActionFn(130);)
    //
    //   @R -> S92
    pub fn ___state91<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action130(text, &___lookbehind, &___lookahead);
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state92(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 92
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => ActionFn(32);)
    //
    pub fn ___state92<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action32(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, &___lookbehind, &___lookahead);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
pub use self::___parse___TypeRef::parse_TypeRef;

pub fn ___action0<
    'input,
>(
    text: &'input str,
    ___0: Grammar,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    (___0)
}

pub fn ___action1<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    (___0)
}

pub fn ___action2<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Pattern<TypeRef>
{
    (___0)
}

pub fn ___action3<
    'input,
>(
    text: &'input str,
    uses: ::std::vec::Vec<GrammarItem>,
    annotations: ::std::vec::Vec<Annotation>,
    lo: usize,
    _: Tok<'input>,
    hi: usize,
    tps: ::std::option::Option<Vec<TypeParameter>>,
    parameters: ::std::option::Option<Vec<Parameter>>,
    where_clauses: ::std::option::Option<Vec<&'input str>>,
    _: Tok<'input>,
    items: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    {
        let where_clauses =
            where_clauses.iter()
                         .flat_map(|wc| wc.iter())
                         .map(|s| strip(s))
                         .filter(|s| !s.is_empty())
                         .map(|s| s.to_string())
                         .collect();
        Grammar { prefix: format!("__"), // adjusted by `parse_grammar`
                  span: Span(lo, hi),
                  type_parameters: tps.unwrap_or(vec![]),
                  parameters: parameters.unwrap_or(vec![]),
                  where_clauses: where_clauses,
                  items: uses.into_iter().chain(items).collect(),
                  annotations: annotations }
    }
}

pub fn ___action4<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<TypeParameter>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeParameter>
{
    (___0)
}

pub fn ___action5<
    'input,
>(
    text: &'input str,
    l: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeParameter
{
    TypeParameter::Lifetime(l)
}

pub fn ___action6<
    'input,
>(
    text: &'input str,
    l: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeParameter
{
    TypeParameter::Id(l)
}

pub fn ___action7<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<Parameter>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Parameter>
{
    (___0)
}

pub fn ___action8<
    'input,
>(
    text: &'input str,
    id: InternedString,
    _: Tok<'input>,
    ty: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Parameter
{
    Parameter { name: id, ty: ty }
}

pub fn ___action9<
    'input,
>(
    text: &'input str,
    ___0: GrammarItem,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    (___0)
}

pub fn ___action10<
    'input,
>(
    text: &'input str,
    ___0: GrammarItem,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    (___0)
}

pub fn ___action11<
    'input,
>(
    text: &'input str,
    ___0: GrammarItem,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    (___0)
}

pub fn ___action12<
    'input,
>(
    text: &'input str,
    u: &'input str,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    GrammarItem::Use(strip(u).to_string())
}

pub fn ___action13<
    'input,
>(
    text: &'input str,
    annotations: ::std::vec::Vec<Annotation>,
    p: ::std::option::Option<Tok<'input>>,
    lo: usize,
    n: (NonterminalString, Vec<NonterminalString>),
    hi: usize,
    t: ::std::option::Option<TypeRef>,
    _: Tok<'input>,
    a: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    {
        GrammarItem::Nonterminal(NonterminalData { public: p.is_some(),
                                                   span: Span(lo, hi),
                                                   name: n.0,
                                                   annotations: annotations,
                                                   args: n.1,
                                                   type_decl: t,
                                                   alternatives: a })
    }
}

pub fn ___action14<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    _: Tok<'input>,
    lo: usize,
    id: InternedString,
    hi: usize,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Annotation
{
    {
        Annotation { id_span: Span(lo, hi), id: id }
    }
}

pub fn ___action15<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
    _: Tok<'input>,
    ___1: Vec<NonterminalString>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (___0, ___1)
}

pub fn ___action16<
    'input,
>(
    text: &'input str,
    n: NonterminalString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (n, vec![])
}

pub fn ___action17<
    'input,
>(
    text: &'input str,
    ___0: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (NonterminalString(intern(___0)), vec![])
}

pub fn ___action18<
    'input,
>(
    text: &'input str,
    a: Alternative,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    vec![a]
}

pub fn ___action19<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<Alternative>,
    _: Tok<'input>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    (___0)
}

pub fn ___action20<
    'input,
>(
    text: &'input str,
    lo: usize,
    s: ::std::vec::Vec<Symbol>,
    c: ::std::option::Option<Condition>,
    a: ::std::option::Option<ActionKind>,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    {
        Alternative {
            span: Span(lo, hi),
            expr: ExprSymbol { symbols: s },
            condition: c,
            action: a
        }
    }
}

pub fn ___action21<
    'input,
>(
    text: &'input str,
    lo: usize,
    c: ::std::option::Option<Condition>,
    a: ActionKind,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    {
        Alternative {
            span: Span(lo, hi),
            expr: ExprSymbol { symbols: vec![] },
            condition: c,
            action: Some(a)
        }
    }
}

pub fn ___action22<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ActionKind
{
    ActionKind::Lookahead
}

pub fn ___action23<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ActionKind
{
    ActionKind::Lookbehind
}

pub fn ___action24<
    'input,
>(
    text: &'input str,
    c: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ActionKind
{
    ActionKind::User(strip(c).to_string())
}

pub fn ___action25<
    'input,
>(
    text: &'input str,
    c: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ActionKind
{
    ActionKind::Fallible(strip(c).to_string())
}

pub fn ___action26<
    'input,
>(
    text: &'input str,
    lo: usize,
    a: NonterminalString,
    op: ConditionOp,
    b: InternedString,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Condition
{
    {
        Condition { span:Span(lo, hi), lhs:a, rhs:b, op:op }
    }
}

pub fn ___action27<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ConditionOp
{
    ConditionOp::Equals
}

pub fn ___action28<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ConditionOp
{
    ConditionOp::NotEquals
}

pub fn ___action29<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ConditionOp
{
    ConditionOp::Match
}

pub fn ___action30<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ConditionOp
{
    ConditionOp::NotMatch
}

pub fn ___action31<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Symbol>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ExprSymbol
{
    ExprSymbol { symbols: ___0 }
}

pub fn ___action32<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    _: usize,
    l: InternedString,
    _: Tok<'input>,
    s: Symbol,
    _: Tok<'input>,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Symbol
{
    Symbol::new(Span(lo, hi), SymbolKind::Name(l, Box::new(s)))
}

pub fn ___action33<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    s: Symbol,
    _: Tok<'input>,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Symbol
{
    Symbol::new(Span(lo, hi), SymbolKind::Choose(Box::new(s)))
}

pub fn ___action34<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Symbol
{
    (___0)
}

pub fn ___action35<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Symbol
{
    (___0)
}

pub fn ___action36<
    'input,
>(
    text: &'input str,
    lhs: Symbol,
    op: RepeatOp,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Symbol
{
    Symbol::new(Span(lhs.span.0, hi),
                    SymbolKind::Repeat(Box::new(RepeatSymbol { symbol: lhs, op: op })))
}

pub fn ___action37<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> RepeatOp
{
    RepeatOp::Plus
}

pub fn ___action38<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> RepeatOp
{
    RepeatOp::Star
}

pub fn ___action39<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> RepeatOp
{
    RepeatOp::Question
}

pub fn ___action40<
    'input,
>(
    text: &'input str,
    lo: usize,
    sk: SymbolKind,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Symbol
{
    Symbol::new(Span(lo, hi), sk)
}

pub fn ___action41<
    'input,
>(
    text: &'input str,
    name: NonterminalString,
    _: Tok<'input>,
    args: Vec<Symbol>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> SymbolKind
{
    SymbolKind::Macro(MacroSymbol { name: name, args: args })
}

pub fn ___action42<
    'input,
>(
    text: &'input str,
    ___0: TerminalString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> SymbolKind
{
    SymbolKind::Terminal(___0)
}

pub fn ___action43<
    'input,
>(
    text: &'input str,
    ___0: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> SymbolKind
{
    SymbolKind::AmbiguousId(intern(___0))
}

pub fn ___action44<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> SymbolKind
{
    SymbolKind::Nonterminal(NonterminalString(___0))
}

pub fn ___action45<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: ExprSymbol,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> SymbolKind
{
    SymbolKind::Expr(___0)
}

pub fn ___action46<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> SymbolKind
{
    SymbolKind::Lookahead
}

pub fn ___action47<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> SymbolKind
{
    SymbolKind::Lookbehind
}

pub fn ___action48<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<TypeRef>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    TypeRef::Tuple(___0)
}

pub fn ___action49<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Symbol,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    {
        TypeRef::OfSymbol(___0.kind)
    }
}

pub fn ___action50<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    l: ::std::option::Option<InternedString>,
    m: ::std::option::Option<Tok<'input>>,
    t: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    TypeRef::Ref { lifetime: l,
                       mutable: m.is_some(),
                       referent: Box::new(t) }
}

pub fn ___action51<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a: Vec<TypeRef>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    TypeRef::Nominal { path: p, types: a }
}

pub fn ___action52<
    'input,
>(
    text: &'input str,
    p: Path,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    match p.as_id() {
            Some(id) => TypeRef::Id(id),
            None => TypeRef::Nominal { path: p, types: vec![] }
        }
}

pub fn ___action53<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    (___0)
}

pub fn ___action54<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    TypeRef::Lifetime(___0)
}

pub fn ___action55<
    'input,
>(
    text: &'input str,
    a: ::std::option::Option<Tok<'input>>,
    h: ::std::vec::Vec<InternedString>,
    t: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Path
{
    {
        Path { absolute: a.is_some(),
               ids: h.into_iter().chain(once(t)).collect() }
    }
}

pub fn ___action56<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    hi: usize,
    _: Tok<'input>,
    a0: ::std::vec::Vec<AssociatedType>,
    et: EnumToken,
    a1: ::std::vec::Vec<AssociatedType>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    {
        GrammarItem::ExternToken(ExternToken {
            span: Span(lo, hi),
            associated_types: a0.into_iter().chain(a1).collect(),
            enum_token: Some(et),
        })
    }
}

pub fn ___action57<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    hi: usize,
    _: Tok<'input>,
    a0: ::std::vec::Vec<AssociatedType>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    {
        GrammarItem::ExternToken(ExternToken {
            span: Span(lo, hi),
            associated_types: a0,
            enum_token: None,
        })
    }
}

pub fn ___action58<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    lo: usize,
    t: TypeRef,
    hi: usize,
    _: Tok<'input>,
    c: Vec<Conversion>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> EnumToken
{
    {
        EnumToken {
            type_name: t,
            type_span: Span(lo, hi),
            conversions: c,
        }
    }
}

pub fn ___action59<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    lo: usize,
    n: InternedString,
    hi: usize,
    _: Tok<'input>,
    t: TypeRef,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> AssociatedType
{
    {
        AssociatedType { type_span: Span(lo, hi),
                         type_name: n,
                         type_ref: t }
    }
}

pub fn ___action60<
    'input,
>(
    text: &'input str,
    lo: usize,
    from: TerminalString,
    start: usize,
    p: &'input str,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Result<Conversion,___ParseError<usize,Tok<'input>,tok::Error>>
{
    {
        let pattern = try!(super::parse_pattern(p, start + 2));
        Ok(Conversion { span: Span(lo, hi),
                        from: from,
                        to: pattern })
    }
}

pub fn ___action61<
    'input,
>(
    text: &'input str,
    lo: usize,
    k: PatternKind<TypeRef>,
    hi: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Pattern<TypeRef>
{
    Pattern { span: Span(lo, hi), kind: k }
}

pub fn ___action62<
    'input,
>(
    text: &'input str,
    ___0: Path,
    _: Tok<'input>,
    ___1: Vec<Pattern<TypeRef>>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    PatternKind::Enum(___0, ___1)
}

pub fn ___action63<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    a1: ::std::option::Option<FieldPattern<TypeRef>>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    PatternKind::Struct(p, a0.into_iter().chain(a1).collect(), false)
}

pub fn ___action64<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    _: Tok<'input>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    PatternKind::Struct(p, a0, true)
}

pub fn ___action65<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    PatternKind::Underscore
}

pub fn ___action66<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    PatternKind::DotDot
}

pub fn ___action67<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: TypeRef,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    PatternKind::Choose(___0)
}

pub fn ___action68<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<Pattern<TypeRef>>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    PatternKind::Tuple(___0)
}

pub fn ___action69<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    PatternKind::Path(___0)
}

pub fn ___action70<
    'input,
>(
    text: &'input str,
    lo: usize,
    id: InternedString,
    hi: usize,
    _: Tok<'input>,
    pat: Pattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> FieldPattern<TypeRef>
{
    {
        FieldPattern { field_span: Span(lo, hi),
                       field_name: id,
                       pattern: pat }
    }
}

pub fn ___action71<
    'input,
>(
    text: &'input str,
    i: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> NonterminalString
{
    NonterminalString(intern(i))
}

pub fn ___action72<
    'input,
>(
    text: &'input str,
    i: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> NonterminalString
{
    NonterminalString(intern(i))
}

pub fn ___action73<
    'input,
>(
    text: &'input str,
    i: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> InternedString
{
    intern(i)
}

pub fn ___action74<
    'input,
>(
    text: &'input str,
    i: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> InternedString
{
    intern(i)
}

pub fn ___action75<
    'input,
>(
    text: &'input str,
    i: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> InternedString
{
    intern(i)
}

pub fn ___action76<
    'input,
>(
    text: &'input str,
    i: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> InternedString
{
    intern(i)
}

pub fn ___action77<
    'input,
>(
    text: &'input str,
    ___0: TerminalString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TerminalString
{
    (___0)
}

pub fn ___action78<
    'input,
>(
    text: &'input str,
    i: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TerminalString
{
    TerminalString::Bare(intern(i))
}

pub fn ___action79<
    'input,
>(
    text: &'input str,
    s: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TerminalString
{
    TerminalString::quoted(s)
}

pub fn ___action80<
    'input,
>(
    text: &'input str,
    s: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TerminalString
{
    TerminalString::regex(s)
}

pub fn ___action81<
    'input,
>(
    text: &'input str,
    s: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> InternedString
{
    intern(s)
}

pub fn ___action82<
    'input,
>(
    text: &'input str,
    s: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> InternedString
{
    intern(s)
}

pub fn ___action83<
    'input,
>(
    text: &'input str,
    ___0: FieldPattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<FieldPattern<TypeRef>>
{
    Some(___0)
}

pub fn ___action84<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<FieldPattern<TypeRef>>
{
    None
}

pub fn ___action85<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    vec![]
}

pub fn ___action86<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<FieldPattern<TypeRef>>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    v
}

pub fn ___action87<
    'input,
>(
    text: &'input str,
    ___0: FieldPattern<TypeRef>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> FieldPattern<TypeRef>
{
    (___0)
}

pub fn ___action88<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Pattern<TypeRef>>,
    e1: ::std::option::Option<Pattern<TypeRef>>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Pattern<TypeRef>>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action89<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Conversion>,
    e1: ::std::option::Option<Conversion>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Conversion>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action90<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<AssociatedType>
{
    vec![]
}

pub fn ___action91<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<AssociatedType>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<AssociatedType>
{
    v
}

pub fn ___action92<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<InternedString>
{
    vec![]
}

pub fn ___action93<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<InternedString>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<InternedString>
{
    v
}

pub fn ___action94<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> InternedString
{
    (___0)
}

pub fn ___action95<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(___0)
}

pub fn ___action96<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn ___action97<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeRef>,
    e1: ::std::option::Option<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action98<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(___0)
}

pub fn ___action99<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn ___action100<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<InternedString>
{
    Some(___0)
}

pub fn ___action101<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<InternedString>
{
    None
}

pub fn ___action102<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeRef>,
    e1: ::std::option::Option<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action103<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Symbol>,
    e1: ::std::option::Option<Symbol>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Symbol>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action104<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    vec![]
}

pub fn ___action105<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    v
}

pub fn ___action106<
    'input,
>(
    text: &'input str,
    ___0: ActionKind,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<ActionKind>
{
    Some(___0)
}

pub fn ___action107<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<ActionKind>
{
    None
}

pub fn ___action108<
    'input,
>(
    text: &'input str,
    ___0: Condition,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Condition>
{
    Some(___0)
}

pub fn ___action109<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Condition>
{
    None
}

pub fn ___action110<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Condition,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Condition
{
    (___0)
}

pub fn ___action111<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    vec![___0]
}

pub fn ___action112<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action113<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Alternative>,
    e1: ::std::option::Option<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action114<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<NonterminalString>,
    e1: ::std::option::Option<NonterminalString>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<NonterminalString>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action115<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeRef>
{
    Some(___0)
}

pub fn ___action116<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn ___action117<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    (___0)
}

pub fn ___action118<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(___0)
}

pub fn ___action119<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn ___action120<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Parameter>,
    e1: ::std::option::Option<Parameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Parameter>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action121<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeParameter>,
    e1: ::std::option::Option<TypeParameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeParameter>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action122<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![]
}

pub fn ___action123<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<GrammarItem>
{
    v
}

pub fn ___action124<
    'input,
>(
    text: &'input str,
    ___0: Vec<&'input str>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Vec<&'input str>>
{
    Some(___0)
}

pub fn ___action125<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Vec<&'input str>>
{
    None
}

pub fn ___action126<
    'input,
>(
    text: &'input str,
    ___0: Vec<Parameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Vec<Parameter>>
{
    Some(___0)
}

pub fn ___action127<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Vec<Parameter>>
{
    None
}

pub fn ___action128<
    'input,
>(
    text: &'input str,
    ___0: Vec<TypeParameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Vec<TypeParameter>>
{
    Some(___0)
}

pub fn ___action129<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Vec<TypeParameter>>
{
    None
}

pub fn ___action130<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> usize
{
    ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default()
}

pub fn ___action131<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> usize
{
    ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default()
}

pub fn ___action132<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Annotation>
{
    vec![]
}

pub fn ___action133<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Annotation>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Annotation>
{
    v
}

pub fn ___action134<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![]
}

pub fn ___action135<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<GrammarItem>
{
    v
}

pub fn ___action136<
    'input,
>(
    text: &'input str,
    ___0: GrammarItem,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![___0]
}

pub fn ___action137<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    e: GrammarItem,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<GrammarItem>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action138<
    'input,
>(
    text: &'input str,
    ___0: Annotation,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Annotation>
{
    vec![___0]
}

pub fn ___action139<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Annotation>,
    e: Annotation,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Annotation>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action140<
    'input,
>(
    text: &'input str,
    ___0: GrammarItem,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![___0]
}

pub fn ___action141<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    e: GrammarItem,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<GrammarItem>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action142<
    'input,
>(
    text: &'input str,
    ___0: TypeParameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeParameter>
{
    Some(___0)
}

pub fn ___action143<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeParameter>
{
    None
}

pub fn ___action144<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeParameter>
{
    vec![]
}

pub fn ___action145<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeParameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeParameter>
{
    v
}

pub fn ___action146<
    'input,
>(
    text: &'input str,
    ___0: TypeParameter,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeParameter
{
    (___0)
}

pub fn ___action147<
    'input,
>(
    text: &'input str,
    ___0: Parameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Parameter>
{
    Some(___0)
}

pub fn ___action148<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Parameter>
{
    None
}

pub fn ___action149<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Parameter>
{
    vec![]
}

pub fn ___action150<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Parameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Parameter>
{
    v
}

pub fn ___action151<
    'input,
>(
    text: &'input str,
    ___0: Parameter,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Parameter
{
    (___0)
}

pub fn ___action152<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<NonterminalString>
{
    Some(___0)
}

pub fn ___action153<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<NonterminalString>
{
    None
}

pub fn ___action154<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<NonterminalString>
{
    vec![]
}

pub fn ___action155<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<NonterminalString>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<NonterminalString>
{
    v
}

pub fn ___action156<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> NonterminalString
{
    (___0)
}

pub fn ___action157<
    'input,
>(
    text: &'input str,
    ___0: Alternative,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Alternative>
{
    Some(___0)
}

pub fn ___action158<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Alternative>
{
    None
}

pub fn ___action159<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Alternative>
{
    vec![]
}

pub fn ___action160<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Alternative>
{
    v
}

pub fn ___action161<
    'input,
>(
    text: &'input str,
    ___0: Alternative,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    (___0)
}

pub fn ___action162<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Symbol>
{
    Some(___0)
}

pub fn ___action163<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Symbol>
{
    None
}

pub fn ___action164<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    vec![]
}

pub fn ___action165<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    v
}

pub fn ___action166<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Symbol
{
    (___0)
}

pub fn ___action167<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeRef>
{
    Some(___0)
}

pub fn ___action168<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn ___action169<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    vec![]
}

pub fn ___action170<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    v
}

pub fn ___action171<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    (___0)
}

pub fn ___action172<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeRef>
{
    Some(___0)
}

pub fn ___action173<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn ___action174<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    vec![]
}

pub fn ___action175<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    v
}

pub fn ___action176<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    (___0)
}

pub fn ___action177<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<InternedString>
{
    vec![___0]
}

pub fn ___action178<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<InternedString>,
    e: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<InternedString>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action179<
    'input,
>(
    text: &'input str,
    ___0: AssociatedType,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<AssociatedType>
{
    vec![___0]
}

pub fn ___action180<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<AssociatedType>,
    e: AssociatedType,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<AssociatedType>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action181<
    'input,
>(
    text: &'input str,
    ___0: Conversion,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Conversion>
{
    Some(___0)
}

pub fn ___action182<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Conversion>
{
    None
}

pub fn ___action183<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Conversion>
{
    vec![]
}

pub fn ___action184<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Conversion>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Conversion>
{
    v
}

pub fn ___action185<
    'input,
>(
    text: &'input str,
    ___0: Conversion,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Conversion
{
    (___0)
}

pub fn ___action186<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Pattern<TypeRef>>
{
    Some(___0)
}

pub fn ___action187<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Pattern<TypeRef>>
{
    None
}

pub fn ___action188<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    vec![]
}

pub fn ___action189<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Pattern<TypeRef>>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    v
}

pub fn ___action190<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
    _: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Pattern<TypeRef>
{
    (___0)
}

pub fn ___action191<
    'input,
>(
    text: &'input str,
    ___0: FieldPattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    vec![___0]
}

pub fn ___action192<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<FieldPattern<TypeRef>>,
    e: FieldPattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action193<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    vec![___0]
}

pub fn ___action194<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Pattern<TypeRef>>,
    e: Pattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action195<
    'input,
>(
    text: &'input str,
    ___0: Conversion,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Conversion>
{
    vec![___0]
}

pub fn ___action196<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Conversion>,
    e: Conversion,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Conversion>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action197<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    vec![___0]
}

pub fn ___action198<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    e: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action199<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    vec![___0]
}

pub fn ___action200<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    e: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action201<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    vec![___0]
}

pub fn ___action202<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action203<
    'input,
>(
    text: &'input str,
    ___0: Alternative,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Alternative>
{
    vec![___0]
}

pub fn ___action204<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Alternative>,
    e: Alternative,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Alternative>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action205<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<NonterminalString>
{
    vec![___0]
}

pub fn ___action206<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<NonterminalString>,
    e: NonterminalString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<NonterminalString>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action207<
    'input,
>(
    text: &'input str,
    ___0: Parameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Parameter>
{
    vec![___0]
}

pub fn ___action208<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Parameter>,
    e: Parameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Parameter>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action209<
    'input,
>(
    text: &'input str,
    ___0: TypeParameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeParameter>
{
    vec![___0]
}

pub fn ___action210<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeParameter>,
    e: TypeParameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeParameter>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action211<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: ::std::vec::Vec<InternedString>,
    ___2: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Path
{
    let ___temp0 = ___action95(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action55(
        text,
        ___temp0,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action212<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<InternedString>,
    ___1: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Path
{
    let ___temp0 = ___action96(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action55(
        text,
        ___temp0,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action213<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: ::std::option::Option<InternedString>,
    ___2: Tok<'input>,
    ___3: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    let ___temp0 = ___action98(
        text,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action50(
        text,
        ___0,
        ___1,
        ___temp0,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action214<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: ::std::option::Option<InternedString>,
    ___2: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    let ___temp0 = ___action99(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action50(
        text,
        ___0,
        ___1,
        ___temp0,
        ___2,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action215<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: (NonterminalString, Vec<NonterminalString>),
    ___4: usize,
    ___5: ::std::option::Option<TypeRef>,
    ___6: Tok<'input>,
    ___7: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action118(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action13(
        text,
        ___0,
        ___temp0,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action216<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: (NonterminalString, Vec<NonterminalString>),
    ___3: usize,
    ___4: ::std::option::Option<TypeRef>,
    ___5: Tok<'input>,
    ___6: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action119(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action13(
        text,
        ___0,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action217<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: ::std::option::Option<Vec<Parameter>>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___9: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action124(
        text,
        ___7,
        ___lookbehind,
        ___lookahead,
    );
    ___action3(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___temp0,
        ___8,
        ___9,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action218<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: ::std::option::Option<Vec<Parameter>>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action125(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action3(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___temp0,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action219<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<TypeRef>
{
    let ___temp0 = ___action117(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action115(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action220<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: (NonterminalString, Vec<NonterminalString>),
    ___4: usize,
    ___5: Tok<'input>,
    ___6: TypeRef,
    ___7: Tok<'input>,
    ___8: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action219(
        text,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    );
    ___action215(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action221<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: (NonterminalString, Vec<NonterminalString>),
    ___4: usize,
    ___5: Tok<'input>,
    ___6: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action116(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action215(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action222<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: (NonterminalString, Vec<NonterminalString>),
    ___3: usize,
    ___4: Tok<'input>,
    ___5: TypeRef,
    ___6: Tok<'input>,
    ___7: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action219(
        text,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action216(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action223<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: (NonterminalString, Vec<NonterminalString>),
    ___3: usize,
    ___4: Tok<'input>,
    ___5: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action116(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action216(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action224<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: Condition,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::option::Option<Condition>
{
    let ___temp0 = ___action110(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action108(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action225<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: ::std::vec::Vec<Symbol>,
    ___2: Tok<'input>,
    ___3: Condition,
    ___4: ::std::option::Option<ActionKind>,
    ___5: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    let ___temp0 = ___action224(
        text,
        ___2,
        ___3,
        ___lookbehind,
        ___lookahead,
    );
    ___action20(
        text,
        ___0,
        ___1,
        ___temp0,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action226<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: ::std::vec::Vec<Symbol>,
    ___2: ::std::option::Option<ActionKind>,
    ___3: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    let ___temp0 = ___action109(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action20(
        text,
        ___0,
        ___1,
        ___temp0,
        ___2,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action227<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: Condition,
    ___3: ActionKind,
    ___4: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    let ___temp0 = ___action224(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action21(
        text,
        ___0,
        ___temp0,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action228<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: ActionKind,
    ___2: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    let ___temp0 = ___action109(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action21(
        text,
        ___0,
        ___temp0,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action229<
    'input,
>(
    text: &'input str,
    ___0: Alternative,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Alternative>
{
    let ___temp0 = ___action161(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action203(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action230<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Alternative>,
    ___1: Alternative,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Alternative>
{
    let ___temp0 = ___action161(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action204(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action231<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    let ___temp0 = ___action159(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action113(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action232<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Alternative>,
    ___1: ::std::option::Option<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    let ___temp0 = ___action160(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action113(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action233<
    'input,
>(
    text: &'input str,
    ___0: Conversion,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Conversion>
{
    let ___temp0 = ___action185(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action195(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action234<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Conversion>,
    ___1: Conversion,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Conversion>
{
    let ___temp0 = ___action185(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action196(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action235<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<Conversion>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Conversion>
{
    let ___temp0 = ___action183(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action89(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action236<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Conversion>,
    ___1: ::std::option::Option<Conversion>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Conversion>
{
    let ___temp0 = ___action184(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action89(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action237<
    'input,
>(
    text: &'input str,
    ___0: FieldPattern<TypeRef>,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    let ___temp0 = ___action87(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action191(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action238<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    ___1: FieldPattern<TypeRef>,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    let ___temp0 = ___action87(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action192(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action239<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___1: Tok<'input>,
    ___2: ::std::option::Option<FieldPattern<TypeRef>>,
    ___3: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    let ___temp0 = ___action85(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action63(
        text,
        ___0,
        ___1,
        ___temp0,
        ___2,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action240<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___1: Tok<'input>,
    ___2: ::std::vec::Vec<FieldPattern<TypeRef>>,
    ___3: ::std::option::Option<FieldPattern<TypeRef>>,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    let ___temp0 = ___action86(
        text,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action63(
        text,
        ___0,
        ___1,
        ___temp0,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action241<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___1: Tok<'input>,
    ___2: Tok<'input>,
    ___3: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    let ___temp0 = ___action85(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action64(
        text,
        ___0,
        ___1,
        ___temp0,
        ___2,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action242<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___1: Tok<'input>,
    ___2: ::std::vec::Vec<FieldPattern<TypeRef>>,
    ___3: Tok<'input>,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    let ___temp0 = ___action86(
        text,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action64(
        text,
        ___0,
        ___1,
        ___temp0,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action243<
    'input,
>(
    text: &'input str,
    ___0: Parameter,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Parameter>
{
    let ___temp0 = ___action151(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action207(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action244<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Parameter>,
    ___1: Parameter,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Parameter>
{
    let ___temp0 = ___action151(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action208(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action245<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<Parameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Parameter>
{
    let ___temp0 = ___action149(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action120(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action246<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Parameter>,
    ___1: ::std::option::Option<Parameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Parameter>
{
    let ___temp0 = ___action150(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action120(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action247<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<InternedString>
{
    let ___temp0 = ___action94(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action177(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action248<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<InternedString>,
    ___1: InternedString,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<InternedString>
{
    let ___temp0 = ___action94(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action178(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action249<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Path
{
    let ___temp0 = ___action92(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action211(
        text,
        ___0,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action250<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: ::std::vec::Vec<InternedString>,
    ___2: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Path
{
    let ___temp0 = ___action93(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action211(
        text,
        ___0,
        ___temp0,
        ___2,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action251<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Path
{
    let ___temp0 = ___action92(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action212(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action252<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<InternedString>,
    ___1: InternedString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Path
{
    let ___temp0 = ___action93(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action212(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action253<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<NonterminalString>
{
    let ___temp0 = ___action156(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action205(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action254<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<NonterminalString>,
    ___1: NonterminalString,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<NonterminalString>
{
    let ___temp0 = ___action156(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action206(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action255<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<NonterminalString>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<NonterminalString>
{
    let ___temp0 = ___action154(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action114(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action256<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<NonterminalString>,
    ___1: ::std::option::Option<NonterminalString>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<NonterminalString>
{
    let ___temp0 = ___action155(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action114(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action257<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    let ___temp0 = ___action190(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action193(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action258<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Pattern<TypeRef>>,
    ___1: Pattern<TypeRef>,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    let ___temp0 = ___action190(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action194(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action259<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<Pattern<TypeRef>>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Pattern<TypeRef>>
{
    let ___temp0 = ___action188(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action88(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action260<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Pattern<TypeRef>>,
    ___1: ::std::option::Option<Pattern<TypeRef>>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Pattern<TypeRef>>
{
    let ___temp0 = ___action189(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action88(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action261<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    let ___temp0 = ___action166(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action201(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action262<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Symbol>,
    ___1: Symbol,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<Symbol>
{
    let ___temp0 = ___action166(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action202(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action263<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<Symbol>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Symbol>
{
    let ___temp0 = ___action164(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action103(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action264<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Symbol>,
    ___1: ::std::option::Option<Symbol>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Symbol>
{
    let ___temp0 = ___action165(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action103(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action265<
    'input,
>(
    text: &'input str,
    ___0: TypeParameter,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeParameter>
{
    let ___temp0 = ___action146(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action209(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action266<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeParameter>,
    ___1: TypeParameter,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeParameter>
{
    let ___temp0 = ___action146(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action210(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action267<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<TypeParameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeParameter>
{
    let ___temp0 = ___action144(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action121(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action268<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeParameter>,
    ___1: ::std::option::Option<TypeParameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeParameter>
{
    let ___temp0 = ___action145(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action121(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action269<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    let ___temp0 = ___action171(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action199(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action270<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeRef>,
    ___1: TypeRef,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    let ___temp0 = ___action171(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action200(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action271<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action169(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action102(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action272<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeRef>,
    ___1: ::std::option::Option<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action170(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action102(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action273<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___1: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    let ___temp0 = ___action176(
        text,
        ___0,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action197(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action274<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeRef>,
    ___1: TypeRef,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ::std::vec::Vec<TypeRef>
{
    let ___temp0 = ___action176(
        text,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action198(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action275<
    'input,
>(
    text: &'input str,
    ___0: ::std::option::Option<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action174(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action97(
        text,
        ___temp0,
        ___0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action276<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeRef>,
    ___1: ::std::option::Option<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action175(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action97(
        text,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action277<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: ::std::vec::Vec<Symbol>,
    ___2: Tok<'input>,
    ___3: Condition,
    ___4: ActionKind,
    ___5: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    let ___temp0 = ___action106(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action225(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action278<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: ::std::vec::Vec<Symbol>,
    ___2: Tok<'input>,
    ___3: Condition,
    ___4: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    let ___temp0 = ___action107(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action225(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action279<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: ::std::vec::Vec<Symbol>,
    ___2: ActionKind,
    ___3: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    let ___temp0 = ___action106(
        text,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action226(
        text,
        ___0,
        ___1,
        ___temp0,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action280<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: ::std::vec::Vec<Symbol>,
    ___2: usize,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Alternative
{
    let ___temp0 = ___action107(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action226(
        text,
        ___0,
        ___1,
        ___temp0,
        ___2,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action281<
    'input,
>(
    text: &'input str,
    ___0: Alternative,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    let ___temp0 = ___action157(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action231(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action282<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    let ___temp0 = ___action158(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action231(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action283<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Alternative>,
    ___1: Alternative,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    let ___temp0 = ___action157(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action232(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action284<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Alternative>
{
    let ___temp0 = ___action158(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action232(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action285<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: ::std::option::Option<Vec<Parameter>>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action132(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action217(
        text,
        ___0,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action286<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: ::std::option::Option<Vec<Parameter>>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___9: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action133(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action217(
        text,
        ___0,
        ___temp0,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___9,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action287<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: ::std::option::Option<Vec<Parameter>>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action132(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action218(
        text,
        ___0,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action288<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: ::std::option::Option<Vec<Parameter>>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action133(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action218(
        text,
        ___0,
        ___temp0,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action289<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: usize,
    ___2: (NonterminalString, Vec<NonterminalString>),
    ___3: usize,
    ___4: Tok<'input>,
    ___5: TypeRef,
    ___6: Tok<'input>,
    ___7: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action132(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action220(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action290<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: (NonterminalString, Vec<NonterminalString>),
    ___4: usize,
    ___5: Tok<'input>,
    ___6: TypeRef,
    ___7: Tok<'input>,
    ___8: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action133(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action220(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action291<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: usize,
    ___2: (NonterminalString, Vec<NonterminalString>),
    ___3: usize,
    ___4: Tok<'input>,
    ___5: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action132(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action221(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action292<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: (NonterminalString, Vec<NonterminalString>),
    ___4: usize,
    ___5: Tok<'input>,
    ___6: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action133(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action221(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action293<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: (NonterminalString, Vec<NonterminalString>),
    ___2: usize,
    ___3: Tok<'input>,
    ___4: TypeRef,
    ___5: Tok<'input>,
    ___6: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action132(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action222(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action294<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: (NonterminalString, Vec<NonterminalString>),
    ___3: usize,
    ___4: Tok<'input>,
    ___5: TypeRef,
    ___6: Tok<'input>,
    ___7: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action133(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action222(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action295<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: (NonterminalString, Vec<NonterminalString>),
    ___2: usize,
    ___3: Tok<'input>,
    ___4: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action132(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action223(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action296<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: (NonterminalString, Vec<NonterminalString>),
    ___3: usize,
    ___4: Tok<'input>,
    ___5: Vec<Alternative>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action133(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action223(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action297<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: EnumToken,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action90(
        text,
        ___lookbehind,
        ___lookahead,
    );
    let ___temp1 = ___action90(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action56(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___temp1,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action298<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: EnumToken,
    ___5: ::std::vec::Vec<AssociatedType>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action90(
        text,
        ___lookbehind,
        ___lookahead,
    );
    let ___temp1 = ___action91(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action56(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___temp1,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action299<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: ::std::vec::Vec<AssociatedType>,
    ___5: EnumToken,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action91(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    let ___temp1 = ___action90(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action56(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___temp1,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action300<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: ::std::vec::Vec<AssociatedType>,
    ___5: EnumToken,
    ___6: ::std::vec::Vec<AssociatedType>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action91(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    let ___temp1 = ___action91(
        text,
        ___6,
        ___lookbehind,
        ___lookahead,
    );
    ___action56(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___temp1,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action301<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action90(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action57(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action302<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: ::std::vec::Vec<AssociatedType>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> GrammarItem
{
    let ___temp0 = ___action91(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action57(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action303<
    'input,
>(
    text: &'input str,
    ___0: Conversion,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Conversion>
{
    let ___temp0 = ___action181(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action235(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action304<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Conversion>
{
    let ___temp0 = ___action182(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action235(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action305<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Conversion>,
    ___1: Conversion,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Conversion>
{
    let ___temp0 = ___action181(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action236(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action306<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Conversion>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Conversion>
{
    let ___temp0 = ___action182(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action236(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action307<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___1: Tok<'input>,
    ___2: FieldPattern<TypeRef>,
    ___3: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    let ___temp0 = ___action83(
        text,
        ___2,
        ___lookbehind,
        ___lookahead,
    );
    ___action239(
        text,
        ___0,
        ___1,
        ___temp0,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action308<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___1: Tok<'input>,
    ___2: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    let ___temp0 = ___action84(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action239(
        text,
        ___0,
        ___1,
        ___temp0,
        ___2,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action309<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___1: Tok<'input>,
    ___2: ::std::vec::Vec<FieldPattern<TypeRef>>,
    ___3: FieldPattern<TypeRef>,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    let ___temp0 = ___action83(
        text,
        ___3,
        ___lookbehind,
        ___lookahead,
    );
    ___action240(
        text,
        ___0,
        ___1,
        ___2,
        ___temp0,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action310<
    'input,
>(
    text: &'input str,
    ___0: Path,
    ___1: Tok<'input>,
    ___2: ::std::vec::Vec<FieldPattern<TypeRef>>,
    ___3: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> PatternKind<TypeRef>
{
    let ___temp0 = ___action84(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action240(
        text,
        ___0,
        ___1,
        ___2,
        ___temp0,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action311<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: ::std::option::Option<Vec<Parameter>>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action122(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action285(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action312<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: ::std::option::Option<Vec<Parameter>>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action123(
        text,
        ___8,
        ___lookbehind,
        ___lookahead,
    );
    ___action285(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action313<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: ::std::option::Option<Vec<Parameter>>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action122(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action286(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action314<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: ::std::option::Option<Vec<Parameter>>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___9: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action123(
        text,
        ___9,
        ___lookbehind,
        ___lookahead,
    );
    ___action286(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action315<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: ::std::option::Option<Vec<Parameter>>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action122(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action287(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action316<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: ::std::option::Option<Vec<Parameter>>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action123(
        text,
        ___7,
        ___lookbehind,
        ___lookahead,
    );
    ___action287(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action317<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: ::std::option::Option<Vec<Parameter>>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action122(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action288(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action318<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: ::std::option::Option<Vec<Parameter>>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action123(
        text,
        ___8,
        ___lookbehind,
        ___lookahead,
    );
    ___action288(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action319<
    'input,
>(
    text: &'input str,
    ___0: Parameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Parameter>
{
    let ___temp0 = ___action147(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action245(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action320<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Parameter>
{
    let ___temp0 = ___action148(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action245(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action321<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Parameter>,
    ___1: Parameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Parameter>
{
    let ___temp0 = ___action147(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action246(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action322<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Parameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Parameter>
{
    let ___temp0 = ___action148(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action246(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action323<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action126(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action311(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action324<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action127(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action311(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action325<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action126(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action312(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action326<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action127(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action312(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action327<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: Vec<Parameter>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action126(
        text,
        ___6,
        ___lookbehind,
        ___lookahead,
    );
    ___action313(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___temp0,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action328<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action127(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action313(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___temp0,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action329<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: Vec<Parameter>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___9: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action126(
        text,
        ___6,
        ___lookbehind,
        ___lookahead,
    );
    ___action314(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___temp0,
        ___7,
        ___8,
        ___9,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action330<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action127(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action314(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___temp0,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action331<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action126(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action315(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action332<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action127(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action315(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action333<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action126(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action316(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action334<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: ::std::option::Option<Vec<TypeParameter>>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action127(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action316(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action335<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: Vec<Parameter>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action126(
        text,
        ___6,
        ___lookbehind,
        ___lookahead,
    );
    ___action317(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___temp0,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action336<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action127(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action317(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___temp0,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action337<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: Vec<Parameter>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action126(
        text,
        ___6,
        ___lookbehind,
        ___lookahead,
    );
    ___action318(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___temp0,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action338<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: ::std::option::Option<Vec<TypeParameter>>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action127(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action318(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___temp0,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action339<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action323(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action340<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action323(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action341<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action324(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action342<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action324(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action343<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action325(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action344<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action325(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action345<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action326(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action346<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action326(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action347<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<Parameter>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action327(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action348<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action327(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action349<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action328(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action350<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action328(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action351<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<Parameter>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___9: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action329(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___8,
        ___9,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action352<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action329(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action353<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action330(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action354<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action330(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action355<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action331(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action356<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action331(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action357<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action332(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action358<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action332(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action359<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action333(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action360<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action333(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action361<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___4,
        ___lookbehind,
        ___lookahead,
    );
    ___action334(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action362<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Tok<'input>,
    ___5: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action334(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___temp0,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action363<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<Parameter>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action335(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action364<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action335(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action365<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action336(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action366<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action336(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action367<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<Parameter>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action337(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action368<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action337(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action369<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action128(
        text,
        ___5,
        ___lookbehind,
        ___lookahead,
    );
    ___action338(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action370<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action129(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action338(
        text,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___temp0,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action371<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: InternedString,
    ___2: Tok<'input>,
    ___3: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    let ___temp0 = ___action100(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action213(
        text,
        ___0,
        ___temp0,
        ___2,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action372<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: Tok<'input>,
    ___2: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    let ___temp0 = ___action101(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action213(
        text,
        ___0,
        ___temp0,
        ___1,
        ___2,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action373<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: InternedString,
    ___2: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    let ___temp0 = ___action100(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action214(
        text,
        ___0,
        ___temp0,
        ___2,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action374<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
    ___1: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> TypeRef
{
    let ___temp0 = ___action101(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action214(
        text,
        ___0,
        ___temp0,
        ___1,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action375<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<NonterminalString>
{
    let ___temp0 = ___action152(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action255(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action376<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<NonterminalString>
{
    let ___temp0 = ___action153(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action255(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action377<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<NonterminalString>,
    ___1: NonterminalString,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<NonterminalString>
{
    let ___temp0 = ___action152(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action256(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action378<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<NonterminalString>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<NonterminalString>
{
    let ___temp0 = ___action153(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action256(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action379<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Pattern<TypeRef>>
{
    let ___temp0 = ___action186(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action259(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action380<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Pattern<TypeRef>>
{
    let ___temp0 = ___action187(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action259(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action381<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Pattern<TypeRef>>,
    ___1: Pattern<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Pattern<TypeRef>>
{
    let ___temp0 = ___action186(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action260(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action382<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Pattern<TypeRef>>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Pattern<TypeRef>>
{
    let ___temp0 = ___action187(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action260(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action383<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ExprSymbol
{
    let ___temp0 = ___action104(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action31(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action384<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Symbol>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> ExprSymbol
{
    let ___temp0 = ___action105(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action31(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action385<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Symbol>
{
    let ___temp0 = ___action162(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action263(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action386<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Symbol>
{
    let ___temp0 = ___action163(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action263(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action387<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Symbol>,
    ___1: Symbol,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Symbol>
{
    let ___temp0 = ___action162(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action264(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action388<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Symbol>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<Symbol>
{
    let ___temp0 = ___action163(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action264(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action389<
    'input,
>(
    text: &'input str,
    ___0: TypeParameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeParameter>
{
    let ___temp0 = ___action142(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action267(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action390<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeParameter>
{
    let ___temp0 = ___action143(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action267(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action391<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeParameter>,
    ___1: TypeParameter,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeParameter>
{
    let ___temp0 = ___action142(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action268(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action392<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeParameter>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeParameter>
{
    let ___temp0 = ___action143(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action268(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action393<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action167(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action271(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action394<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action168(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action271(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action395<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeRef>,
    ___1: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action167(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action272(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action396<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action168(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action272(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action397<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action172(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action275(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action398<
    'input,
>(
    text: &'input str,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action173(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action275(
        text,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action399<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeRef>,
    ___1: TypeRef,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action172(
        text,
        ___1,
        ___lookbehind,
        ___lookahead,
    );
    ___action276(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action400<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<TypeRef>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Vec<TypeRef>
{
    let ___temp0 = ___action173(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action276(
        text,
        ___0,
        ___temp0,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action401<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<TypeParameter>,
    ___4: Vec<Parameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action339(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action402<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action339(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action403<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<Parameter>,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action340(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action404<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action340(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action405<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<TypeParameter>,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action341(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action406<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action341(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action407<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<&'input str>,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action342(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action408<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action342(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action409<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<TypeParameter>,
    ___4: Vec<Parameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action343(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action410<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action343(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action411<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<Parameter>,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action344(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action412<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action344(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action413<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<TypeParameter>,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action345(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action414<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action345(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action415<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<&'input str>,
    ___4: Tok<'input>,
    ___5: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action346(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action416<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action346(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action417<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action347(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action418<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<Parameter>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action347(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action419<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action348(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action420<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action348(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action421<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action349(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action422<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action349(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action423<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action350(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action424<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action350(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action425<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action351(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action426<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<Parameter>,
    ___7: Vec<&'input str>,
    ___8: Tok<'input>,
    ___9: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action351(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___9,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action427<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action352(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action428<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<Parameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action352(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action429<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action353(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action430<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<&'input str>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action353(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action431<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<&'input str>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action354(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action432<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<&'input str>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action354(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action433<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<TypeParameter>,
    ___4: Vec<Parameter>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action355(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action434<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action355(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action435<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<Parameter>,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action356(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action436<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action356(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action437<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<TypeParameter>,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action357(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action438<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action357(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action439<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action358(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action440<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action358(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action441<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<TypeParameter>,
    ___4: Vec<Parameter>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action359(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action442<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action359(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action443<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<Parameter>,
    ___4: Tok<'input>,
    ___5: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action360(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action444<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action360(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action445<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Vec<TypeParameter>,
    ___4: Tok<'input>,
    ___5: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action361(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action446<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action361(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action447<
    'input,
>(
    text: &'input str,
    ___0: usize,
    ___1: Tok<'input>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action362(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action448<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Tok<'input>,
    ___5: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action362(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action449<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action363(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action450<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<Parameter>,
    ___7: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action363(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action451<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action364(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action452<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action364(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action453<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action365(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action454<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action365(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action455<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action366(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action456<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Tok<'input>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action366(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action457<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action367(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action458<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Vec<Parameter>,
    ___7: Tok<'input>,
    ___8: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action367(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___8,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action459<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<Parameter>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action368(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action460<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<Parameter>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action368(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action461<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Vec<TypeParameter>,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action369(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action462<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Vec<TypeParameter>,
    ___6: Tok<'input>,
    ___7: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action369(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___7,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action463<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Annotation>,
    ___1: usize,
    ___2: Tok<'input>,
    ___3: usize,
    ___4: Tok<'input>,
    ___5: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action134(
        text,
        ___lookbehind,
        ___lookahead,
    );
    ___action370(
        text,
        ___temp0,
        ___0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___lookbehind,
        ___lookahead,
    )
}

pub fn ___action464<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<GrammarItem>,
    ___1: ::std::vec::Vec<Annotation>,
    ___2: usize,
    ___3: Tok<'input>,
    ___4: usize,
    ___5: Tok<'input>,
    ___6: ::std::vec::Vec<GrammarItem>,
    ___lookbehind: &Option<usize>,
    ___lookahead: &Option<(usize, Tok<'input>, usize)>,
) -> Grammar
{
    let ___temp0 = ___action135(
        text,
        ___0,
        ___lookbehind,
        ___lookahead,
    );
    ___action370(
        text,
        ___temp0,
        ___1,
        ___2,
        ___3,
        ___4,
        ___5,
        ___6,
        ___lookbehind,
        ___lookahead,
    )
}

pub trait ___ToTriple<'input, > {
    type Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),Self::Error>;
}

impl<'input, > ___ToTriple<'input, > for (usize, Tok<'input>, usize) {
    type Error = tok::Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),tok::Error> {
        Ok(value)
    }
}
impl<'input, > ___ToTriple<'input, > for Result<(usize, Tok<'input>, usize),tok::Error> {
    type Error = tok::Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),tok::Error> {
        value
    }
}
