#![allow(unused_imports)]
#![allow(unused_variables)]
use intern::{intern, InternedString};
use grammar::parse_tree::*;
use grammar::pattern::*;
use std::iter::once;
use tok::{self, Tok};
use util::strip;
extern crate lalrpop_util as ___lalrpop_util;
use self::___lalrpop_util::ParseError as ___ParseError;

mod ___parse___Grammar {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as ___lalrpop_util;
    use self::___lalrpop_util::ParseError as ___ParseError;
    use super::___ToTriple;
    pub fn parse_Grammar<
        'input,
        ___TOKEN: ___ToTriple<'input, Error=tok::Error>,
        ___TOKENS: IntoIterator<Item=___TOKEN>,
    >(
        text: &'input str,
        ___tokens: ___TOKENS,
    ) -> Result<Grammar, ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let ___tokens = ___tokens.into_iter();
        let mut ___tokens = ___tokens.map(|t| ___ToTriple::to_triple(t));
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match try!(___state0(text, None, &mut ___tokens, ___lookahead)) {
            (_, Some(___lookahead), _) => {
                Err(___ParseError::ExtraToken { token: ___lookahead })
            }
            (_, None, ___Nonterminal::______Grammar(___nt)) => {
                Ok(___nt)
            }
            _ => unreachable!(),
        }
    }

    #[allow(dead_code)]
    pub enum ___Nonterminal<'input> {
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        _28_22if_22_20_3cCond_3e_29(Condition),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        _28_3cAlternative_3e_20_22_2c_22_29(Alternative),
        _28_3cAlternative_3e_20_22_2c_22_29_2a(::std::vec::Vec<Alternative>),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _40L(usize),
        _40R(usize),
        Action(ActionKind),
        Action_3f(::std::option::Option<ActionKind>),
        Algorithm(Algorithm),
        Algorithm_3f(::std::option::Option<Algorithm>),
        Alternative(Alternative),
        Alternative_3f(::std::option::Option<Alternative>),
        Alternatives(Vec<Alternative>),
        Annotation(Annotation),
        Annotation_2a(::std::vec::Vec<Annotation>),
        AssociatedType(AssociatedType),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        Comma_3cAlternative_3e(Vec<Alternative>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        Cond(Condition),
        CondOp(ConditionOp),
        Conversion(Conversion),
        Conversion_3f(::std::option::Option<Conversion>),
        EnumToken(EnumToken),
        Escape(InternedString),
        ExprSymbol(ExprSymbol),
        ExternToken(GrammarItem),
        FieldPattern(FieldPattern<TypeRef>),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        Grammar(Grammar),
        GrammarItem(GrammarItem),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        GrammarParameter(Parameter),
        GrammarParameter_3f(::std::option::Option<Parameter>),
        GrammarParameters(Vec<Parameter>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        GrammarTypeParameters(Vec<TypeParameter>),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        Id(InternedString),
        Lifetime(InternedString),
        Lifetime_3f(::std::option::Option<InternedString>),
        MacroId(NonterminalString),
        Nonterminal(GrammarItem),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        NotMacroId(NonterminalString),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        Path(Path),
        Pattern(Pattern<TypeRef>),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        QuotedTerminal(TerminalString),
        RegexLiteral(InternedString),
        RepeatOp(RepeatOp),
        StringLiteral(InternedString),
        Symbol(Symbol),
        Symbol_2a(::std::vec::Vec<Symbol>),
        Symbol_2b(::std::vec::Vec<Symbol>),
        Symbol0(Symbol),
        Symbol1(Symbol),
        Symbol_3f(::std::option::Option<Symbol>),
        SymbolKind1(SymbolKind),
        Terminal(TerminalString),
        TypeParameter(TypeParameter),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        TypeRef(TypeRef),
        TypeRef_3f(::std::option::Option<TypeRef>),
        TypeRefOrLifetime(TypeRef),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        Use(GrammarItem),
        Use_2a(::std::vec::Vec<GrammarItem>),
        ______Grammar(Grammar),
        ______Pattern(Pattern<TypeRef>),
        ______TypeRef(TypeRef),
    }

    // State 0
    //   Grammar = (*) Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //   Use* = (*) ["grammar"]
    //   Use* = (*) ["use"]
    //   Use* = (*) Use* Use ["grammar"]
    //   Use* = (*) Use* Use ["use"]
    //   ___Grammar = (*) Grammar [EOF]
    //
    //   "grammar" -> Reduce(Use* =  => Call(ActionFn(135));)
    //   "use" -> Reduce(Use* =  => Call(ActionFn(135));)
    //
    //   Grammar -> S1
    //   Use* -> S2
    pub fn ___state0<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___nt = super::___action135(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Use_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Grammar(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Use_2a(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
    }

    // State 1
    //   ___Grammar = Grammar (*) [EOF]
    //
    //   EOF -> Reduce(___Grammar = Grammar => Call(ActionFn(0));)
    //
    pub fn ___state1<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Grammar>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action0(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::______Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 2
    //   @L = (*) ["grammar"]
    //   Grammar = Use* (*) @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //   Use = (*) "use" ";" ["grammar"]
    //   Use = (*) "use" ";" ["use"]
    //   Use* = Use* (*) Use ["grammar"]
    //   Use* = Use* (*) Use ["use"]
    //
    //   "grammar" -> Reduce(@L =  => Lookahead;)
    //   "use" -> Shift(S5)
    //
    //   @L -> S3
    //   Use -> S4
    pub fn ___state2<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Grammar, _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 3
    //   Grammar = Use* @L (*) "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //
    //   "grammar" -> Shift(S6)
    //
    pub fn ___state3<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Grammar, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 4
    //   Use* = Use* Use (*) ["grammar"]
    //   Use* = Use* Use (*) ["use"]
    //
    //   "grammar" -> Reduce(Use* = Use*, Use => Call(ActionFn(136));)
    //   "use" -> Reduce(Use* = Use*, Use => Call(ActionFn(136));)
    //
    pub fn ___state4<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action136(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Use_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 5
    //   Use = "use" (*) ";" ["grammar"]
    //   Use = "use" (*) ";" ["use"]
    //   Use = "use" (*) ";" [EOF]
    //   Use = "use" (*) ";" ["#"]
    //   Use = "use" (*) ";" ["Escape"]
    //   Use = "use" (*) ";" ["Id"]
    //   Use = "use" (*) ";" ["MacroId"]
    //   Use = "use" (*) ";" ["extern"]
    //   Use = "use" (*) ";" ["pub"]
    //   Use = "use" (*) ";" ["use"]
    //
    //   ";" -> Shift(S7)
    //
    pub fn ___state5<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 6
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["["]
    //   @R = (*) ["where"]
    //   Grammar = Use* @L "grammar" (*) @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "[" -> Reduce(@R =  => Lookbehind;)
    //   "where" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S8
    pub fn ___state6<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::LeftBracket, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state8(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 7
    //   Use = "use" ";" (*) ["grammar"]
    //   Use = "use" ";" (*) ["use"]
    //   Use = "use" ";" (*) [EOF]
    //   Use = "use" ";" (*) ["#"]
    //   Use = "use" ";" (*) ["Escape"]
    //   Use = "use" ";" (*) ["Id"]
    //   Use = "use" ";" (*) ["MacroId"]
    //   Use = "use" ";" (*) ["extern"]
    //   Use = "use" ";" (*) ["pub"]
    //   Use = "use" ";" (*) ["use"]
    //
    //   EOF -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "#" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "Escape" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "Id" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "MacroId" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "extern" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "grammar" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "pub" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //   "use" -> Reduce(Use = "use", ";" => Call(ActionFn(13));)
    //
    pub fn ___state7<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Grammar, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action13(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Use(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 8
    //   Grammar = Use* @L "grammar" @R (*) GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["["]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["where"]
    //   GrammarTypeParameters? = (*) ["("]
    //   GrammarTypeParameters? = (*) [";"]
    //   GrammarTypeParameters? = (*) ["["]
    //   GrammarTypeParameters? = (*) ["where"]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters ["("]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters [";"]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters ["["]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters ["where"]
    //
    //   "(" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(134));)
    //   ";" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(134));)
    //   "<" -> Shift(S11)
    //   "[" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(134));)
    //   "where" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(134));)
    //
    //   GrammarTypeParameters -> S9
    //   GrammarTypeParameters? -> S10
    pub fn ___state8<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state11(text, ___lookbehind, ___tokens, ___sym4));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LeftBracket, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___nt = super::___action134(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::GrammarTypeParameters_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarTypeParameters(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state9(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::GrammarTypeParameters_3f(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state10(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 9
    //   GrammarTypeParameters? = GrammarTypeParameters (*) ["("]
    //   GrammarTypeParameters? = GrammarTypeParameters (*) [";"]
    //   GrammarTypeParameters? = GrammarTypeParameters (*) ["["]
    //   GrammarTypeParameters? = GrammarTypeParameters (*) ["where"]
    //
    //   "(" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(133));)
    //   ";" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(133));)
    //   "[" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(133));)
    //   "where" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(133));)
    //
    pub fn ___state9<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LeftBracket, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action133(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarTypeParameters_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 10
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? (*) GrammarParameters? "where"? Algorithm? ";" GrammarItem* [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["["]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //   GrammarParameters? = (*) [";"]
    //   GrammarParameters? = (*) ["["]
    //   GrammarParameters? = (*) ["where"]
    //   GrammarParameters? = (*) GrammarParameters [";"]
    //   GrammarParameters? = (*) GrammarParameters ["["]
    //   GrammarParameters? = (*) GrammarParameters ["where"]
    //
    //   "(" -> Shift(S14)
    //   ";" -> Reduce(GrammarParameters? =  => Call(ActionFn(132));)
    //   "[" -> Reduce(GrammarParameters? =  => Call(ActionFn(132));)
    //   "where" -> Reduce(GrammarParameters? =  => Call(ActionFn(132));)
    //
    //   GrammarParameters -> S12
    //   GrammarParameters? -> S13
    pub fn ___state10<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state14(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LeftBracket, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___nt = super::___action132(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::GrammarParameters_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarParameters(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state12(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::GrammarParameters_3f(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state13(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 11
    //   (<TypeParameter> ",")* = (*) [">"]
    //   (<TypeParameter> ",")* = (*) ["Id"]
    //   (<TypeParameter> ",")* = (*) ["Lifetime"]
    //   (<TypeParameter> ",")* = (*) ["MacroId"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") [">"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") ["Id"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") ["Lifetime"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") ["MacroId"]
    //   Comma<TypeParameter> = (*) (<TypeParameter> ",")* TypeParameter? [">"]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["["]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["where"]
    //
    //   ">" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(139));)
    //   "Id" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(139));)
    //   "Lifetime" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(139));)
    //   "MacroId" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(139));)
    //
    //   (<TypeParameter> ",")* -> S15
    //   Comma<TypeParameter> -> S16
    pub fn ___state11<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action139(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state15(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cTypeParameter_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state16(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 12
    //   GrammarParameters? = GrammarParameters (*) [";"]
    //   GrammarParameters? = GrammarParameters (*) ["["]
    //   GrammarParameters? = GrammarParameters (*) ["where"]
    //
    //   ";" -> Reduce(GrammarParameters? = GrammarParameters => Call(ActionFn(131));)
    //   "[" -> Reduce(GrammarParameters? = GrammarParameters => Call(ActionFn(131));)
    //   "where" -> Reduce(GrammarParameters? = GrammarParameters => Call(ActionFn(131));)
    //
    pub fn ___state12<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LeftBracket, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action131(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarParameters_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 13
    //   "where"? = (*) [";"]
    //   "where"? = (*) ["["]
    //   "where"? = (*) "where" [";"]
    //   "where"? = (*) "where" ["["]
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? (*) "where"? Algorithm? ";" GrammarItem* [EOF]
    //
    //   ";" -> Reduce("where"? =  => Call(ActionFn(130));)
    //   "[" -> Reduce("where"? =  => Call(ActionFn(130));)
    //   "where" -> Shift(S18)
    //
    //   "where"? -> S17
    pub fn ___state13<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        ___sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Where(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok0));
                ___result = try!(___state18(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LeftBracket, _)) => {
                let ___nt = super::___action130(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22where_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22where_22_3f(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 14
    //   (<GrammarParameter> ",")* = (*) [")"]
    //   (<GrammarParameter> ",")* = (*) ["Id"]
    //   (<GrammarParameter> ",")* = (*) ["MacroId"]
    //   (<GrammarParameter> ",")* = (*) (<GrammarParameter> ",")* (<GrammarParameter> ",") [")"]
    //   (<GrammarParameter> ",")* = (*) (<GrammarParameter> ",")* (<GrammarParameter> ",") ["Id"]
    //   (<GrammarParameter> ",")* = (*) (<GrammarParameter> ",")* (<GrammarParameter> ",") ["MacroId"]
    //   Comma<GrammarParameter> = (*) (<GrammarParameter> ",")* GrammarParameter? [")"]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" ["["]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" ["where"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",")* =  => Call(ActionFn(144));)
    //   "Id" -> Reduce((<GrammarParameter> ",")* =  => Call(ActionFn(144));)
    //   "MacroId" -> Reduce((<GrammarParameter> ",")* =  => Call(ActionFn(144));)
    //
    //   (<GrammarParameter> ",")* -> S19
    //   Comma<GrammarParameter> -> S20
    pub fn ___state14<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action144(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state19(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cGrammarParameter_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state20(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 15
    //   (<TypeParameter> ",") = (*) TypeParameter "," [">"]
    //   (<TypeParameter> ",") = (*) TypeParameter "," ["Id"]
    //   (<TypeParameter> ",") = (*) TypeParameter "," ["Lifetime"]
    //   (<TypeParameter> ",") = (*) TypeParameter "," ["MacroId"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") [">"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") ["Id"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") ["Lifetime"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") ["MacroId"]
    //   Comma<TypeParameter> = (<TypeParameter> ",")* (*) TypeParameter? [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   TypeParameter = (*) Id [","]
    //   TypeParameter = (*) Id [">"]
    //   TypeParameter = (*) Lifetime [","]
    //   TypeParameter = (*) Lifetime [">"]
    //   TypeParameter? = (*) [">"]
    //   TypeParameter? = (*) TypeParameter [">"]
    //
    //   ">" -> Reduce(TypeParameter? =  => Call(ActionFn(138));)
    //   "Id" -> Shift(S26)
    //   "Lifetime" -> Shift(S27)
    //   "MacroId" -> Shift(S28)
    //
    //   (<TypeParameter> ",") -> S21
    //   Id -> S22
    //   Lifetime -> S23
    //   TypeParameter -> S24
    //   TypeParameter? -> S25
    pub fn ___state15<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action138(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::TypeParameter_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state21(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state22(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state23(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeParameter(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeParameter_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state25(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 16
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["("]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" [";"]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["["]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["where"]
    //
    //   ">" -> Shift(S29)
    //
    pub fn ___state16<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state29(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 17
    //   Algorithm = (*) "[" @L StringLiteral @R "]" [";"]
    //   Algorithm? = (*) [";"]
    //   Algorithm? = (*) Algorithm [";"]
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? (*) Algorithm? ";" GrammarItem* [EOF]
    //
    //   ";" -> Reduce(Algorithm? =  => Call(ActionFn(128));)
    //   "[" -> Shift(S32)
    //
    //   Algorithm -> S30
    //   Algorithm? -> S31
    pub fn ___state17<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        ___sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        ___sym6: &mut Option<::std::option::Option<Vec<&'input str>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBracket, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::Semi, _)) => {
                let ___nt = super::___action128(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Algorithm_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Algorithm(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state30(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Algorithm_3f(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state31(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 18
    //   "where"? = "where" (*) [";"]
    //   "where"? = "where" (*) ["["]
    //
    //   ";" -> Reduce("where"? = "where" => Call(ActionFn(129));)
    //   "[" -> Reduce("where"? = "where" => Call(ActionFn(129));)
    //
    pub fn ___state18<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Vec<&'input str>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LeftBracket, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action129(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_22where_22_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 19
    //   (<GrammarParameter> ",") = (*) GrammarParameter "," [")"]
    //   (<GrammarParameter> ",") = (*) GrammarParameter "," ["Id"]
    //   (<GrammarParameter> ",") = (*) GrammarParameter "," ["MacroId"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (*) (<GrammarParameter> ",") [")"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (*) (<GrammarParameter> ",") ["Id"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (*) (<GrammarParameter> ",") ["MacroId"]
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")* (*) GrammarParameter? [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [","]
    //   GrammarParameter? = (*) [")"]
    //   GrammarParameter? = (*) GrammarParameter [")"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //
    //   ")" -> Reduce(GrammarParameter? =  => Call(ActionFn(143));)
    //   "Id" -> Shift(S26)
    //   "MacroId" -> Shift(S28)
    //
    //   (<GrammarParameter> ",") -> S33
    //   GrammarParameter -> S34
    //   GrammarParameter? -> S35
    //   Id -> S36
    pub fn ___state19<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action143(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::GrammarParameter_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state33(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::GrammarParameter(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state34(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::GrammarParameter_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state35(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 20
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" [";"]
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" ["["]
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" ["where"]
    //
    //   ")" -> Shift(S37)
    //
    pub fn ___state20<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state37(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 21
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) [">"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) ["Id"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) ["Lifetime"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) ["MacroId"]
    //
    //   ">" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(140));)
    //   "Id" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(140));)
    //   "Lifetime" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(140));)
    //   "MacroId" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(140));)
    //
    pub fn ___state21<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
        ___sym1: &mut Option<TypeParameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action140(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 22
    //   TypeParameter = Id (*) [","]
    //   TypeParameter = Id (*) [">"]
    //
    //   "," -> Reduce(TypeParameter = Id => Call(ActionFn(7));)
    //   ">" -> Reduce(TypeParameter = Id => Call(ActionFn(7));)
    //
    pub fn ___state22<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action7(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeParameter(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 23
    //   TypeParameter = Lifetime (*) [","]
    //   TypeParameter = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeParameter = Lifetime => Call(ActionFn(6));)
    //   ">" -> Reduce(TypeParameter = Lifetime => Call(ActionFn(6));)
    //
    pub fn ___state23<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action6(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeParameter(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 24
    //   (<TypeParameter> ",") = TypeParameter (*) "," [">"]
    //   (<TypeParameter> ",") = TypeParameter (*) "," ["Id"]
    //   (<TypeParameter> ",") = TypeParameter (*) "," ["Lifetime"]
    //   (<TypeParameter> ",") = TypeParameter (*) "," ["MacroId"]
    //   TypeParameter? = TypeParameter (*) [">"]
    //
    //   "," -> Shift(S38)
    //   ">" -> Reduce(TypeParameter? = TypeParameter => Call(ActionFn(137));)
    //
    pub fn ___state24<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeParameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state38(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action137(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeParameter_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 25
    //   Comma<TypeParameter> = (<TypeParameter> ",")* TypeParameter? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeParameter> = (<TypeParameter> ",")*, TypeParameter? => Call(ActionFn(124));)
    //
    pub fn ___state25<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
        ___sym1: &mut Option<::std::option::Option<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action124(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeParameter_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 26
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) [":"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["]"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["="]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["="]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) [";"]
    //   Id = "Id" (*) ["<"]
    //
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ";" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "=" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "]" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "{" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //
    pub fn ___state26<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::RightBracket, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 27
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //
    //   "#" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "&" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "(" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "," -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "::" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   ">" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //
    pub fn ___state27<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action77(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 28
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) [":"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) ["]"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) ["="]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) ["="]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) [";"]
    //   Id = "MacroId" (*) ["<"]
    //
    //   ")" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "," -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "::" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   ";" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "<" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "=" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   ">" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "]" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "{" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //
    pub fn ___state28<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::RightBracket, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 29
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["("]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) [";"]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["["]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["where"]
    //
    //   "(" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(5));)
    //   ";" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(5));)
    //   "[" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(5));)
    //   "where" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(5));)
    //
    pub fn ___state29<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeParameter>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LeftBracket, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action5(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarTypeParameters(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 30
    //   Algorithm? = Algorithm (*) [";"]
    //
    //   ";" -> Reduce(Algorithm? = Algorithm => Call(ActionFn(127));)
    //
    pub fn ___state30<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Algorithm>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Semi, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action127(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Algorithm_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 31
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? (*) ";" GrammarItem* [EOF]
    //
    //   ";" -> Shift(S39)
    //
    pub fn ___state31<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        ___sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        ___sym6: &mut Option<::std::option::Option<Vec<&'input str>>>,
        ___sym7: &mut Option<::std::option::Option<Algorithm>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym8 = &mut Some((___tok));
                ___result = try!(___state39(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 32
    //   @L = (*) ["StringLiteral"]
    //   Algorithm = "[" (*) @L StringLiteral @R "]" [";"]
    //
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S40
    pub fn ___state32<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state40(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 33
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (<GrammarParameter> ",") (*) [")"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (<GrammarParameter> ",") (*) ["Id"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (<GrammarParameter> ",") (*) ["MacroId"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",")* = (<GrammarParameter> ",")*, (<GrammarParameter> ",") => Call(ActionFn(145));)
    //   "Id" -> Reduce((<GrammarParameter> ",")* = (<GrammarParameter> ",")*, (<GrammarParameter> ",") => Call(ActionFn(145));)
    //   "MacroId" -> Reduce((<GrammarParameter> ",")* = (<GrammarParameter> ",")*, (<GrammarParameter> ",") => Call(ActionFn(145));)
    //
    pub fn ___state33<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Parameter>>,
        ___sym1: &mut Option<Parameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action145(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 34
    //   (<GrammarParameter> ",") = GrammarParameter (*) "," [")"]
    //   (<GrammarParameter> ",") = GrammarParameter (*) "," ["Id"]
    //   (<GrammarParameter> ",") = GrammarParameter (*) "," ["MacroId"]
    //   GrammarParameter? = GrammarParameter (*) [")"]
    //
    //   ")" -> Reduce(GrammarParameter? = GrammarParameter => Call(ActionFn(142));)
    //   "," -> Shift(S41)
    //
    pub fn ___state34<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Parameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state41(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action142(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarParameter_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 35
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")* GrammarParameter? (*) [")"]
    //
    //   ")" -> Reduce(Comma<GrammarParameter> = (<GrammarParameter> ",")*, GrammarParameter? => Call(ActionFn(123));)
    //
    pub fn ___state35<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Parameter>>,
        ___sym1: &mut Option<::std::option::Option<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action123(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cGrammarParameter_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 36
    //   GrammarParameter = Id (*) ":" TypeRef [")"]
    //   GrammarParameter = Id (*) ":" TypeRef [","]
    //
    //   ":" -> Shift(S42)
    //
    pub fn ___state36<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state42(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 37
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) [";"]
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) ["["]
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) ["where"]
    //
    //   ";" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => Call(ActionFn(8));)
    //   "[" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => Call(ActionFn(8));)
    //   "where" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => Call(ActionFn(8));)
    //
    pub fn ___state37<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Parameter>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LeftBracket, _)) |
            Some((_, Tok::Where(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action8(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarParameters(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 38
    //   (<TypeParameter> ",") = TypeParameter "," (*) [">"]
    //   (<TypeParameter> ",") = TypeParameter "," (*) ["Id"]
    //   (<TypeParameter> ",") = TypeParameter "," (*) ["Lifetime"]
    //   (<TypeParameter> ",") = TypeParameter "," (*) ["MacroId"]
    //
    //   ">" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(141));)
    //   "Id" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(141));)
    //   "Lifetime" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(141));)
    //   "MacroId" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(141));)
    //
    pub fn ___state38<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeParameter>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action141(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 39
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" (*) GrammarItem* [EOF]
    //   GrammarItem* = (*) [EOF]
    //   GrammarItem* = (*) ["#"]
    //   GrammarItem* = (*) ["Escape"]
    //   GrammarItem* = (*) ["Id"]
    //   GrammarItem* = (*) ["MacroId"]
    //   GrammarItem* = (*) ["extern"]
    //   GrammarItem* = (*) ["pub"]
    //   GrammarItem* = (*) ["use"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem [EOF]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["#"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["Escape"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["Id"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["MacroId"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["extern"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["pub"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["use"]
    //
    //   EOF -> Reduce(GrammarItem* =  => Call(ActionFn(125));)
    //   "#" -> Reduce(GrammarItem* =  => Call(ActionFn(125));)
    //   "Escape" -> Reduce(GrammarItem* =  => Call(ActionFn(125));)
    //   "Id" -> Reduce(GrammarItem* =  => Call(ActionFn(125));)
    //   "MacroId" -> Reduce(GrammarItem* =  => Call(ActionFn(125));)
    //   "extern" -> Reduce(GrammarItem* =  => Call(ActionFn(125));)
    //   "pub" -> Reduce(GrammarItem* =  => Call(ActionFn(125));)
    //   "use" -> Reduce(GrammarItem* =  => Call(ActionFn(125));)
    //
    //   GrammarItem* -> S43
    pub fn ___state39<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        ___sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        ___sym6: &mut Option<::std::option::Option<Vec<&'input str>>>,
        ___sym7: &mut Option<::std::option::Option<Algorithm>>,
        ___sym8: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___nt = super::___action125(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::GrammarItem_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym8.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::GrammarItem_2a(___nt) => {
                    let ___sym9 = &mut Some(___nt);
                    ___result = try!(___state43(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, ___sym9));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 40
    //   Algorithm = "[" @L (*) StringLiteral @R "]" [";"]
    //   StringLiteral = (*) "StringLiteral" ["]"]
    //
    //   "StringLiteral" -> Shift(S45)
    //
    //   StringLiteral -> S44
    pub fn ___state40<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state45(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state44(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 41
    //   (<GrammarParameter> ",") = GrammarParameter "," (*) [")"]
    //   (<GrammarParameter> ",") = GrammarParameter "," (*) ["Id"]
    //   (<GrammarParameter> ",") = GrammarParameter "," (*) ["MacroId"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",") = GrammarParameter, "," => Call(ActionFn(146));)
    //   "Id" -> Reduce((<GrammarParameter> ",") = GrammarParameter, "," => Call(ActionFn(146));)
    //   "MacroId" -> Reduce((<GrammarParameter> ",") = GrammarParameter, "," => Call(ActionFn(146));)
    //
    pub fn ___state41<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Parameter>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action146(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 42
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   GrammarParameter = Id ":" (*) TypeRef [")"]
    //   GrammarParameter = Id ":" (*) TypeRef [","]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "#" -> Shift(S49)
    //   "&" -> Shift(S50)
    //   "(" -> Shift(S51)
    //   "::" -> Shift(S52)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S46
    //   Path -> S47
    //   TypeRef -> S48
    pub fn ___state42<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 43
    //   @L = (*) ["extern"]
    //   Annotation* = (*) ["#"]
    //   Annotation* = (*) ["Escape"]
    //   Annotation* = (*) ["Id"]
    //   Annotation* = (*) ["MacroId"]
    //   Annotation* = (*) ["pub"]
    //   Annotation* = (*) Annotation* Annotation ["#"]
    //   Annotation* = (*) Annotation* Annotation ["Escape"]
    //   Annotation* = (*) Annotation* Annotation ["Id"]
    //   Annotation* = (*) Annotation* Annotation ["MacroId"]
    //   Annotation* = (*) Annotation* Annotation ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["use"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "}" [EOF]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "}" ["#"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "}" ["Escape"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "}" ["Id"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "}" ["extern"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "}" ["pub"]
    //   ExternToken = (*) @L "extern" @R "{" AssociatedType* "}" ["use"]
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? Algorithm? ";" GrammarItem* (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["#"]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["#"]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["#"]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem [EOF]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["#"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["Escape"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["Id"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["MacroId"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["extern"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["pub"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["use"]
    //   Nonterminal = (*) Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = (*) Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["#"]
    //   Nonterminal = (*) Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = (*) Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = (*) Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = (*) Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = (*) Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["#"]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   EOF -> Reduce(Grammar = Use*, @L, "grammar", @R, GrammarTypeParameters?, GrammarParameters?, "where"?, Algorithm?, ";", GrammarItem* => Call(ActionFn(3));)
    //   "#" -> Reduce(Annotation* =  => Call(ActionFn(121));)
    //   "Escape" -> Reduce(Annotation* =  => Call(ActionFn(121));)
    //   "Id" -> Reduce(Annotation* =  => Call(ActionFn(121));)
    //   "MacroId" -> Reduce(Annotation* =  => Call(ActionFn(121));)
    //   "extern" -> Reduce(@L =  => Lookahead;)
    //   "pub" -> Reduce(Annotation* =  => Call(ActionFn(121));)
    //   "use" -> Shift(S5)
    //
    //   @L -> S53
    //   Annotation* -> S54
    //   ExternToken -> S55
    //   GrammarItem -> S56
    //   Nonterminal -> S57
    //   Use -> S58
    pub fn ___state43<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        ___sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        ___sym6: &mut Option<::std::option::Option<Vec<&'input str>>>,
        ___sym7: &mut Option<::std::option::Option<Algorithm>>,
        ___sym8: &mut Option<Tok<'input>>,
        ___sym9: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Use(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym10 = &mut Some((___tok0));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym10));
            }
            Some((_, Tok::Extern, _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Pub, _)) => {
                let ___nt = super::___action121(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Annotation_2a(___nt));
            }
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___sym8 = ___sym8.take().unwrap();
                let ___sym9 = ___sym9.take().unwrap();
                let ___nt = super::___action3(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7, ___sym8, ___sym9);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Grammar(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym9.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state53(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::Annotation_2a(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state54(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::ExternToken(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state55(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::GrammarItem(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state56(text, ___lookbehind, ___tokens, ___lookahead, ___sym9, ___sym10));
                }
                ___Nonterminal::Nonterminal(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state57(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                ___Nonterminal::Use(___nt) => {
                    let ___sym10 = &mut Some(___nt);
                    ___result = try!(___state58(text, ___lookbehind, ___tokens, ___lookahead, ___sym10));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 44
    //   @R = (*) ["]"]
    //   Algorithm = "[" @L StringLiteral (*) @R "]" [";"]
    //
    //   "]" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S59
    pub fn ___state44<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightBracket, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state59(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 45
    //   StringLiteral = "StringLiteral" (*) ["]"]
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [";"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["if"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["if"]
    //   StringLiteral = "StringLiteral" (*) ["}"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) [";"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["}"]
    //
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   ";" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "=>" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "=>?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "=>@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "=>@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "RegexLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "]" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "if" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "}" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //
    pub fn ___state45<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightBracket, _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action82(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::StringLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 46
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id ["="]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [";"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(93));)
    //   "MacroId" -> Reduce((<Id> "::")* =  => Call(ActionFn(93));)
    //
    //   (<Id> "::")* -> S60
    pub fn ___state46<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action93(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state60(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 47
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path (*) ["="]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = Path (*) ["{"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = Path (*) [";"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [";"]
    //
    //   ")" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   ";" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   "<" -> Shift(S61)
    //   "=" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   "{" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //
    pub fn ___state47<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state61(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action53(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 48
    //   GrammarParameter = Id ":" TypeRef (*) [")"]
    //   GrammarParameter = Id ":" TypeRef (*) [","]
    //
    //   ")" -> Reduce(GrammarParameter = Id, ":", TypeRef => Call(ActionFn(9));)
    //   "," -> Reduce(GrammarParameter = Id, ":", TypeRef => Call(ActionFn(9));)
    //
    pub fn ___state48<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action9(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarParameter(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 49
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" ["="]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" ["{"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [";"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S62
    //   Symbol -> S63
    //   Symbol0 -> S64
    //   Symbol1 -> S65
    pub fn ___state49<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state62(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state63(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 50
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef ["="]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef ["{"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [";"]
    //
    //   "#" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "Lifetime" -> Shift(S27)
    //   "MacroId" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //
    //   Lifetime -> S66
    //   Lifetime? -> S67
    pub fn ___state50<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___nt = super::___action102(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Lifetime_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state66(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state67(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 51
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" ["="]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" ["{"]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //
    //   (<TypeRef> ",")* -> S68
    //   Comma<TypeRef> -> S69
    pub fn ___state51<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action164(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state68(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cTypeRef_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 52
    //   "::"? = "::" (*) ["Id"]
    //   "::"? = "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce("::"? = "::" => Call(ActionFn(96));)
    //   "MacroId" -> Reduce("::"? = "::" => Call(ActionFn(96));)
    //
    pub fn ___state52<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action96(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 53
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["#"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" ["use"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "}" [EOF]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "}" ["#"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "}" ["Id"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "}" ["extern"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "}" ["pub"]
    //   ExternToken = @L (*) "extern" @R "{" AssociatedType* "}" ["use"]
    //
    //   "extern" -> Shift(S70)
    //
    pub fn ___state53<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Extern, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state70(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 54
    //   "pub"? = (*) ["Escape"]
    //   "pub"? = (*) ["Id"]
    //   "pub"? = (*) ["MacroId"]
    //   "pub"? = (*) "pub" ["Escape"]
    //   "pub"? = (*) "pub" ["Id"]
    //   "pub"? = (*) "pub" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["#"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Escape"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["Id"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["MacroId"]
    //   Annotation = (*) "#" "[" @L Id @R "]" ["pub"]
    //   Annotation* = Annotation* (*) Annotation ["#"]
    //   Annotation* = Annotation* (*) Annotation ["Escape"]
    //   Annotation* = Annotation* (*) Annotation ["Id"]
    //   Annotation* = Annotation* (*) Annotation ["MacroId"]
    //   Annotation* = Annotation* (*) Annotation ["pub"]
    //   Nonterminal = Annotation* (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = Annotation* (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["#"]
    //   Nonterminal = Annotation* (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation* (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = Annotation* (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation* (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = Annotation* (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = Annotation* (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   "#" -> Shift(S73)
    //   "Escape" -> Reduce("pub"? =  => Call(ActionFn(120));)
    //   "Id" -> Reduce("pub"? =  => Call(ActionFn(120));)
    //   "MacroId" -> Reduce("pub"? =  => Call(ActionFn(120));)
    //   "pub" -> Shift(S74)
    //
    //   "pub"? -> S71
    //   Annotation -> S72
    pub fn ___state54<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state73(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Pub, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state74(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action120(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22pub_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22pub_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state71(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Annotation(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state72(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 55
    //   GrammarItem = ExternToken (*) [EOF]
    //   GrammarItem = ExternToken (*) ["#"]
    //   GrammarItem = ExternToken (*) ["Escape"]
    //   GrammarItem = ExternToken (*) ["Id"]
    //   GrammarItem = ExternToken (*) ["MacroId"]
    //   GrammarItem = ExternToken (*) ["extern"]
    //   GrammarItem = ExternToken (*) ["pub"]
    //   GrammarItem = ExternToken (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "#" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "Escape" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "Id" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "MacroId" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "extern" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "pub" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //   "use" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(11));)
    //
    pub fn ___state55<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action11(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 56
    //   GrammarItem* = GrammarItem* GrammarItem (*) [EOF]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["#"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["Escape"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["Id"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["MacroId"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["extern"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["pub"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(126));)
    //   "#" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(126));)
    //   "Escape" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(126));)
    //   "Id" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(126));)
    //   "MacroId" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(126));)
    //   "extern" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(126));)
    //   "pub" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(126));)
    //   "use" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(126));)
    //
    pub fn ___state56<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        ___sym1: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action126(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 57
    //   GrammarItem = Nonterminal (*) [EOF]
    //   GrammarItem = Nonterminal (*) ["#"]
    //   GrammarItem = Nonterminal (*) ["Escape"]
    //   GrammarItem = Nonterminal (*) ["Id"]
    //   GrammarItem = Nonterminal (*) ["MacroId"]
    //   GrammarItem = Nonterminal (*) ["extern"]
    //   GrammarItem = Nonterminal (*) ["pub"]
    //   GrammarItem = Nonterminal (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "#" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "Escape" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "Id" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "MacroId" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "extern" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "pub" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //   "use" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(12));)
    //
    pub fn ___state57<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action12(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 58
    //   GrammarItem = Use (*) [EOF]
    //   GrammarItem = Use (*) ["#"]
    //   GrammarItem = Use (*) ["Escape"]
    //   GrammarItem = Use (*) ["Id"]
    //   GrammarItem = Use (*) ["MacroId"]
    //   GrammarItem = Use (*) ["extern"]
    //   GrammarItem = Use (*) ["pub"]
    //   GrammarItem = Use (*) ["use"]
    //
    //   EOF -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "#" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "Escape" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "Id" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "MacroId" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "extern" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "pub" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //   "use" -> Reduce(GrammarItem = Use => Call(ActionFn(10));)
    //
    pub fn ___state58<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action10(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::GrammarItem(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 59
    //   Algorithm = "[" @L StringLiteral @R (*) "]" [";"]
    //
    //   "]" -> Shift(S75)
    //
    pub fn ___state59<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBracket, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state75(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 60
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["="]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id ["="]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" [";"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [";"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //
    //   "Id" -> Shift(S26)
    //   "MacroId" -> Shift(S28)
    //
    //   (<Id> "::") -> S76
    //   Id -> S77
    pub fn ___state60<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state76(text, ___lookbehind, ___tokens, ___lookahead, ___sym1, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state77(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 61
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" ["="]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" ["{"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [";"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S78
    //   Comma<TypeRefOrLifetime> -> S79
    pub fn ___state61<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action169(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state78(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state79(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 62
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["#"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["#"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral [")"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" [")"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [","]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [","]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [";"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["=>"]
    //   Escape = (*) "Escape" ["=>?"]
    //   Escape = (*) "Escape" ["=>@L"]
    //   Escape = (*) "Escape" ["=>@R"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   Escape = (*) "Escape" ["if"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [";"]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["=>"]
    //   QuotedTerminal = (*) RegexLiteral ["=>?"]
    //   QuotedTerminal = (*) RegexLiteral ["=>@L"]
    //   QuotedTerminal = (*) RegexLiteral ["=>@R"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["if"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [";"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["=>"]
    //   QuotedTerminal = (*) StringLiteral ["=>?"]
    //   QuotedTerminal = (*) StringLiteral ["=>@L"]
    //   QuotedTerminal = (*) StringLiteral ["=>@R"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["if"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [";"]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>?"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["if"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [";"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["if"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [";"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [";"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["if"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [";"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["=>"]
    //   SymbolKind1 = (*) Escape ["=>?"]
    //   SymbolKind1 = (*) Escape ["=>@L"]
    //   SymbolKind1 = (*) Escape ["=>@R"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["if"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [";"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [";"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>?"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["if"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [";"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["if"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [";"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["=>"]
    //   SymbolKind1 = (*) "@L" ["=>?"]
    //   SymbolKind1 = (*) "@L" ["=>@L"]
    //   SymbolKind1 = (*) "@L" ["=>@R"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["if"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [";"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["=>"]
    //   SymbolKind1 = (*) "@R" ["=>?"]
    //   SymbolKind1 = (*) "@R" ["=>@L"]
    //   SymbolKind1 = (*) "@R" ["=>@R"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["if"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [";"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["=>"]
    //   SymbolKind1 = (*) "Id" ["=>?"]
    //   SymbolKind1 = (*) "Id" ["=>@L"]
    //   SymbolKind1 = (*) "Id" ["=>@R"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["if"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["=>"]
    //   Escape = (*) "Escape" ["=>?"]
    //   Escape = (*) "Escape" ["=>@L"]
    //   Escape = (*) "Escape" ["=>@R"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   Escape = (*) "Escape" ["if"]
    //   Escape = (*) "Escape" ["}"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [","]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["=>"]
    //   QuotedTerminal = (*) RegexLiteral ["=>?"]
    //   QuotedTerminal = (*) RegexLiteral ["=>@L"]
    //   QuotedTerminal = (*) RegexLiteral ["=>@R"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["if"]
    //   QuotedTerminal = (*) RegexLiteral ["}"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["=>"]
    //   QuotedTerminal = (*) StringLiteral ["=>?"]
    //   QuotedTerminal = (*) StringLiteral ["=>@L"]
    //   QuotedTerminal = (*) StringLiteral ["=>@R"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["if"]
    //   QuotedTerminal = (*) StringLiteral ["}"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [","]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>?"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["if"]
    //   RegexLiteral = (*) "RegexLiteral" ["}"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["if"]
    //   StringLiteral = (*) "StringLiteral" ["}"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["}"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["if"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["}"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["}"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["=>"]
    //   SymbolKind1 = (*) Escape ["=>?"]
    //   SymbolKind1 = (*) Escape ["=>@L"]
    //   SymbolKind1 = (*) Escape ["=>@R"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["if"]
    //   SymbolKind1 = (*) Escape ["}"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["}"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>?"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["=>@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["if"]
    //   SymbolKind1 = (*) QuotedTerminal ["}"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["if"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["}"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["=>"]
    //   SymbolKind1 = (*) "@L" ["=>?"]
    //   SymbolKind1 = (*) "@L" ["=>@L"]
    //   SymbolKind1 = (*) "@L" ["=>@R"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["if"]
    //   SymbolKind1 = (*) "@L" ["}"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["=>"]
    //   SymbolKind1 = (*) "@R" ["=>?"]
    //   SymbolKind1 = (*) "@R" ["=>@L"]
    //   SymbolKind1 = (*) "@R" ["=>@R"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["if"]
    //   SymbolKind1 = (*) "@R" ["}"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["=>"]
    //   SymbolKind1 = (*) "Id" ["=>?"]
    //   SymbolKind1 = (*) "Id" ["=>@L"]
    //   SymbolKind1 = (*) "Id" ["=>@R"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["if"]
    //   SymbolKind1 = (*) "Id" ["}"]
    //
    //   "(" -> Shift(S86)
    //   "<" -> Shift(S87)
    //   "@L" -> Shift(S88)
    //   "@R" -> Shift(S89)
    //   "Escape" -> Shift(S90)
    //   "Id" -> Shift(S91)
    //   "MacroId" -> Shift(S92)
    //   "RegexLiteral" -> Shift(S93)
    //   "StringLiteral" -> Shift(S45)
    //
    //   Escape -> S80
    //   MacroId -> S81
    //   QuotedTerminal -> S82
    //   RegexLiteral -> S83
    //   StringLiteral -> S84
    //   SymbolKind1 -> S85
    pub fn ___state62<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state86(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state87(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state88(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state89(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state90(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state91(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state92(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state93(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state45(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state80(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state81(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state82(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state84(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state85(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 63
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //   TypeRef = "#" Symbol (*) "#" ["="]
    //   TypeRef = "#" Symbol (*) "#" ["{"]
    //   TypeRef = "#" Symbol (*) "#" [";"]
    //
    //   "#" -> Shift(S94)
    //
    pub fn ___state63<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state94(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 64
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [";"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["=>"]
    //   RepeatOp = (*) "*" ["=>?"]
    //   RepeatOp = (*) "*" ["=>@L"]
    //   RepeatOp = (*) "*" ["=>@R"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "*" ["if"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [";"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["=>"]
    //   RepeatOp = (*) "+" ["=>?"]
    //   RepeatOp = (*) "+" ["=>@L"]
    //   RepeatOp = (*) "+" ["=>@R"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["if"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [";"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["=>"]
    //   RepeatOp = (*) "?" ["=>?"]
    //   RepeatOp = (*) "?" ["=>@L"]
    //   RepeatOp = (*) "?" ["=>@R"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["if"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [";"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["=>"]
    //   Symbol = Symbol0 (*) ["=>?"]
    //   Symbol = Symbol0 (*) ["=>@L"]
    //   Symbol = Symbol0 (*) ["=>@R"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [";"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["if"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["=>"]
    //   RepeatOp = (*) "*" ["=>?"]
    //   RepeatOp = (*) "*" ["=>@L"]
    //   RepeatOp = (*) "*" ["=>@R"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "*" ["if"]
    //   RepeatOp = (*) "*" ["}"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["=>"]
    //   RepeatOp = (*) "+" ["=>?"]
    //   RepeatOp = (*) "+" ["=>@L"]
    //   RepeatOp = (*) "+" ["=>@R"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["if"]
    //   RepeatOp = (*) "+" ["}"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["=>"]
    //   RepeatOp = (*) "?" ["=>?"]
    //   RepeatOp = (*) "?" ["=>@L"]
    //   RepeatOp = (*) "?" ["=>@R"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["if"]
    //   RepeatOp = (*) "?" ["}"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["=>"]
    //   Symbol = Symbol0 (*) ["=>?"]
    //   Symbol = Symbol0 (*) ["=>@L"]
    //   Symbol = Symbol0 (*) ["=>@R"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["if"]
    //   Symbol = Symbol0 (*) ["}"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["}"]
    //
    //   "#" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "(" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   ")" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "*" -> Shift(S96)
    //   "+" -> Shift(S97)
    //   "," -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   ";" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "<" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "=>" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "=>?" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "=>@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "=>@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   ">" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "?" -> Shift(S98)
    //   "@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "Escape" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "Id" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "RegexLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "if" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "}" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //
    //   RepeatOp -> S95
    pub fn ___state64<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state96(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state97(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state98(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action35(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state95(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 65
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [";"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["=>"]
    //   Symbol0 = Symbol1 (*) ["=>?"]
    //   Symbol0 = Symbol1 (*) ["=>@L"]
    //   Symbol0 = Symbol1 (*) ["=>@R"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["if"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["=>"]
    //   Symbol0 = Symbol1 (*) ["=>?"]
    //   Symbol0 = Symbol1 (*) ["=>@L"]
    //   Symbol0 = Symbol1 (*) ["=>@R"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["if"]
    //   Symbol0 = Symbol1 (*) ["}"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "(" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   ")" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "," -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   ";" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "<" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "=>" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "=>?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "=>@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "=>@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   ">" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "if" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "}" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //
    pub fn ___state65<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action36(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 66
    //   Lifetime? = Lifetime (*) ["#"]
    //   Lifetime? = Lifetime (*) ["&"]
    //   Lifetime? = Lifetime (*) ["("]
    //   Lifetime? = Lifetime (*) ["::"]
    //   Lifetime? = Lifetime (*) ["Id"]
    //   Lifetime? = Lifetime (*) ["MacroId"]
    //   Lifetime? = Lifetime (*) ["mut"]
    //
    //   "#" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "&" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "(" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "::" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "Id" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "MacroId" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "mut" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //
    pub fn ___state66<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action101(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 67
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [")"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef ["="]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef ["{"]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [";"]
    //
    //   "#" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "MacroId" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "mut" -> Shift(S100)
    //
    //   "mut"? -> S99
    pub fn ___state67<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state100(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action100(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22mut_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22mut_22_3f(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state99(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 68
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["("]
    //   (<TypeRef> ",") = (*) TypeRef "," [")"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")* (*) TypeRef? [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef? = (*) [")"]
    //   TypeRef? = (*) TypeRef [")"]
    //
    //   "#" -> Shift(S49)
    //   "&" -> Shift(S50)
    //   "(" -> Shift(S51)
    //   ")" -> Reduce(TypeRef? =  => Call(ActionFn(163));)
    //   "::" -> Shift(S52)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S46
    //   (<TypeRef> ",") -> S101
    //   Path -> S47
    //   TypeRef -> S102
    //   TypeRef? -> S103
    pub fn ___state68<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action163(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::TypeRef_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state101(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state102(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state103(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 69
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" ["="]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" ["{"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [";"]
    //
    //   ")" -> Shift(S104)
    //
    pub fn ___state69<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state104(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 70
    //   @R = (*) ["{"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* EnumToken AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* EnumToken AssociatedType* "}" ["#"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* EnumToken AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* EnumToken AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* EnumToken AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* EnumToken AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* EnumToken AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* EnumToken AssociatedType* "}" ["use"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "}" ["#"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" (*) @R "{" AssociatedType* "}" ["use"]
    //
    //   "{" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S105
    pub fn ___state70<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state105(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 71
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Nonterminal = Annotation* "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = Annotation* "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["#"]
    //   Nonterminal = Annotation* "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation* "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = Annotation* "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation* "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = Annotation* "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = Annotation* "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S106
    pub fn ___state71<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state106(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 72
    //   Annotation* = Annotation* Annotation (*) ["#"]
    //   Annotation* = Annotation* Annotation (*) ["Escape"]
    //   Annotation* = Annotation* Annotation (*) ["Id"]
    //   Annotation* = Annotation* Annotation (*) ["MacroId"]
    //   Annotation* = Annotation* Annotation (*) ["pub"]
    //
    //   "#" -> Reduce(Annotation* = Annotation*, Annotation => Call(ActionFn(122));)
    //   "Escape" -> Reduce(Annotation* = Annotation*, Annotation => Call(ActionFn(122));)
    //   "Id" -> Reduce(Annotation* = Annotation*, Annotation => Call(ActionFn(122));)
    //   "MacroId" -> Reduce(Annotation* = Annotation*, Annotation => Call(ActionFn(122));)
    //   "pub" -> Reduce(Annotation* = Annotation*, Annotation => Call(ActionFn(122));)
    //
    pub fn ___state72<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<Annotation>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Pub, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action122(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Annotation_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 73
    //   Annotation = "#" (*) "[" @L Id @R "]" ["#"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["Escape"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["Id"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["MacroId"]
    //   Annotation = "#" (*) "[" @L Id @R "]" ["pub"]
    //
    //   "[" -> Shift(S107)
    //
    pub fn ___state73<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBracket, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state107(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 74
    //   "pub"? = "pub" (*) ["Escape"]
    //   "pub"? = "pub" (*) ["Id"]
    //   "pub"? = "pub" (*) ["MacroId"]
    //
    //   "Escape" -> Reduce("pub"? = "pub" => Call(ActionFn(119));)
    //   "Id" -> Reduce("pub"? = "pub" => Call(ActionFn(119));)
    //   "MacroId" -> Reduce("pub"? = "pub" => Call(ActionFn(119));)
    //
    pub fn ___state74<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action119(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_22pub_22_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 75
    //   Algorithm = "[" @L StringLiteral @R "]" (*) [";"]
    //
    //   ";" -> Reduce(Algorithm = "[", @L, StringLiteral, @R, "]" => Call(ActionFn(4));)
    //
    pub fn ___state75<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Semi, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action4(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Algorithm(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 76
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(94));)
    //   "MacroId" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(94));)
    //
    pub fn ___state76<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action94(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 77
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) ["="]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [";"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "::" -> Shift(S108)
    //   ";" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "=" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "{" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //
    pub fn ___state77<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state108(text, ___lookbehind, ___tokens, ___sym2, ___sym3));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action56(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 78
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* (*) TypeRefOrLifetime? [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   TypeRefOrLifetime? = (*) [">"]
    //   TypeRefOrLifetime? = (*) TypeRefOrLifetime [">"]
    //
    //   "#" -> Shift(S49)
    //   "&" -> Shift(S50)
    //   "(" -> Shift(S51)
    //   "::" -> Shift(S52)
    //   ">" -> Reduce(TypeRefOrLifetime? =  => Call(ActionFn(168));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "Lifetime" -> Shift(S27)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S46
    //   (<TypeRefOrLifetime> ",") -> S109
    //   Lifetime -> S110
    //   Path -> S47
    //   TypeRef -> S111
    //   TypeRefOrLifetime -> S112
    //   TypeRefOrLifetime? -> S113
    pub fn ___state78<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state27(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action168(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state109(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state110(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state111(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state112(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state113(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 79
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" ["="]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" ["{"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [";"]
    //
    //   ">" -> Shift(S114)
    //
    pub fn ___state79<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state114(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 80
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [";"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["=>"]
    //   SymbolKind1 = Escape (*) ["=>?"]
    //   SymbolKind1 = Escape (*) ["=>@L"]
    //   SymbolKind1 = Escape (*) ["=>@R"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["if"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["=>"]
    //   SymbolKind1 = Escape (*) ["=>?"]
    //   SymbolKind1 = Escape (*) ["=>@L"]
    //   SymbolKind1 = Escape (*) ["=>@R"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["if"]
    //   SymbolKind1 = Escape (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "(" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   ")" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "," -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   ";" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "<" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "=>" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "=>?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "=>@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "=>@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   ">" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "Id" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "if" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "}" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //
    pub fn ___state80<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action45(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 81
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [";"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["}"]
    //
    //   "<" -> Shift(S115)
    //
    pub fn ___state81<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state115(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 82
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [";"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>?"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["if"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>?"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["=>@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["if"]
    //   SymbolKind1 = QuotedTerminal (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   ";" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "=>" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "=>?" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "=>@L" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "=>@R" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "if" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "}" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //
    pub fn ___state82<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 83
    //   QuotedTerminal = RegexLiteral (*) ["#"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) [")"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [","]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [";"]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["=>"]
    //   QuotedTerminal = RegexLiteral (*) ["=>?"]
    //   QuotedTerminal = RegexLiteral (*) ["=>@L"]
    //   QuotedTerminal = RegexLiteral (*) ["=>@R"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["if"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [","]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["=>"]
    //   QuotedTerminal = RegexLiteral (*) ["=>?"]
    //   QuotedTerminal = RegexLiteral (*) ["=>@L"]
    //   QuotedTerminal = RegexLiteral (*) ["=>@R"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["if"]
    //   QuotedTerminal = RegexLiteral (*) ["}"]
    //   QuotedTerminal = RegexLiteral (*) ["=>"]
    //
    //   "#" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "(" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   ")" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "*" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "+" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "," -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   ";" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "<" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "=>" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "=>?" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "=>@L" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "=>@R" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   ">" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "?" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "@L" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "@R" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "Escape" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "Id" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "MacroId" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "if" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "}" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //
    pub fn ___state83<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action81(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 84
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [";"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["=>"]
    //   QuotedTerminal = StringLiteral (*) ["=>?"]
    //   QuotedTerminal = StringLiteral (*) ["=>@L"]
    //   QuotedTerminal = StringLiteral (*) ["=>@R"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["if"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["=>"]
    //   QuotedTerminal = StringLiteral (*) ["=>?"]
    //   QuotedTerminal = StringLiteral (*) ["=>@L"]
    //   QuotedTerminal = StringLiteral (*) ["=>@R"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["if"]
    //   QuotedTerminal = StringLiteral (*) ["}"]
    //   QuotedTerminal = StringLiteral (*) ["=>"]
    //
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "," -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   ";" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "=>" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "=>?" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "=>@L" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "=>@R" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "if" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "}" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //
    pub fn ___state84<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action80(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 85
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [";"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["if"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["if"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["}"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S116
    pub fn ___state85<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state116(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 86
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [";"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["if"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["=>@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["if"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["}"]
    //
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "RegexLiteral" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //
    //   ExprSymbol -> S117
    //   Symbol* -> S118
    pub fn ___state86<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action105(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Symbol_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::ExprSymbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 87
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [";"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["}"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["}"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S119
    //   Symbol0 -> S120
    //   Symbol1 -> S65
    pub fn ___state87<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state119(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state120(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 88
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [";"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["=>"]
    //   SymbolKind1 = "@L" (*) ["=>?"]
    //   SymbolKind1 = "@L" (*) ["=>@L"]
    //   SymbolKind1 = "@L" (*) ["=>@R"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["if"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["=>"]
    //   SymbolKind1 = "@L" (*) ["=>?"]
    //   SymbolKind1 = "@L" (*) ["=>@L"]
    //   SymbolKind1 = "@L" (*) ["=>@R"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["if"]
    //   SymbolKind1 = "@L" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "(" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   ")" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "," -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   ";" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "<" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "=>" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "=>?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "=>@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "=>@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   ">" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "if" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "}" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //
    pub fn ___state88<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action47(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 89
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [";"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["=>"]
    //   SymbolKind1 = "@R" (*) ["=>?"]
    //   SymbolKind1 = "@R" (*) ["=>@L"]
    //   SymbolKind1 = "@R" (*) ["=>@R"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["if"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["=>"]
    //   SymbolKind1 = "@R" (*) ["=>?"]
    //   SymbolKind1 = "@R" (*) ["=>@L"]
    //   SymbolKind1 = "@R" (*) ["=>@R"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["if"]
    //   SymbolKind1 = "@R" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "(" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   ")" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "," -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   ";" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "<" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "=>" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "=>?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "=>@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "=>@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   ">" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "if" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "}" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //
    pub fn ___state89<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action48(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 90
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [";"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["=>"]
    //   Escape = "Escape" (*) ["=>?"]
    //   Escape = "Escape" (*) ["=>@L"]
    //   Escape = "Escape" (*) ["=>@R"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["if"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["=>"]
    //   Escape = "Escape" (*) ["=>?"]
    //   Escape = "Escape" (*) ["=>@L"]
    //   Escape = "Escape" (*) ["=>@R"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["if"]
    //   Escape = "Escape" (*) ["}"]
    //
    //   "#" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "(" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   ";" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "<" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "=>" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "=>?" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "=>@L" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "=>@R" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "@L" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "@R" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "Escape" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "Id" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "MacroId" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "RegexLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "if" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "}" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //
    pub fn ___state90<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action76(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Escape(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 91
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [";"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["=>"]
    //   SymbolKind1 = "Id" (*) ["=>?"]
    //   SymbolKind1 = "Id" (*) ["=>@L"]
    //   SymbolKind1 = "Id" (*) ["=>@R"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["if"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["=>"]
    //   SymbolKind1 = "Id" (*) ["=>?"]
    //   SymbolKind1 = "Id" (*) ["=>@L"]
    //   SymbolKind1 = "Id" (*) ["=>@R"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["if"]
    //   SymbolKind1 = "Id" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "(" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ")" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "," -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ";" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "<" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "=>" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "=>?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "=>@L" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "=>@R" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "if" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "}" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //
    pub fn ___state91<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 92
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(72));)
    //
    pub fn ___state92<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action72(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 93
    //   RegexLiteral = "RegexLiteral" (*) ["#"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) [")"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [","]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [";"]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>?"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["if"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [","]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>?"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["if"]
    //   RegexLiteral = "RegexLiteral" (*) ["}"]
    //   RegexLiteral = "RegexLiteral" (*) ["=>"]
    //
    //   "#" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "(" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   ")" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "*" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "+" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "," -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   ";" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "<" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "=>" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "=>?" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "=>@L" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "=>@R" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   ">" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "?" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "@L" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "@R" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "Escape" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "Id" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "MacroId" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "RegexLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "StringLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "if" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "}" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //
    pub fn ___state93<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action83(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RegexLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 94
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //   TypeRef = "#" Symbol "#" (*) ["="]
    //   TypeRef = "#" Symbol "#" (*) ["{"]
    //   TypeRef = "#" Symbol "#" (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   ";" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   "=" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   "{" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //
    pub fn ___state94<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action50(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 95
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [";"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["if"]
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["if"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["}"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S121
    pub fn ___state95<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state121(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 96
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [";"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["=>"]
    //   RepeatOp = "*" (*) ["=>?"]
    //   RepeatOp = "*" (*) ["=>@L"]
    //   RepeatOp = "*" (*) ["=>@R"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["if"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["=>"]
    //   RepeatOp = "*" (*) ["=>?"]
    //   RepeatOp = "*" (*) ["=>@L"]
    //   RepeatOp = "*" (*) ["=>@R"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["if"]
    //   RepeatOp = "*" (*) ["}"]
    //
    //   "#" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "(" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   ")" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "," -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   ";" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "<" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "=>" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "=>?" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "=>@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "=>@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   ">" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "Escape" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "Id" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "MacroId" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "if" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "}" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //
    pub fn ___state96<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action39(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 97
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [";"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["=>"]
    //   RepeatOp = "+" (*) ["=>?"]
    //   RepeatOp = "+" (*) ["=>@L"]
    //   RepeatOp = "+" (*) ["=>@R"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["if"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["=>"]
    //   RepeatOp = "+" (*) ["=>?"]
    //   RepeatOp = "+" (*) ["=>@L"]
    //   RepeatOp = "+" (*) ["=>@R"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["if"]
    //   RepeatOp = "+" (*) ["}"]
    //
    //   "#" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "(" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   ")" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "," -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   ";" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "<" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "=>" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "=>?" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "=>@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "=>@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   ">" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "Escape" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "Id" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "MacroId" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "if" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "}" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //
    pub fn ___state97<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action38(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 98
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [";"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["=>"]
    //   RepeatOp = "?" (*) ["=>?"]
    //   RepeatOp = "?" (*) ["=>@L"]
    //   RepeatOp = "?" (*) ["=>@R"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["if"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["=>"]
    //   RepeatOp = "?" (*) ["=>?"]
    //   RepeatOp = "?" (*) ["=>@L"]
    //   RepeatOp = "?" (*) ["=>@R"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["if"]
    //   RepeatOp = "?" (*) ["}"]
    //
    //   "#" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "(" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   ")" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "," -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   ";" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "<" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "=>" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "=>?" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "=>@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "=>@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   ">" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "Escape" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "Id" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "MacroId" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "if" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "}" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //
    pub fn ___state98<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action40(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 99
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["="]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["{"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Shift(S49)
    //   "&" -> Shift(S50)
    //   "(" -> Shift(S51)
    //   "::" -> Shift(S52)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S46
    //   Path -> S47
    //   TypeRef -> S122
    pub fn ___state99<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
        ___sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state122(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 100
    //   "mut"? = "mut" (*) ["#"]
    //   "mut"? = "mut" (*) ["&"]
    //   "mut"? = "mut" (*) ["("]
    //   "mut"? = "mut" (*) ["::"]
    //   "mut"? = "mut" (*) ["Id"]
    //   "mut"? = "mut" (*) ["MacroId"]
    //
    //   "#" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "&" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "(" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "::" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "Id" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "MacroId" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //
    pub fn ___state100<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action99(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_22mut_22_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 101
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "&" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "(" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   ")" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "::" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "Id" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //
    pub fn ___state101<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action165(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 102
    //   (<TypeRef> ",") = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["("]
    //   (<TypeRef> ",") = TypeRef (*) "," [")"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["MacroId"]
    //   TypeRef? = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(TypeRef? = TypeRef => Call(ActionFn(162));)
    //   "," -> Shift(S123)
    //
    pub fn ___state102<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state123(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action162(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 103
    //   Comma<TypeRef> = (<TypeRef> ",")* TypeRef? (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")*, TypeRef? => Call(ActionFn(103));)
    //
    pub fn ___state103<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action103(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 104
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) ["="]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) ["{"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   ";" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   "=" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   "{" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //
    pub fn ___state104<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action49(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 105
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* EnumToken AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* EnumToken AssociatedType* "}" ["#"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* EnumToken AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* EnumToken AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* EnumToken AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* EnumToken AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* EnumToken AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* EnumToken AssociatedType* "}" ["use"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "}" ["#"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R (*) "{" AssociatedType* "}" ["use"]
    //
    //   "{" -> Shift(S124)
    //
    pub fn ___state105<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state124(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 106
    //   MacroId = (*) "MacroId" ["<"]
    //   Nonterminal = Annotation* "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = Annotation* "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["#"]
    //   Nonterminal = Annotation* "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation* "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = Annotation* "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation* "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = Annotation* "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = Annotation* "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = (*) MacroId "<" Comma<NotMacroId> ">" ["="]
    //   NonterminalName = (*) NotMacroId [":"]
    //   NonterminalName = (*) NotMacroId ["="]
    //   NonterminalName = (*) "Escape" [":"]
    //   NonterminalName = (*) "Escape" ["="]
    //   NotMacroId = (*) "Id" [":"]
    //   NotMacroId = (*) "Id" ["="]
    //
    //   "Escape" -> Shift(S128)
    //   "Id" -> Shift(S129)
    //   "MacroId" -> Shift(S92)
    //
    //   MacroId -> S125
    //   NonterminalName -> S126
    //   NotMacroId -> S127
    pub fn ___state106<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state128(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state129(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state92(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state125(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::NonterminalName(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state126(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state127(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 107
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["#"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["Escape"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["Id"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["MacroId"]
    //   Annotation = "#" "[" (*) @L Id @R "]" ["pub"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S130
    pub fn ___state107<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state130(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 108
    //   (<Id> "::") = Id "::" (*) ["Id"]
    //   (<Id> "::") = Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(95));)
    //   "MacroId" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(95));)
    //
    pub fn ___state108<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action95(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 109
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //
    pub fn ___state109<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action170(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 110
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(55));)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(55));)
    //
    pub fn ___state110<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action55(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 111
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(54));)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(54));)
    //
    pub fn ___state111<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action54(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 112
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["MacroId"]
    //   TypeRefOrLifetime? = TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S131)
    //   ">" -> Reduce(TypeRefOrLifetime? = TypeRefOrLifetime => Call(ActionFn(167));)
    //
    pub fn ___state112<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state131(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action167(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 113
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")*, TypeRefOrLifetime? => Call(ActionFn(98));)
    //
    pub fn ___state113<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action98(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 114
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) ["="]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) ["{"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   ";" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   "=" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   "{" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //
    pub fn ___state114<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action52(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 115
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [";"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["if"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["}"]
    //
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //
    //   (<Symbol> ",")* -> S132
    //   Comma<Symbol> -> S133
    pub fn ___state115<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action159(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state132(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cSymbol_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state133(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 116
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [";"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["if"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["if"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["}"]
    //
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   ";" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "=>" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "=>?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "=>@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "=>@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "RegexLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "if" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "}" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //
    pub fn ___state116<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action41(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 117
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [";"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["if"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["if"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["}"]
    //
    //   ")" -> Shift(S134)
    //
    pub fn ___state117<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state134(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 118
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol* (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["RegexLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(ExprSymbol = Symbol* => Call(ActionFn(32));)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S62
    //   Symbol -> S135
    //   Symbol0 -> S64
    //   Symbol1 -> S65
    pub fn ___state118<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action32(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state62(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state135(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 119
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["}"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S86)
    //   "@L" -> Shift(S88)
    //   "@R" -> Shift(S89)
    //   "Escape" -> Shift(S90)
    //   "Id" -> Shift(S137)
    //   "MacroId" -> Shift(S138)
    //   "RegexLiteral" -> Shift(S93)
    //   "StringLiteral" -> Shift(S45)
    //
    //   Escape -> S80
    //   Id -> S136
    //   MacroId -> S81
    //   QuotedTerminal -> S82
    //   RegexLiteral -> S83
    //   StringLiteral -> S84
    //   SymbolKind1 -> S85
    pub fn ___state119<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state86(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state88(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state89(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state90(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state137(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state138(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state93(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state45(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state80(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state136(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state81(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state82(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state84(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state85(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 120
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [";"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["if"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["}"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S96)
    //   "+" -> Shift(S97)
    //   ">" -> Shift(S139)
    //   "?" -> Shift(S98)
    //
    //   RepeatOp -> S95
    pub fn ___state120<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state96(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state97(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state139(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state98(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state95(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 121
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [";"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["if"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["if"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["}"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   ";" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "=>" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "=>?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "=>@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "=>@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "if" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "}" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //
    pub fn ___state121<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action37(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 122
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) ["="]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) ["{"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [";"]
    //
    //   ")" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   ";" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   "=" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   "{" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //
    pub fn ___state122<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
        ___sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action51(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 123
    //   (<TypeRef> ",") = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["("]
    //   (<TypeRef> ",") = TypeRef "," (*) [")"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "&" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "(" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   ")" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "::" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "Id" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "MacroId" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //
    pub fn ___state123<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action166(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 124
    //   AssociatedType* = (*) ["enum"]
    //   AssociatedType* = (*) ["type"]
    //   AssociatedType* = (*) ["}"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["enum"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["type"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* EnumToken AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* EnumToken AssociatedType* "}" ["#"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* EnumToken AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* EnumToken AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* EnumToken AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* EnumToken AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* EnumToken AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* EnumToken AssociatedType* "}" ["use"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "}" ["#"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" (*) AssociatedType* "}" ["use"]
    //
    //   "enum" -> Reduce(AssociatedType* =  => Call(ActionFn(91));)
    //   "type" -> Reduce(AssociatedType* =  => Call(ActionFn(91));)
    //   "}" -> Reduce(AssociatedType* =  => Call(ActionFn(91));)
    //
    //   AssociatedType* -> S140
    pub fn ___state124<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Enum, _)) |
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action91(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::AssociatedType_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType_2a(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state140(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 125
    //   NonterminalName = MacroId (*) "<" Comma<NotMacroId> ">" [":"]
    //   NonterminalName = MacroId (*) "<" Comma<NotMacroId> ">" ["="]
    //
    //   "<" -> Shift(S141)
    //
    pub fn ___state125<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state141(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 126
    //   @R = (*) [":"]
    //   @R = (*) ["="]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["#"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   ":" -> Reduce(@R =  => Lookbehind;)
    //   "=" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S142
    pub fn ___state126<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state142(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 127
    //   NonterminalName = NotMacroId (*) [":"]
    //   NonterminalName = NotMacroId (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = NotMacroId => Call(ActionFn(17));)
    //   "=" -> Reduce(NonterminalName = NotMacroId => Call(ActionFn(17));)
    //
    pub fn ___state127<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action17(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NonterminalName(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 128
    //   NonterminalName = "Escape" (*) [":"]
    //   NonterminalName = "Escape" (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = "Escape" => Call(ActionFn(18));)
    //   "=" -> Reduce(NonterminalName = "Escape" => Call(ActionFn(18));)
    //
    pub fn ___state128<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action18(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NonterminalName(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 129
    //   NotMacroId = "Id" (*) [":"]
    //   NotMacroId = "Id" (*) ["="]
    //   NotMacroId = "Id" (*) [","]
    //   NotMacroId = "Id" (*) [">"]
    //   NotMacroId = "Id" (*) ["!="]
    //   NotMacroId = "Id" (*) ["!~"]
    //   NotMacroId = "Id" (*) ["=="]
    //   NotMacroId = "Id" (*) ["~~"]
    //
    //   "!=" -> Reduce(NotMacroId = "Id" => Call(ActionFn(73));)
    //   "!~" -> Reduce(NotMacroId = "Id" => Call(ActionFn(73));)
    //   "," -> Reduce(NotMacroId = "Id" => Call(ActionFn(73));)
    //   ":" -> Reduce(NotMacroId = "Id" => Call(ActionFn(73));)
    //   "=" -> Reduce(NotMacroId = "Id" => Call(ActionFn(73));)
    //   "==" -> Reduce(NotMacroId = "Id" => Call(ActionFn(73));)
    //   ">" -> Reduce(NotMacroId = "Id" => Call(ActionFn(73));)
    //   "~~" -> Reduce(NotMacroId = "Id" => Call(ActionFn(73));)
    //
    pub fn ___state129<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::BangEquals, _)) |
            Some((_, Tok::BangTilde, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) |
            Some((_, Tok::EqualsEquals, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::TildeTilde, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action73(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NotMacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 130
    //   Annotation = "#" "[" @L (*) Id @R "]" ["#"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["Escape"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["Id"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["MacroId"]
    //   Annotation = "#" "[" @L (*) Id @R "]" ["pub"]
    //   Id = (*) "Id" ["]"]
    //   Id = (*) "MacroId" ["]"]
    //
    //   "Id" -> Shift(S26)
    //   "MacroId" -> Shift(S28)
    //
    //   Id -> S143
    pub fn ___state130<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state143(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 131
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //
    pub fn ___state131<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action171(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 132
    //   (<Symbol> ",") = (*) Symbol "," ["("]
    //   (<Symbol> ",") = (*) Symbol "," ["<"]
    //   (<Symbol> ",") = (*) Symbol "," [">"]
    //   (<Symbol> ",") = (*) Symbol "," ["@L"]
    //   (<Symbol> ",") = (*) Symbol "," ["@R"]
    //   (<Symbol> ",") = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",") = (*) Symbol "," ["Id"]
    //   (<Symbol> ",") = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",") = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",") = (*) Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")* (*) Symbol? [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol? = (*) [">"]
    //   Symbol? = (*) Symbol [">"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   ">" -> Reduce(Symbol? =  => Call(ActionFn(158));)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   (<Symbol> ",") -> S144
    //   @L -> S62
    //   Symbol -> S145
    //   Symbol0 -> S64
    //   Symbol1 -> S65
    //   Symbol? -> S146
    pub fn ___state132<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action158(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Symbol_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state144(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state62(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state145(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state146(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 133
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [";"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["if"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["if"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["}"]
    //
    //   ">" -> Shift(S147)
    //
    pub fn ___state133<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state147(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 134
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [";"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["if"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["=>@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["if"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   ";" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "=>" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "=>?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "=>@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "=>@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "if" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "}" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //
    pub fn ___state134<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action46(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 135
    //   Symbol* = Symbol* Symbol (*) ["("]
    //   Symbol* = Symbol* Symbol (*) [")"]
    //   Symbol* = Symbol* Symbol (*) ["<"]
    //   Symbol* = Symbol* Symbol (*) ["@L"]
    //   Symbol* = Symbol* Symbol (*) ["@R"]
    //   Symbol* = Symbol* Symbol (*) ["Escape"]
    //   Symbol* = Symbol* Symbol (*) ["Id"]
    //   Symbol* = Symbol* Symbol (*) ["MacroId"]
    //   Symbol* = Symbol* Symbol (*) ["RegexLiteral"]
    //   Symbol* = Symbol* Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   ")" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "<" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "Escape" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "Id" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "MacroId" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "RegexLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "StringLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //
    pub fn ___state135<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action106(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 136
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["}"]
    //
    //   ":" -> Shift(S148)
    //
    pub fn ___state136<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state148(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 137
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //
    pub fn ___state137<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 138
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(72));)
    //
    pub fn ___state138<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action72(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 139
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [";"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["if"]
    //   @R = (*) ["("]
    //   @R = (*) [","]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["if"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["}"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S149
    pub fn ___state139<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state149(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 140
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["enum"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["type"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["}"]
    //   EnumToken = (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) EnumToken AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) EnumToken AssociatedType* "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) EnumToken AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) EnumToken AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) EnumToken AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) EnumToken AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) EnumToken AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) EnumToken AssociatedType* "}" ["use"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* (*) "}" ["use"]
    //
    //   "enum" -> Shift(S152)
    //   "type" -> Shift(S153)
    //   "}" -> Shift(S154)
    //
    //   AssociatedType -> S150
    //   EnumToken -> S151
    pub fn ___state140<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Enum, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state152(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Type, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state153(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state154(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state150(text, ___lookbehind, ___tokens, ___lookahead, ___sym4, ___sym5));
                }
                ___Nonterminal::EnumToken(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state151(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 141
    //   (<NotMacroId> ",")* = (*) [">"]
    //   (<NotMacroId> ",")* = (*) ["Id"]
    //   (<NotMacroId> ",")* = (*) (<NotMacroId> ",")* (<NotMacroId> ",") [">"]
    //   (<NotMacroId> ",")* = (*) (<NotMacroId> ",")* (<NotMacroId> ",") ["Id"]
    //   Comma<NotMacroId> = (*) (<NotMacroId> ",")* NotMacroId? [">"]
    //   NonterminalName = MacroId "<" (*) Comma<NotMacroId> ">" [":"]
    //   NonterminalName = MacroId "<" (*) Comma<NotMacroId> ">" ["="]
    //
    //   ">" -> Reduce((<NotMacroId> ",")* =  => Call(ActionFn(149));)
    //   "Id" -> Reduce((<NotMacroId> ",")* =  => Call(ActionFn(149));)
    //
    //   (<NotMacroId> ",")* -> S155
    //   Comma<NotMacroId> -> S156
    pub fn ___state141<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) => {
                let ___nt = super::___action149(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state155(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cNotMacroId_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state156(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 142
    //   (":" <TypeRef>) = (*) ":" TypeRef ["="]
    //   (":" <TypeRef>)? = (*) ["="]
    //   (":" <TypeRef>)? = (*) (":" <TypeRef>) ["="]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["#"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   ":" -> Shift(S159)
    //   "=" -> Reduce((":" <TypeRef>)? =  => Call(ActionFn(117));)
    //
    //   (":" <TypeRef>) -> S157
    //   (":" <TypeRef>)? -> S158
    pub fn ___state142<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state159(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Equals, _)) => {
                let ___nt = super::___action117(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state157(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state158(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 143
    //   @R = (*) ["]"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["#"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["Escape"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["Id"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["MacroId"]
    //   Annotation = "#" "[" @L Id (*) @R "]" ["pub"]
    //
    //   "]" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S160
    pub fn ___state143<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightBracket, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state160(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 144
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "<" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   ">" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "@L" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "@R" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "Escape" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "Id" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "MacroId" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //
    pub fn ___state144<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action160(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 145
    //   (<Symbol> ",") = Symbol (*) "," ["("]
    //   (<Symbol> ",") = Symbol (*) "," ["<"]
    //   (<Symbol> ",") = Symbol (*) "," [">"]
    //   (<Symbol> ",") = Symbol (*) "," ["@L"]
    //   (<Symbol> ",") = Symbol (*) "," ["@R"]
    //   (<Symbol> ",") = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",") = Symbol (*) "," ["Id"]
    //   (<Symbol> ",") = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",") = Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",") = Symbol (*) "," ["StringLiteral"]
    //   Symbol? = Symbol (*) [">"]
    //
    //   "," -> Shift(S161)
    //   ">" -> Reduce(Symbol? = Symbol => Call(ActionFn(157));)
    //
    pub fn ___state145<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state161(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action157(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 146
    //   Comma<Symbol> = (<Symbol> ",")* Symbol? (*) [">"]
    //
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")*, Symbol? => Call(ActionFn(104));)
    //
    pub fn ___state146<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<::std::option::Option<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action104(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 147
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [";"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["if"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["if"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["}"]
    //
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   ";" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "=>" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "=>?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "=>@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "=>@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "if" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "}" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //
    pub fn ___state147<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action42(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 148
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["}"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S162
    //   Symbol0 -> S163
    //   Symbol1 -> S65
    pub fn ___state148<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state162(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state163(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 149
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [";"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["if"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["if"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["}"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   ";" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "=>" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "=>?" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "=>@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "=>@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "if" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "}" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //
    pub fn ___state149<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action34(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 150
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["enum"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["type"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["}"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["type"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["}"]
    //
    //   "enum" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(92));)
    //   "type" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(92));)
    //   "}" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(92));)
    //
    pub fn ___state150<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym1: &mut Option<AssociatedType>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Enum, _)) |
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action92(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::AssociatedType_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 151
    //   AssociatedType* = (*) ["type"]
    //   AssociatedType* = (*) ["}"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["type"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken (*) AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken (*) AssociatedType* "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken (*) AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken (*) AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken (*) AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken (*) AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken (*) AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken (*) AssociatedType* "}" ["use"]
    //
    //   "type" -> Reduce(AssociatedType* =  => Call(ActionFn(91));)
    //   "}" -> Reduce(AssociatedType* =  => Call(ActionFn(91));)
    //
    //   AssociatedType* -> S164
    pub fn ___state151<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<EnumToken>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action91(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::AssociatedType_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType_2a(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state164(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 152
    //   @L = (*) ["#"]
    //   @L = (*) ["&"]
    //   @L = (*) ["("]
    //   @L = (*) ["::"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   EnumToken = "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" ["}"]
    //
    //   "#" -> Reduce(@L =  => Lookahead;)
    //   "&" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S165
    pub fn ___state152<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state165(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 153
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["}"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S166
    pub fn ___state153<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state166(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 154
    //   ExternToken = @L "extern" @R "{" AssociatedType* "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "}" (*) ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* "}" (*) ["use"]
    //
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "}" => Call(ActionFn(58));)
    //   "#" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "}" => Call(ActionFn(58));)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "}" => Call(ActionFn(58));)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "}" => Call(ActionFn(58));)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "}" => Call(ActionFn(58));)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "}" => Call(ActionFn(58));)
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "}" => Call(ActionFn(58));)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, "}" => Call(ActionFn(58));)
    //
    pub fn ___state154<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action58(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExternToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 155
    //   (<NotMacroId> ",") = (*) NotMacroId "," [">"]
    //   (<NotMacroId> ",") = (*) NotMacroId "," ["Id"]
    //   (<NotMacroId> ",")* = (<NotMacroId> ",")* (*) (<NotMacroId> ",") [">"]
    //   (<NotMacroId> ",")* = (<NotMacroId> ",")* (*) (<NotMacroId> ",") ["Id"]
    //   Comma<NotMacroId> = (<NotMacroId> ",")* (*) NotMacroId? [">"]
    //   NotMacroId = (*) "Id" [","]
    //   NotMacroId = (*) "Id" [">"]
    //   NotMacroId? = (*) [">"]
    //   NotMacroId? = (*) NotMacroId [">"]
    //
    //   ">" -> Reduce(NotMacroId? =  => Call(ActionFn(148));)
    //   "Id" -> Shift(S129)
    //
    //   (<NotMacroId> ",") -> S167
    //   NotMacroId -> S168
    //   NotMacroId? -> S169
    pub fn ___state155<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state129(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action148(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::NotMacroId_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state167(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state168(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::NotMacroId_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state169(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 156
    //   NonterminalName = MacroId "<" Comma<NotMacroId> (*) ">" [":"]
    //   NonterminalName = MacroId "<" Comma<NotMacroId> (*) ">" ["="]
    //
    //   ">" -> Shift(S170)
    //
    pub fn ___state156<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state170(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 157
    //   (":" <TypeRef>)? = (":" <TypeRef>) (*) ["="]
    //
    //   "=" -> Reduce((":" <TypeRef>)? = (":" <TypeRef>) => Call(ActionFn(116));)
    //
    pub fn ___state157<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Equals, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action116(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 158
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives [EOF]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["#"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["Escape"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["Id"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["extern"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["pub"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["use"]
    //
    //   "=" -> Shift(S171)
    //
    pub fn ___state158<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state171(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 159
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (":" <TypeRef>) = ":" (*) TypeRef ["="]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "#" Symbol "#" ["="]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //
    //   "#" -> Shift(S49)
    //   "&" -> Shift(S50)
    //   "(" -> Shift(S51)
    //   "::" -> Shift(S52)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S46
    //   Path -> S47
    //   TypeRef -> S172
    pub fn ___state159<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state172(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 160
    //   Annotation = "#" "[" @L Id @R (*) "]" ["#"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["Escape"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["Id"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["MacroId"]
    //   Annotation = "#" "[" @L Id @R (*) "]" ["pub"]
    //
    //   "]" -> Shift(S173)
    //
    pub fn ___state160<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBracket, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state173(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 161
    //   (<Symbol> ",") = Symbol "," (*) ["("]
    //   (<Symbol> ",") = Symbol "," (*) ["<"]
    //   (<Symbol> ",") = Symbol "," (*) [">"]
    //   (<Symbol> ",") = Symbol "," (*) ["@L"]
    //   (<Symbol> ",") = Symbol "," (*) ["@R"]
    //   (<Symbol> ",") = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",") = Symbol "," (*) ["Id"]
    //   (<Symbol> ",") = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",") = Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",") = Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "<" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   ">" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "@L" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "@R" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "Escape" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "Id" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "MacroId" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "StringLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //
    pub fn ___state161<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action161(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 162
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S86)
    //   "@L" -> Shift(S88)
    //   "@R" -> Shift(S89)
    //   "Escape" -> Shift(S90)
    //   "Id" -> Shift(S91)
    //   "MacroId" -> Shift(S92)
    //   "RegexLiteral" -> Shift(S93)
    //   "StringLiteral" -> Shift(S45)
    //
    //   Escape -> S80
    //   MacroId -> S81
    //   QuotedTerminal -> S82
    //   RegexLiteral -> S83
    //   StringLiteral -> S84
    //   SymbolKind1 -> S85
    pub fn ___state162<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state86(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state88(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state89(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state90(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state91(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state92(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state93(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state45(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state80(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state81(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state82(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state84(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state85(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 163
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["}"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S96)
    //   "+" -> Shift(S97)
    //   ">" -> Shift(S174)
    //   "?" -> Shift(S98)
    //
    //   RepeatOp -> S95
    pub fn ___state163<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state96(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state97(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state174(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state98(text, ___lookbehind, ___tokens, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state95(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 164
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["type"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["}"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* (*) "}" [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* (*) "}" ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* (*) "}" ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* (*) "}" ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* (*) "}" ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* (*) "}" ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* (*) "}" ["use"]
    //
    //   "type" -> Shift(S153)
    //   "}" -> Shift(S175)
    //
    //   AssociatedType -> S150
    pub fn ___state164<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<EnumToken>,
        ___sym6: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Type, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state153(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state175(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::AssociatedType(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state150(text, ___lookbehind, ___tokens, ___lookahead, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 165
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   EnumToken = "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" ["}"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "#" Symbol "#" ["{"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //
    //   "#" -> Shift(S49)
    //   "&" -> Shift(S50)
    //   "(" -> Shift(S51)
    //   "::" -> Shift(S52)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S46
    //   Path -> S47
    //   TypeRef -> S176
    pub fn ___state165<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state176(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 166
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["}"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["="]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["}"]
    //   Id = (*) "Id" ["="]
    //   Id = (*) "MacroId" ["="]
    //
    //   "Id" -> Shift(S26)
    //   "MacroId" -> Shift(S28)
    //
    //   Id -> S177
    pub fn ___state166<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state26(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state28(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state177(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 167
    //   (<NotMacroId> ",")* = (<NotMacroId> ",")* (<NotMacroId> ",") (*) [">"]
    //   (<NotMacroId> ",")* = (<NotMacroId> ",")* (<NotMacroId> ",") (*) ["Id"]
    //
    //   ">" -> Reduce((<NotMacroId> ",")* = (<NotMacroId> ",")*, (<NotMacroId> ",") => Call(ActionFn(150));)
    //   "Id" -> Reduce((<NotMacroId> ",")* = (<NotMacroId> ",")*, (<NotMacroId> ",") => Call(ActionFn(150));)
    //
    pub fn ___state167<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
        ___sym1: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action150(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 168
    //   (<NotMacroId> ",") = NotMacroId (*) "," [">"]
    //   (<NotMacroId> ",") = NotMacroId (*) "," ["Id"]
    //   NotMacroId? = NotMacroId (*) [">"]
    //
    //   "," -> Shift(S178)
    //   ">" -> Reduce(NotMacroId? = NotMacroId => Call(ActionFn(147));)
    //
    pub fn ___state168<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state178(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action147(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NotMacroId_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 169
    //   Comma<NotMacroId> = (<NotMacroId> ",")* NotMacroId? (*) [">"]
    //
    //   ">" -> Reduce(Comma<NotMacroId> = (<NotMacroId> ",")*, NotMacroId? => Call(ActionFn(115));)
    //
    pub fn ___state169<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
        ___sym1: &mut Option<::std::option::Option<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action115(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cNotMacroId_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 170
    //   NonterminalName = MacroId "<" Comma<NotMacroId> ">" (*) [":"]
    //   NonterminalName = MacroId "<" Comma<NotMacroId> ">" (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = MacroId, "<", Comma<NotMacroId>, ">" => Call(ActionFn(16));)
    //   "=" -> Reduce(NonterminalName = MacroId, "<", Comma<NotMacroId>, ">" => Call(ActionFn(16));)
    //
    pub fn ___state170<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<NonterminalString>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::Equals, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action16(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::NonterminalName(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 171
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L ("if" <Cond>)? Action @R [";"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? @R [";"]
    //   Alternatives = (*) Alternative ";" [EOF]
    //   Alternatives = (*) Alternative ";" ["#"]
    //   Alternatives = (*) Alternative ";" ["Escape"]
    //   Alternatives = (*) Alternative ";" ["Id"]
    //   Alternatives = (*) Alternative ";" ["MacroId"]
    //   Alternatives = (*) Alternative ";" ["extern"]
    //   Alternatives = (*) Alternative ";" ["pub"]
    //   Alternatives = (*) Alternative ";" ["use"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = (*) "{" Comma<Alternative> "}" ";" ["use"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives [EOF]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["#"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["Escape"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["Id"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["extern"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["pub"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["use"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "=>" -> Reduce(@L =  => Lookahead;)
    //   "=>?" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Reduce(@L =  => Lookahead;)
    //   "{" -> Shift(S182)
    //
    //   @L -> S179
    //   Alternative -> S180
    //   Alternatives -> S181
    pub fn ___state171<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<::std::option::Option<TypeRef>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym7 = &mut Some((___tok));
                ___result = try!(___state182(text, ___lookbehind, ___tokens, ___sym7));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state179(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state180(text, ___lookbehind, ___tokens, ___lookahead, ___sym7));
                }
                ___Nonterminal::Alternatives(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state181(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 172
    //   (":" <TypeRef>) = ":" TypeRef (*) ["="]
    //
    //   "=" -> Reduce((":" <TypeRef>) = ":", TypeRef => Call(ActionFn(118));)
    //
    pub fn ___state172<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Equals, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action118(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 173
    //   Annotation = "#" "[" @L Id @R "]" (*) ["#"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["Escape"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["Id"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["MacroId"]
    //   Annotation = "#" "[" @L Id @R "]" (*) ["pub"]
    //
    //   "#" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => Call(ActionFn(15));)
    //   "Escape" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => Call(ActionFn(15));)
    //   "Id" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => Call(ActionFn(15));)
    //   "MacroId" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => Call(ActionFn(15));)
    //   "pub" -> Reduce(Annotation = "#", "[", @L, Id, @R, "]" => Call(ActionFn(15));)
    //
    pub fn ___state173<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Pub, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___nt = super::___action15(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Annotation(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 174
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["if"]
    //   @R = (*) ["("]
    //   @R = (*) [","]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["}"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S183
    pub fn ___state174<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state183(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 175
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" (*) [EOF]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" (*) ["#"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" (*) ["Escape"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" (*) ["Id"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" (*) ["extern"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" (*) ["pub"]
    //   ExternToken = @L "extern" @R "{" AssociatedType* EnumToken AssociatedType* "}" (*) ["use"]
    //
    //   EOF -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, EnumToken, AssociatedType*, "}" => Call(ActionFn(57));)
    //   "#" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, EnumToken, AssociatedType*, "}" => Call(ActionFn(57));)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, EnumToken, AssociatedType*, "}" => Call(ActionFn(57));)
    //   "Id" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, EnumToken, AssociatedType*, "}" => Call(ActionFn(57));)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, EnumToken, AssociatedType*, "}" => Call(ActionFn(57));)
    //   "extern" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, EnumToken, AssociatedType*, "}" => Call(ActionFn(57));)
    //   "pub" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, EnumToken, AssociatedType*, "}" => Call(ActionFn(57));)
    //   "use" -> Reduce(ExternToken = @L, "extern", @R, "{", AssociatedType*, EnumToken, AssociatedType*, "}" => Call(ActionFn(57));)
    //
    pub fn ___state175<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym5: &mut Option<EnumToken>,
        ___sym6: &mut Option<::std::vec::Vec<AssociatedType>>,
        ___sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action57(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExternToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 176
    //   @R = (*) ["{"]
    //   EnumToken = "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" ["}"]
    //
    //   "{" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S184
    pub fn ___state176<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state184(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 177
    //   @R = (*) ["="]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["}"]
    //   @R = (*) ["="]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["}"]
    //
    //   "=" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S185
    pub fn ___state177<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Equals, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state185(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 178
    //   (<NotMacroId> ",") = NotMacroId "," (*) [">"]
    //   (<NotMacroId> ",") = NotMacroId "," (*) ["Id"]
    //
    //   ">" -> Reduce((<NotMacroId> ",") = NotMacroId, "," => Call(ActionFn(151));)
    //   "Id" -> Reduce((<NotMacroId> ",") = NotMacroId, "," => Call(ActionFn(151));)
    //
    pub fn ___state178<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action151(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cNotMacroId_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 179
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L (*) ("if" <Cond>)? Action @R [";"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [";"]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["=>"]
    //   Symbol+ = (*) Symbol ["=>?"]
    //   Symbol+ = (*) Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["if"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [";"]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>?"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L (*) ("if" <Cond>)? Action @R [","]
    //   Alternative = @L (*) ("if" <Cond>)? Action @R ["}"]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? @R [","]
    //   Alternative = @L (*) Symbol+ ("if" <Cond>)? Action? @R ["}"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["}"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["}"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol = (*) Symbol0 ["}"]
    //   Symbol+ = (*) Symbol ["("]
    //   Symbol+ = (*) Symbol [","]
    //   Symbol+ = (*) Symbol ["<"]
    //   Symbol+ = (*) Symbol ["=>"]
    //   Symbol+ = (*) Symbol ["=>?"]
    //   Symbol+ = (*) Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol ["@L"]
    //   Symbol+ = (*) Symbol ["@R"]
    //   Symbol+ = (*) Symbol ["Escape"]
    //   Symbol+ = (*) Symbol ["Id"]
    //   Symbol+ = (*) Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol ["if"]
    //   Symbol+ = (*) Symbol ["}"]
    //   Symbol+ = (*) Symbol+ Symbol ["("]
    //   Symbol+ = (*) Symbol+ Symbol [","]
    //   Symbol+ = (*) Symbol+ Symbol ["<"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>?"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["=>@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["@L"]
    //   Symbol+ = (*) Symbol+ Symbol ["@R"]
    //   Symbol+ = (*) Symbol+ Symbol ["Escape"]
    //   Symbol+ = (*) Symbol+ Symbol ["Id"]
    //   Symbol+ = (*) Symbol+ Symbol ["MacroId"]
    //   Symbol+ = (*) Symbol+ Symbol ["RegexLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["StringLiteral"]
    //   Symbol+ = (*) Symbol+ Symbol ["if"]
    //   Symbol+ = (*) Symbol+ Symbol ["}"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["}"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol0 = (*) Symbol1 ["}"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["}"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "=>" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "=>?" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "=>@L" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "=>@R" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Shift(S190)
    //
    //   ("if" <Cond>) -> S186
    //   ("if" <Cond>)? -> S187
    //   @L -> S62
    //   Symbol -> S188
    //   Symbol+ -> S189
    //   Symbol0 -> S64
    //   Symbol1 -> S65
    pub fn ___state179<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::If, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state190(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) => {
                let ___nt = super::___action110(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(___nt));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_22if_22_20_3cCond_3e_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state186(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state187(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state62(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state188(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol_2b(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state189(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 180
    //   Alternatives = Alternative (*) ";" [EOF]
    //   Alternatives = Alternative (*) ";" ["#"]
    //   Alternatives = Alternative (*) ";" ["Escape"]
    //   Alternatives = Alternative (*) ";" ["Id"]
    //   Alternatives = Alternative (*) ";" ["MacroId"]
    //   Alternatives = Alternative (*) ";" ["extern"]
    //   Alternatives = Alternative (*) ";" ["pub"]
    //   Alternatives = Alternative (*) ";" ["use"]
    //
    //   ";" -> Shift(S191)
    //
    pub fn ___state180<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state191(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 181
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) [EOF]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["#"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["Escape"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["Id"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["extern"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["pub"]
    //   Nonterminal = Annotation* "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["use"]
    //
    //   EOF -> Reduce(Nonterminal = Annotation*, "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "#" -> Reduce(Nonterminal = Annotation*, "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "Escape" -> Reduce(Nonterminal = Annotation*, "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "Id" -> Reduce(Nonterminal = Annotation*, "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "MacroId" -> Reduce(Nonterminal = Annotation*, "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "extern" -> Reduce(Nonterminal = Annotation*, "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "pub" -> Reduce(Nonterminal = Annotation*, "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //   "use" -> Reduce(Nonterminal = Annotation*, "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(14));)
    //
    pub fn ___state181<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Annotation>>,
        ___sym1: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        ___sym4: &mut Option<usize>,
        ___sym5: &mut Option<::std::option::Option<TypeRef>>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action14(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Nonterminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 182
    //   (<Alternative> ",")* = (*) ["("]
    //   (<Alternative> ",")* = (*) ["<"]
    //   (<Alternative> ",")* = (*) ["=>"]
    //   (<Alternative> ",")* = (*) ["=>?"]
    //   (<Alternative> ",")* = (*) ["=>@L"]
    //   (<Alternative> ",")* = (*) ["=>@R"]
    //   (<Alternative> ",")* = (*) ["@L"]
    //   (<Alternative> ",")* = (*) ["@R"]
    //   (<Alternative> ",")* = (*) ["Escape"]
    //   (<Alternative> ",")* = (*) ["Id"]
    //   (<Alternative> ",")* = (*) ["MacroId"]
    //   (<Alternative> ",")* = (*) ["RegexLiteral"]
    //   (<Alternative> ",")* = (*) ["StringLiteral"]
    //   (<Alternative> ",")* = (*) ["if"]
    //   (<Alternative> ",")* = (*) ["}"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["("]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["<"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["=>"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["=>?"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["=>@L"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["=>@R"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["@L"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["@R"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["Escape"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["Id"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["MacroId"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["RegexLiteral"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["StringLiteral"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["if"]
    //   (<Alternative> ",")* = (*) (<Alternative> ",")* (<Alternative> ",") ["}"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" [EOF]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["#"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["Escape"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["Id"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["MacroId"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["extern"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["pub"]
    //   Alternatives = "{" (*) Comma<Alternative> "}" ";" ["use"]
    //   Comma<Alternative> = (*) (<Alternative> ",")* Alternative? ["}"]
    //
    //   "(" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "<" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "=>" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "=>?" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "=>@L" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "=>@R" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "@L" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "@R" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "Escape" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "Id" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "MacroId" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "RegexLiteral" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "StringLiteral" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "if" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //   "}" -> Reduce((<Alternative> ",")* =  => Call(ActionFn(154));)
    //
    //   (<Alternative> ",")* -> S192
    //   Comma<Alternative> -> S193
    pub fn ___state182<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action154(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cAlternative_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cAlternative_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state192(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cAlternative_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state193(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 183
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["}"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ";" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "=>" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "=>?" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "=>@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "=>@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "if" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "}" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //
    pub fn ___state183<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action33(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 184
    //   EnumToken = "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" ["}"]
    //
    //   "{" -> Shift(S194)
    //
    pub fn ___state184<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state194(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 185
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["}"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["}"]
    //
    //   "=" -> Shift(S195)
    //
    pub fn ___state185<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Equals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state195(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 186
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>?"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@L"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@R"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) [";"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>?"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@L"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@R"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) [","]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>?"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@L"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@R"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["}"]
    //
    //   "," -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(109));)
    //   ";" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(109));)
    //   "=>" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(109));)
    //   "=>?" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(109));)
    //   "=>@L" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(109));)
    //   "=>@R" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(109));)
    //   "}" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(109));)
    //
    pub fn ___state186<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Condition>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action109(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 187
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Alternative = @L ("if" <Cond>)? (*) Action @R [";"]
    //   Action = (*) "=>" [","]
    //   Action = (*) "=>" ["}"]
    //   Action = (*) "=>?" [","]
    //   Action = (*) "=>?" ["}"]
    //   Action = (*) "=>@L" [","]
    //   Action = (*) "=>@L" ["}"]
    //   Action = (*) "=>@R" [","]
    //   Action = (*) "=>@R" ["}"]
    //   Alternative = @L ("if" <Cond>)? (*) Action @R [","]
    //   Alternative = @L ("if" <Cond>)? (*) Action @R ["}"]
    //
    //   "=>" -> Shift(S197)
    //   "=>?" -> Shift(S198)
    //   "=>@L" -> Shift(S199)
    //   "=>@R" -> Shift(S200)
    //
    //   Action -> S196
    pub fn ___state187<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::option::Option<Condition>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state197(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state198(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state199(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state200(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Action(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state196(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 188
    //   Symbol+ = Symbol (*) ["("]
    //   Symbol+ = Symbol (*) [";"]
    //   Symbol+ = Symbol (*) ["<"]
    //   Symbol+ = Symbol (*) ["=>"]
    //   Symbol+ = Symbol (*) ["=>?"]
    //   Symbol+ = Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol (*) ["@L"]
    //   Symbol+ = Symbol (*) ["@R"]
    //   Symbol+ = Symbol (*) ["Escape"]
    //   Symbol+ = Symbol (*) ["Id"]
    //   Symbol+ = Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol (*) ["if"]
    //   Symbol+ = Symbol (*) ["("]
    //   Symbol+ = Symbol (*) [","]
    //   Symbol+ = Symbol (*) ["<"]
    //   Symbol+ = Symbol (*) ["=>"]
    //   Symbol+ = Symbol (*) ["=>?"]
    //   Symbol+ = Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol (*) ["@L"]
    //   Symbol+ = Symbol (*) ["@R"]
    //   Symbol+ = Symbol (*) ["Escape"]
    //   Symbol+ = Symbol (*) ["Id"]
    //   Symbol+ = Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol (*) ["if"]
    //   Symbol+ = Symbol (*) ["}"]
    //
    //   "(" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "," -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   ";" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "<" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "=>" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "=>?" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "=>@L" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "=>@R" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "@L" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "@R" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "Escape" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "Id" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "MacroId" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "RegexLiteral" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "if" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //   "}" -> Reduce(Symbol+ = Symbol => Call(ActionFn(112));)
    //
    pub fn ___state188<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action112(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 189
    //   ("if" <Cond>) = (*) "if" Cond [";"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) [";"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) [";"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [";"]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>?"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["RegexLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   ("if" <Cond>) = (*) "if" Cond [","]
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>) = (*) "if" Cond ["}"]
    //   ("if" <Cond>)? = (*) [","]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ["}"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) [","]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["}"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? @R [","]
    //   Alternative = @L Symbol+ (*) ("if" <Cond>)? Action? @R ["}"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["}"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["}"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol = (*) Symbol0 ["}"]
    //   Symbol+ = Symbol+ (*) Symbol ["("]
    //   Symbol+ = Symbol+ (*) Symbol [","]
    //   Symbol+ = Symbol+ (*) Symbol ["<"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>?"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["=>@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["@L"]
    //   Symbol+ = Symbol+ (*) Symbol ["@R"]
    //   Symbol+ = Symbol+ (*) Symbol ["Escape"]
    //   Symbol+ = Symbol+ (*) Symbol ["Id"]
    //   Symbol+ = Symbol+ (*) Symbol ["MacroId"]
    //   Symbol+ = Symbol+ (*) Symbol ["RegexLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["StringLiteral"]
    //   Symbol+ = Symbol+ (*) Symbol ["if"]
    //   Symbol+ = Symbol+ (*) Symbol ["}"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["}"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol0 = (*) Symbol1 ["}"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["}"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "," -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   ";" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "=>" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "=>?" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "=>@L" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "=>@R" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Shift(S190)
    //   "}" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(110));)
    //
    //   ("if" <Cond>) -> S186
    //   ("if" <Cond>)? -> S201
    //   @L -> S62
    //   Symbol -> S202
    //   Symbol0 -> S64
    //   Symbol1 -> S65
    pub fn ___state189<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::If, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state190(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action110(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(___nt));
            }
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_22if_22_20_3cCond_3e_29(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state186(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state201(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state62(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state202(text, ___lookbehind, ___tokens, ___lookahead, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 190
    //   ("if" <Cond>) = "if" (*) Cond ["=>"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>?"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@L"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@R"]
    //   @L = (*) ["Id"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   ("if" <Cond>) = "if" (*) Cond [";"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>?"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@L"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@R"]
    //   @L = (*) ["Id"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R [";"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   ("if" <Cond>) = "if" (*) Cond [","]
    //   ("if" <Cond>) = "if" (*) Cond ["=>"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>?"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@L"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@R"]
    //   ("if" <Cond>) = "if" (*) Cond ["}"]
    //   @L = (*) ["Id"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R [","]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   Cond = (*) @L NotMacroId CondOp StringLiteral @R ["}"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S203
    //   Cond -> S204
    pub fn ___state190<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state203(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Cond(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state204(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 191
    //   Alternatives = Alternative ";" (*) [EOF]
    //   Alternatives = Alternative ";" (*) ["#"]
    //   Alternatives = Alternative ";" (*) ["Escape"]
    //   Alternatives = Alternative ";" (*) ["Id"]
    //   Alternatives = Alternative ";" (*) ["MacroId"]
    //   Alternatives = Alternative ";" (*) ["extern"]
    //   Alternatives = Alternative ";" (*) ["pub"]
    //   Alternatives = Alternative ";" (*) ["use"]
    //
    //   EOF -> Reduce(Alternatives = Alternative, ";" => Call(ActionFn(19));)
    //   "#" -> Reduce(Alternatives = Alternative, ";" => Call(ActionFn(19));)
    //   "Escape" -> Reduce(Alternatives = Alternative, ";" => Call(ActionFn(19));)
    //   "Id" -> Reduce(Alternatives = Alternative, ";" => Call(ActionFn(19));)
    //   "MacroId" -> Reduce(Alternatives = Alternative, ";" => Call(ActionFn(19));)
    //   "extern" -> Reduce(Alternatives = Alternative, ";" => Call(ActionFn(19));)
    //   "pub" -> Reduce(Alternatives = Alternative, ";" => Call(ActionFn(19));)
    //   "use" -> Reduce(Alternatives = Alternative, ";" => Call(ActionFn(19));)
    //
    pub fn ___state191<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Alternative>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action19(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternatives(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 192
    //   (<Alternative> ",") = (*) Alternative "," ["("]
    //   (<Alternative> ",") = (*) Alternative "," ["<"]
    //   (<Alternative> ",") = (*) Alternative "," ["=>"]
    //   (<Alternative> ",") = (*) Alternative "," ["=>?"]
    //   (<Alternative> ",") = (*) Alternative "," ["=>@L"]
    //   (<Alternative> ",") = (*) Alternative "," ["=>@R"]
    //   (<Alternative> ",") = (*) Alternative "," ["@L"]
    //   (<Alternative> ",") = (*) Alternative "," ["@R"]
    //   (<Alternative> ",") = (*) Alternative "," ["Escape"]
    //   (<Alternative> ",") = (*) Alternative "," ["Id"]
    //   (<Alternative> ",") = (*) Alternative "," ["MacroId"]
    //   (<Alternative> ",") = (*) Alternative "," ["RegexLiteral"]
    //   (<Alternative> ",") = (*) Alternative "," ["StringLiteral"]
    //   (<Alternative> ",") = (*) Alternative "," ["if"]
    //   (<Alternative> ",") = (*) Alternative "," ["}"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["("]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["<"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["=>"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["=>?"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["=>@L"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["=>@R"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["@L"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["@R"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["Escape"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["Id"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["MacroId"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["RegexLiteral"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["StringLiteral"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["if"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (*) (<Alternative> ",") ["}"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L ("if" <Cond>)? Action @R [","]
    //   Alternative = (*) @L ("if" <Cond>)? Action @R ["}"]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? @R [","]
    //   Alternative = (*) @L Symbol+ ("if" <Cond>)? Action? @R ["}"]
    //   Alternative? = (*) ["}"]
    //   Alternative? = (*) Alternative ["}"]
    //   Comma<Alternative> = (<Alternative> ",")* (*) Alternative? ["}"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "=>" -> Reduce(@L =  => Lookahead;)
    //   "=>?" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Reduce(@L =  => Lookahead;)
    //   "}" -> Reduce(Alternative? =  => Call(ActionFn(153));)
    //
    //   (<Alternative> ",") -> S205
    //   @L -> S179
    //   Alternative -> S206
    //   Alternative? -> S207
    pub fn ___state192<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action153(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Alternative_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cAlternative_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state205(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state179(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Alternative(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state206(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Alternative_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state207(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 193
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" [EOF]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["#"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["Escape"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["Id"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["MacroId"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["extern"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["pub"]
    //   Alternatives = "{" Comma<Alternative> (*) "}" ";" ["use"]
    //
    //   "}" -> Shift(S208)
    //
    pub fn ___state193<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state208(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 194
    //   (<Conversion> ",")* = (*) ["Id"]
    //   (<Conversion> ",")* = (*) ["RegexLiteral"]
    //   (<Conversion> ",")* = (*) ["StringLiteral"]
    //   (<Conversion> ",")* = (*) ["}"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["Id"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["RegexLiteral"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["StringLiteral"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["}"]
    //   Comma<Conversion> = (*) (<Conversion> ",")* Conversion? ["}"]
    //   EnumToken = "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" ["type"]
    //   EnumToken = "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" ["}"]
    //
    //   "Id" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(174));)
    //   "RegexLiteral" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(174));)
    //   "StringLiteral" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(174));)
    //   "}" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(174));)
    //
    //   (<Conversion> ",")* -> S209
    //   Comma<Conversion> -> S210
    pub fn ___state194<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action174(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state209(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Comma_3cConversion_3e(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state210(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 195
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["}"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["}"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "#" Symbol "#" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "#" -> Shift(S49)
    //   "&" -> Shift(S50)
    //   "(" -> Shift(S51)
    //   "::" -> Shift(S52)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S46
    //   Path -> S47
    //   TypeRef -> S211
    pub fn ___state195<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym5 = &mut Some((___tok));
                ___result = try!(___state52(text, ___lookbehind, ___tokens, ___sym5));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state211(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 196
    //   @R = (*) [";"]
    //   Alternative = @L ("if" <Cond>)? Action (*) @R [";"]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Alternative = @L ("if" <Cond>)? Action (*) @R [","]
    //   Alternative = @L ("if" <Cond>)? Action (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S212
    pub fn ___state196<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::option::Option<Condition>>,
        ___sym2: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state212(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 197
    //   Action = "=>" (*) [";"]
    //   Action = "=>" (*) [","]
    //   Action = "=>" (*) ["}"]
    //
    //   "," -> Reduce(Action = "=>" => Call(ActionFn(25));)
    //   ";" -> Reduce(Action = "=>" => Call(ActionFn(25));)
    //   "}" -> Reduce(Action = "=>" => Call(ActionFn(25));)
    //
    pub fn ___state197<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action25(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 198
    //   Action = "=>?" (*) [";"]
    //   Action = "=>?" (*) [","]
    //   Action = "=>?" (*) ["}"]
    //
    //   "," -> Reduce(Action = "=>?" => Call(ActionFn(26));)
    //   ";" -> Reduce(Action = "=>?" => Call(ActionFn(26));)
    //   "}" -> Reduce(Action = "=>?" => Call(ActionFn(26));)
    //
    pub fn ___state198<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action26(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 199
    //   Action = "=>@L" (*) [";"]
    //   Action = "=>@L" (*) [","]
    //   Action = "=>@L" (*) ["}"]
    //
    //   "," -> Reduce(Action = "=>@L" => Call(ActionFn(23));)
    //   ";" -> Reduce(Action = "=>@L" => Call(ActionFn(23));)
    //   "}" -> Reduce(Action = "=>@L" => Call(ActionFn(23));)
    //
    pub fn ___state199<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action23(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 200
    //   Action = "=>@R" (*) [";"]
    //   Action = "=>@R" (*) [","]
    //   Action = "=>@R" (*) ["}"]
    //
    //   "," -> Reduce(Action = "=>@R" => Call(ActionFn(24));)
    //   ";" -> Reduce(Action = "=>@R" => Call(ActionFn(24));)
    //   "}" -> Reduce(Action = "=>@R" => Call(ActionFn(24));)
    //
    pub fn ___state200<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action24(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 201
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Action? = (*) [";"]
    //   Action? = (*) Action [";"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? @R [";"]
    //   Action = (*) "=>" [","]
    //   Action = (*) "=>" ["}"]
    //   Action = (*) "=>?" [","]
    //   Action = (*) "=>?" ["}"]
    //   Action = (*) "=>@L" [","]
    //   Action = (*) "=>@L" ["}"]
    //   Action = (*) "=>@R" [","]
    //   Action = (*) "=>@R" ["}"]
    //   Action? = (*) [","]
    //   Action? = (*) ["}"]
    //   Action? = (*) Action [","]
    //   Action? = (*) Action ["}"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? @R [","]
    //   Alternative = @L Symbol+ ("if" <Cond>)? (*) Action? @R ["}"]
    //
    //   "," -> Reduce(Action? =  => Call(ActionFn(108));)
    //   ";" -> Reduce(Action? =  => Call(ActionFn(108));)
    //   "=>" -> Shift(S197)
    //   "=>?" -> Shift(S198)
    //   "=>@L" -> Shift(S199)
    //   "=>@R" -> Shift(S200)
    //   "}" -> Reduce(Action? =  => Call(ActionFn(108));)
    //
    //   Action -> S213
    //   Action? -> S214
    pub fn ___state201<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<::std::option::Option<Condition>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state197(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state198(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state199(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::EqualsGreaterThanLookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state200(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action108(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Action_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Action(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state213(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Action_3f(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state214(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 202
    //   Symbol+ = Symbol+ Symbol (*) ["("]
    //   Symbol+ = Symbol+ Symbol (*) [";"]
    //   Symbol+ = Symbol+ Symbol (*) ["<"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>?"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["Escape"]
    //   Symbol+ = Symbol+ Symbol (*) ["Id"]
    //   Symbol+ = Symbol+ Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol+ Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["if"]
    //   Symbol+ = Symbol+ Symbol (*) ["("]
    //   Symbol+ = Symbol+ Symbol (*) [","]
    //   Symbol+ = Symbol+ Symbol (*) ["<"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>?"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["=>@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["@L"]
    //   Symbol+ = Symbol+ Symbol (*) ["@R"]
    //   Symbol+ = Symbol+ Symbol (*) ["Escape"]
    //   Symbol+ = Symbol+ Symbol (*) ["Id"]
    //   Symbol+ = Symbol+ Symbol (*) ["MacroId"]
    //   Symbol+ = Symbol+ Symbol (*) ["RegexLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["StringLiteral"]
    //   Symbol+ = Symbol+ Symbol (*) ["if"]
    //   Symbol+ = Symbol+ Symbol (*) ["}"]
    //
    //   "(" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "," -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   ";" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "<" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "=>" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "=>?" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "=>@L" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "=>@R" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "@L" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "@R" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "Escape" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "Id" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "MacroId" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "RegexLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "StringLiteral" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "if" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //   "}" -> Reduce(Symbol+ = Symbol+, Symbol => Call(ActionFn(113));)
    //
    pub fn ___state202<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action113(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2b(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 203
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   NotMacroId = (*) "Id" ["!="]
    //   NotMacroId = (*) "Id" ["!~"]
    //   NotMacroId = (*) "Id" ["=="]
    //   NotMacroId = (*) "Id" ["~~"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R [";"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   NotMacroId = (*) "Id" ["!="]
    //   NotMacroId = (*) "Id" ["!~"]
    //   NotMacroId = (*) "Id" ["=="]
    //   NotMacroId = (*) "Id" ["~~"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R [","]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>?"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["=>@R"]
    //   Cond = @L (*) NotMacroId CondOp StringLiteral @R ["}"]
    //   NotMacroId = (*) "Id" ["!="]
    //   NotMacroId = (*) "Id" ["!~"]
    //   NotMacroId = (*) "Id" ["=="]
    //   NotMacroId = (*) "Id" ["~~"]
    //
    //   "Id" -> Shift(S129)
    //
    //   NotMacroId -> S215
    pub fn ___state203<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state129(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::NotMacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state215(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 204
    //   ("if" <Cond>) = "if" Cond (*) ["=>"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>?"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@L"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@R"]
    //   ("if" <Cond>) = "if" Cond (*) [";"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>?"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@L"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@R"]
    //   ("if" <Cond>) = "if" Cond (*) [","]
    //   ("if" <Cond>) = "if" Cond (*) ["=>"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>?"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@L"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@R"]
    //   ("if" <Cond>) = "if" Cond (*) ["}"]
    //
    //   "," -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(111));)
    //   ";" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(111));)
    //   "=>" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(111));)
    //   "=>?" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(111));)
    //   "=>@L" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(111));)
    //   "=>@R" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(111));)
    //   "}" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(111));)
    //
    pub fn ___state204<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Condition>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action111(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_22if_22_20_3cCond_3e_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 205
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["("]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["<"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["=>"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["=>?"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["=>@L"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["=>@R"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["@L"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["@R"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["Escape"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["Id"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["MacroId"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["RegexLiteral"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["StringLiteral"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["if"]
    //   (<Alternative> ",")* = (<Alternative> ",")* (<Alternative> ",") (*) ["}"]
    //
    //   "(" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "<" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "=>" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "=>?" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "=>@L" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "=>@R" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "@L" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "@R" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "Escape" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "Id" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "MacroId" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "RegexLiteral" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "StringLiteral" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "if" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //   "}" -> Reduce((<Alternative> ",")* = (<Alternative> ",")*, (<Alternative> ",") => Call(ActionFn(155));)
    //
    pub fn ___state205<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Alternative>>,
        ___sym1: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action155(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cAlternative_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 206
    //   (<Alternative> ",") = Alternative (*) "," ["("]
    //   (<Alternative> ",") = Alternative (*) "," ["<"]
    //   (<Alternative> ",") = Alternative (*) "," ["=>"]
    //   (<Alternative> ",") = Alternative (*) "," ["=>?"]
    //   (<Alternative> ",") = Alternative (*) "," ["=>@L"]
    //   (<Alternative> ",") = Alternative (*) "," ["=>@R"]
    //   (<Alternative> ",") = Alternative (*) "," ["@L"]
    //   (<Alternative> ",") = Alternative (*) "," ["@R"]
    //   (<Alternative> ",") = Alternative (*) "," ["Escape"]
    //   (<Alternative> ",") = Alternative (*) "," ["Id"]
    //   (<Alternative> ",") = Alternative (*) "," ["MacroId"]
    //   (<Alternative> ",") = Alternative (*) "," ["RegexLiteral"]
    //   (<Alternative> ",") = Alternative (*) "," ["StringLiteral"]
    //   (<Alternative> ",") = Alternative (*) "," ["if"]
    //   (<Alternative> ",") = Alternative (*) "," ["}"]
    //   Alternative? = Alternative (*) ["}"]
    //
    //   "," -> Shift(S216)
    //   "}" -> Reduce(Alternative? = Alternative => Call(ActionFn(152));)
    //
    pub fn ___state206<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state216(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action152(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 207
    //   Comma<Alternative> = (<Alternative> ",")* Alternative? (*) ["}"]
    //
    //   "}" -> Reduce(Comma<Alternative> = (<Alternative> ",")*, Alternative? => Call(ActionFn(114));)
    //
    pub fn ___state207<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Alternative>>,
        ___sym1: &mut Option<::std::option::Option<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action114(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cAlternative_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 208
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" [EOF]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["#"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["Escape"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["Id"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["MacroId"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["extern"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["pub"]
    //   Alternatives = "{" Comma<Alternative> "}" (*) ";" ["use"]
    //
    //   ";" -> Shift(S217)
    //
    pub fn ___state208<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Alternative>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state217(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 209
    //   (<Conversion> ",") = (*) Conversion "," ["Id"]
    //   (<Conversion> ",") = (*) Conversion "," ["RegexLiteral"]
    //   (<Conversion> ",") = (*) Conversion "," ["StringLiteral"]
    //   (<Conversion> ",") = (*) Conversion "," ["}"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["Id"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["RegexLiteral"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["StringLiteral"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Conversion> = (<Conversion> ",")* (*) Conversion? ["}"]
    //   Conversion = (*) @L Terminal @L "=>" @R [","]
    //   Conversion = (*) @L Terminal @L "=>" @R ["}"]
    //   Conversion? = (*) ["}"]
    //   Conversion? = (*) Conversion ["}"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "}" -> Reduce(Conversion? =  => Call(ActionFn(173));)
    //
    //   (<Conversion> ",") -> S218
    //   @L -> S219
    //   Conversion -> S220
    //   Conversion? -> S221
    pub fn ___state209<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action173(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Conversion_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cConversion_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state218(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state219(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Conversion(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state220(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Conversion_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state221(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 210
    //   EnumToken = "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" ["type"]
    //   EnumToken = "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" ["}"]
    //
    //   "}" -> Shift(S222)
    //
    pub fn ___state210<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Vec<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state222(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 211
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["enum"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["}"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["}"]
    //
    //   ";" -> Shift(S223)
    //
    pub fn ___state211<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Semi, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state223(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 212
    //   Alternative = @L ("if" <Cond>)? Action @R (*) [";"]
    //   Alternative = @L ("if" <Cond>)? Action @R (*) [","]
    //   Alternative = @L ("if" <Cond>)? Action @R (*) ["}"]
    //
    //   "," -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, @R => Call(ActionFn(22));)
    //   ";" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, @R => Call(ActionFn(22));)
    //   "}" -> Reduce(Alternative = @L, ("if" <Cond>)?, Action, @R => Call(ActionFn(22));)
    //
    pub fn ___state212<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::option::Option<Condition>>,
        ___sym2: &mut Option<ActionKind>,
        ___sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action22(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 213
    //   Action? = Action (*) [";"]
    //   Action? = Action (*) [","]
    //   Action? = Action (*) ["}"]
    //
    //   "," -> Reduce(Action? = Action => Call(ActionFn(107));)
    //   ";" -> Reduce(Action? = Action => Call(ActionFn(107));)
    //   "}" -> Reduce(Action? = Action => Call(ActionFn(107));)
    //
    pub fn ___state213<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action107(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Action_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 214
    //   @R = (*) [";"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) @R [";"]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) @R [","]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S224
    pub fn ___state214<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<::std::option::Option<Condition>>,
        ___sym3: &mut Option<::std::option::Option<ActionKind>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state224(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 215
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@R"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R [";"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@R"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R [","]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["=>@R"]
    //   Cond = @L NotMacroId (*) CondOp StringLiteral @R ["}"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //
    //   "!=" -> Shift(S226)
    //   "!~" -> Shift(S227)
    //   "==" -> Shift(S228)
    //   "~~" -> Shift(S229)
    //
    //   CondOp -> S225
    pub fn ___state215<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::BangEquals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state226(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::BangTilde, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state227(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::EqualsEquals, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state228(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, ___tok @ Tok::TildeTilde, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state229(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::CondOp(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state225(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 216
    //   (<Alternative> ",") = Alternative "," (*) ["("]
    //   (<Alternative> ",") = Alternative "," (*) ["<"]
    //   (<Alternative> ",") = Alternative "," (*) ["=>"]
    //   (<Alternative> ",") = Alternative "," (*) ["=>?"]
    //   (<Alternative> ",") = Alternative "," (*) ["=>@L"]
    //   (<Alternative> ",") = Alternative "," (*) ["=>@R"]
    //   (<Alternative> ",") = Alternative "," (*) ["@L"]
    //   (<Alternative> ",") = Alternative "," (*) ["@R"]
    //   (<Alternative> ",") = Alternative "," (*) ["Escape"]
    //   (<Alternative> ",") = Alternative "," (*) ["Id"]
    //   (<Alternative> ",") = Alternative "," (*) ["MacroId"]
    //   (<Alternative> ",") = Alternative "," (*) ["RegexLiteral"]
    //   (<Alternative> ",") = Alternative "," (*) ["StringLiteral"]
    //   (<Alternative> ",") = Alternative "," (*) ["if"]
    //   (<Alternative> ",") = Alternative "," (*) ["}"]
    //
    //   "(" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "<" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "=>" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "=>?" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "=>@L" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "=>@R" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "@L" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "@R" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "Escape" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "Id" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "MacroId" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "RegexLiteral" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "StringLiteral" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "if" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //   "}" -> Reduce((<Alternative> ",") = Alternative, "," => Call(ActionFn(156));)
    //
    pub fn ___state216<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Alternative>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::If, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action156(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cAlternative_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 217
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) [EOF]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["#"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["Escape"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["Id"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["MacroId"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["extern"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["pub"]
    //   Alternatives = "{" Comma<Alternative> "}" ";" (*) ["use"]
    //
    //   EOF -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => Call(ActionFn(20));)
    //   "#" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => Call(ActionFn(20));)
    //   "Escape" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => Call(ActionFn(20));)
    //   "Id" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => Call(ActionFn(20));)
    //   "MacroId" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => Call(ActionFn(20));)
    //   "extern" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => Call(ActionFn(20));)
    //   "pub" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => Call(ActionFn(20));)
    //   "use" -> Reduce(Alternatives = "{", Comma<Alternative>, "}", ";" => Call(ActionFn(20));)
    //
    pub fn ___state217<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Alternative>>,
        ___sym2: &mut Option<Tok<'input>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Extern, _)) |
            Some((_, Tok::Pub, _)) |
            Some((_, Tok::Use(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action20(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternatives(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 218
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["Id"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["RegexLiteral"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["StringLiteral"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["}"]
    //
    //   "Id" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(175));)
    //   "RegexLiteral" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(175));)
    //   "StringLiteral" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(175));)
    //   "}" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(175));)
    //
    pub fn ___state218<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Conversion>>,
        ___sym1: &mut Option<Conversion>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action175(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 219
    //   Conversion = @L (*) Terminal @L "=>" @R [","]
    //   Conversion = @L (*) Terminal @L "=>" @R ["}"]
    //   QuotedTerminal = (*) RegexLiteral ["=>"]
    //   QuotedTerminal = (*) StringLiteral ["=>"]
    //   RegexLiteral = (*) "RegexLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   Terminal = (*) QuotedTerminal ["=>"]
    //   Terminal = (*) "Id" ["=>"]
    //
    //   "Id" -> Shift(S232)
    //   "RegexLiteral" -> Shift(S93)
    //   "StringLiteral" -> Shift(S45)
    //
    //   QuotedTerminal -> S230
    //   RegexLiteral -> S83
    //   StringLiteral -> S84
    //   Terminal -> S231
    pub fn ___state219<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state232(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state93(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state45(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state230(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state84(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Terminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state231(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 220
    //   (<Conversion> ",") = Conversion (*) "," ["Id"]
    //   (<Conversion> ",") = Conversion (*) "," ["RegexLiteral"]
    //   (<Conversion> ",") = Conversion (*) "," ["StringLiteral"]
    //   (<Conversion> ",") = Conversion (*) "," ["}"]
    //   Conversion? = Conversion (*) ["}"]
    //
    //   "," -> Shift(S233)
    //   "}" -> Reduce(Conversion? = Conversion => Call(ActionFn(172));)
    //
    pub fn ___state220<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Conversion>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state233(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action172(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Conversion_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 221
    //   Comma<Conversion> = (<Conversion> ",")* Conversion? (*) ["}"]
    //
    //   "}" -> Reduce(Comma<Conversion> = (<Conversion> ",")*, Conversion? => Call(ActionFn(90));)
    //
    pub fn ___state221<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Conversion>>,
        ___sym1: &mut Option<::std::option::Option<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action90(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cConversion_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 222
    //   EnumToken = "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) ["type"]
    //   EnumToken = "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) ["}"]
    //
    //   "type" -> Reduce(EnumToken = "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}" => Call(ActionFn(59));)
    //   "}" -> Reduce(EnumToken = "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}" => Call(ActionFn(59));)
    //
    pub fn ___state222<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<TypeRef>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Vec<Conversion>>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action59(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::EnumToken(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 223
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["enum"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["}"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["}"]
    //
    //   "enum" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(60));)
    //   "type" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(60));)
    //   "}" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(60));)
    //
    pub fn ___state223<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<usize>,
        ___sym2: &mut Option<InternedString>,
        ___sym3: &mut Option<usize>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<TypeRef>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Enum, _)) |
            Some((_, Tok::Type, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___nt = super::___action60(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::AssociatedType(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 224
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? @R (*) [";"]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? @R (*) [","]
    //   Alternative = @L Symbol+ ("if" <Cond>)? Action? @R (*) ["}"]
    //
    //   "," -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, @R => Call(ActionFn(21));)
    //   ";" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, @R => Call(ActionFn(21));)
    //   "}" -> Reduce(Alternative = @L, Symbol+, ("if" <Cond>)?, Action?, @R => Call(ActionFn(21));)
    //
    pub fn ___state224<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym2: &mut Option<::std::option::Option<Condition>>,
        ___sym3: &mut Option<::std::option::Option<ActionKind>>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action21(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Alternative(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 225
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R [";"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" [";"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R [","]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>?"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["=>@R"]
    //   Cond = @L NotMacroId CondOp (*) StringLiteral @R ["}"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["}"]
    //
    //   "StringLiteral" -> Shift(S45)
    //
    //   StringLiteral -> S234
    pub fn ___state225<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<NonterminalString>,
        ___sym2: &mut Option<ConditionOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state45(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state234(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 226
    //   CondOp = "!=" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "!=" => Call(ActionFn(29));)
    //
    pub fn ___state226<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action29(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::CondOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 227
    //   CondOp = "!~" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "!~" => Call(ActionFn(31));)
    //
    pub fn ___state227<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action31(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::CondOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 228
    //   CondOp = "==" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "==" => Call(ActionFn(28));)
    //
    pub fn ___state228<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action28(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::CondOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 229
    //   CondOp = "~~" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "~~" => Call(ActionFn(30));)
    //
    pub fn ___state229<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action30(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::CondOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 230
    //   Terminal = QuotedTerminal (*) ["=>"]
    //
    //   "=>" -> Reduce(Terminal = QuotedTerminal => Call(ActionFn(78));)
    //
    pub fn ___state230<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action78(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Terminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 231
    //   @L = (*) ["=>"]
    //   Conversion = @L Terminal (*) @L "=>" @R [","]
    //   Conversion = @L Terminal (*) @L "=>" @R ["}"]
    //
    //   "=>" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S235
    pub fn ___state231<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state235(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 232
    //   Terminal = "Id" (*) ["=>"]
    //
    //   "=>" -> Reduce(Terminal = "Id" => Call(ActionFn(79));)
    //
    pub fn ___state232<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action79(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Terminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 233
    //   (<Conversion> ",") = Conversion "," (*) ["Id"]
    //   (<Conversion> ",") = Conversion "," (*) ["RegexLiteral"]
    //   (<Conversion> ",") = Conversion "," (*) ["StringLiteral"]
    //   (<Conversion> ",") = Conversion "," (*) ["}"]
    //
    //   "Id" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(176));)
    //   "RegexLiteral" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(176));)
    //   "StringLiteral" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(176));)
    //   "}" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(176));)
    //
    pub fn ___state233<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Conversion>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action176(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cConversion_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 234
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@R"]
    //   @R = (*) [";"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R [";"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@R"]
    //   @R = (*) [","]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["}"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R [","]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S236
    pub fn ___state234<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<NonterminalString>,
        ___sym2: &mut Option<ConditionOp>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state236(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 235
    //   Conversion = @L Terminal @L (*) "=>" @R [","]
    //   Conversion = @L Terminal @L (*) "=>" @R ["}"]
    //
    //   "=>" -> Shift(S237)
    //
    pub fn ___state235<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<TerminalString>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::EqualsGreaterThanCode(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state237(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 236
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) [";"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) [","]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>?"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@L"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["=>@R"]
    //   Cond = @L NotMacroId CondOp StringLiteral @R (*) ["}"]
    //
    //   "," -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(27));)
    //   ";" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(27));)
    //   "=>" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(27));)
    //   "=>?" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(27));)
    //   "=>@L" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(27));)
    //   "=>@R" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(27));)
    //   "}" -> Reduce(Cond = @L, NotMacroId, CondOp, StringLiteral, @R => Call(ActionFn(27));)
    //
    pub fn ___state236<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<NonterminalString>,
        ___sym2: &mut Option<ConditionOp>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Semi, _)) |
            Some((_, Tok::EqualsGreaterThanCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) |
            Some((_, Tok::EqualsGreaterThanLookahead, _)) |
            Some((_, Tok::EqualsGreaterThanLookbehind, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action27(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Cond(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 237
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Conversion = @L Terminal @L "=>" (*) @R [","]
    //   Conversion = @L Terminal @L "=>" (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S238
    pub fn ___state237<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<TerminalString>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state238(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 238
    //   Conversion = @L Terminal @L "=>" @R (*) [","]
    //   Conversion = @L Terminal @L "=>" @R (*) ["}"]
    //
    //   "," -> Reduce(Conversion = @L, Terminal, @L, "=>", @R => TryCall(ActionFn(61));)
    //   "}" -> Reduce(Conversion = @L, Terminal, @L, "=>", @R => TryCall(ActionFn(61));)
    //
    pub fn ___state238<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<TerminalString>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<&'input str>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = try!(super::___action61(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Conversion(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
pub use self::___parse___Grammar::parse_Grammar;

mod ___parse___Pattern {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as ___lalrpop_util;
    use self::___lalrpop_util::ParseError as ___ParseError;
    use super::___ToTriple;
    pub fn parse_Pattern<
        'input,
        ___TOKEN: ___ToTriple<'input, Error=tok::Error>,
        ___TOKENS: IntoIterator<Item=___TOKEN>,
    >(
        text: &'input str,
        ___tokens: ___TOKENS,
    ) -> Result<Pattern<TypeRef>, ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let ___tokens = ___tokens.into_iter();
        let mut ___tokens = ___tokens.map(|t| ___ToTriple::to_triple(t));
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match try!(___state0(text, None, &mut ___tokens, ___lookahead)) {
            (_, Some(___lookahead), _) => {
                Err(___ParseError::ExtraToken { token: ___lookahead })
            }
            (_, None, ___Nonterminal::______Pattern(___nt)) => {
                Ok(___nt)
            }
            _ => unreachable!(),
        }
    }

    #[allow(dead_code)]
    pub enum ___Nonterminal<'input> {
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        _28_22if_22_20_3cCond_3e_29(Condition),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        _28_3cAlternative_3e_20_22_2c_22_29(Alternative),
        _28_3cAlternative_3e_20_22_2c_22_29_2a(::std::vec::Vec<Alternative>),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _40L(usize),
        _40R(usize),
        Action(ActionKind),
        Action_3f(::std::option::Option<ActionKind>),
        Algorithm(Algorithm),
        Algorithm_3f(::std::option::Option<Algorithm>),
        Alternative(Alternative),
        Alternative_3f(::std::option::Option<Alternative>),
        Alternatives(Vec<Alternative>),
        Annotation(Annotation),
        Annotation_2a(::std::vec::Vec<Annotation>),
        AssociatedType(AssociatedType),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        Comma_3cAlternative_3e(Vec<Alternative>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        Cond(Condition),
        CondOp(ConditionOp),
        Conversion(Conversion),
        Conversion_3f(::std::option::Option<Conversion>),
        EnumToken(EnumToken),
        Escape(InternedString),
        ExprSymbol(ExprSymbol),
        ExternToken(GrammarItem),
        FieldPattern(FieldPattern<TypeRef>),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        Grammar(Grammar),
        GrammarItem(GrammarItem),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        GrammarParameter(Parameter),
        GrammarParameter_3f(::std::option::Option<Parameter>),
        GrammarParameters(Vec<Parameter>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        GrammarTypeParameters(Vec<TypeParameter>),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        Id(InternedString),
        Lifetime(InternedString),
        Lifetime_3f(::std::option::Option<InternedString>),
        MacroId(NonterminalString),
        Nonterminal(GrammarItem),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        NotMacroId(NonterminalString),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        Path(Path),
        Pattern(Pattern<TypeRef>),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        QuotedTerminal(TerminalString),
        RegexLiteral(InternedString),
        RepeatOp(RepeatOp),
        StringLiteral(InternedString),
        Symbol(Symbol),
        Symbol_2a(::std::vec::Vec<Symbol>),
        Symbol_2b(::std::vec::Vec<Symbol>),
        Symbol0(Symbol),
        Symbol1(Symbol),
        Symbol_3f(::std::option::Option<Symbol>),
        SymbolKind1(SymbolKind),
        Terminal(TerminalString),
        TypeParameter(TypeParameter),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        TypeRef(TypeRef),
        TypeRef_3f(::std::option::Option<TypeRef>),
        TypeRefOrLifetime(TypeRef),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        Use(GrammarItem),
        Use_2a(::std::vec::Vec<GrammarItem>),
        ______Grammar(Grammar),
        ______Pattern(Pattern<TypeRef>),
        ______TypeRef(TypeRef),
    }

    // State 0
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Pattern = (*) @L PatternKind @R [EOF]
    //   ___Pattern = (*) Pattern [EOF]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ".." -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "_" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S1
    //   Pattern -> S2
    pub fn ___state0<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Pattern(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
    }

    // State 1
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [EOF]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Pattern = @L (*) PatternKind @R [EOF]
    //   PatternKind = (*) Path [EOF]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [EOF]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = (*) ".." [EOF]
    //   PatternKind = (*) "<" TypeRef ">" [EOF]
    //   PatternKind = (*) "_" [EOF]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Pattern = @L (*) PatternKind @R [")"]
    //   Pattern = @L (*) PatternKind @R [","]
    //   PatternKind = (*) Path [")"]
    //   PatternKind = (*) Path [","]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [")"]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [")"]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) ".." [")"]
    //   PatternKind = (*) ".." [","]
    //   PatternKind = (*) "<" TypeRef ">" [")"]
    //   PatternKind = (*) "<" TypeRef ">" [","]
    //   PatternKind = (*) "_" [")"]
    //   PatternKind = (*) "_" [","]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Path = (*) "::"? (<Id> "::")* Id ["}"]
    //   Pattern = @L (*) PatternKind @R [","]
    //   Pattern = @L (*) PatternKind @R ["}"]
    //   PatternKind = (*) Path [","]
    //   PatternKind = (*) Path ["}"]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" ["}"]
    //   PatternKind = (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = (*) ".." [","]
    //   PatternKind = (*) ".." ["}"]
    //   PatternKind = (*) "<" TypeRef ">" [","]
    //   PatternKind = (*) "<" TypeRef ">" ["}"]
    //   PatternKind = (*) "_" [","]
    //   PatternKind = (*) "_" ["}"]
    //
    //   "(" -> Shift(S6)
    //   ".." -> Shift(S7)
    //   "::" -> Shift(S8)
    //   "<" -> Shift(S9)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "_" -> Shift(S10)
    //
    //   "::"? -> S3
    //   Path -> S4
    //   PatternKind -> S5
    pub fn ___state1<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::DotDot, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Underscore, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state10(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state4(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::PatternKind(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state5(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 2
    //   ___Pattern = Pattern (*) [EOF]
    //
    //   EOF -> Reduce(___Pattern = Pattern => Call(ActionFn(2));)
    //
    pub fn ___state2<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action2(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::______Pattern(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 3
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [EOF]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   Path = "::"? (*) (<Id> "::")* Id ["}"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(93));)
    //   "MacroId" -> Reduce((<Id> "::")* =  => Call(ActionFn(93));)
    //
    //   (<Id> "::")* -> S11
    pub fn ___state3<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action93(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state11(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 4
    //   PatternKind = Path (*) [EOF]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [EOF]
    //   PatternKind = Path (*) [")"]
    //   PatternKind = Path (*) [","]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [")"]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = Path (*) [","]
    //   PatternKind = Path (*) ["}"]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path => Call(ActionFn(70));)
    //   "(" -> Shift(S12)
    //   ")" -> Reduce(PatternKind = Path => Call(ActionFn(70));)
    //   "," -> Reduce(PatternKind = Path => Call(ActionFn(70));)
    //   "{" -> Shift(S13)
    //   "}" -> Reduce(PatternKind = Path => Call(ActionFn(70));)
    //
    pub fn ___state4<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state12(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state13(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action70(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 5
    //   @R = (*) [EOF]
    //   Pattern = @L PatternKind (*) @R [EOF]
    //   @R = (*) [")"]
    //   @R = (*) [","]
    //   Pattern = @L PatternKind (*) @R [")"]
    //   Pattern = @L PatternKind (*) @R [","]
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Pattern = @L PatternKind (*) @R [","]
    //   Pattern = @L PatternKind (*) @R ["}"]
    //
    //   EOF -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S14
    pub fn ___state5<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<PatternKind<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 6
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [EOF]
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [","]
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = "(" (*) Comma<Pattern> ")" [","]
    //   PatternKind = "(" (*) Comma<Pattern> ")" ["}"]
    //
    //   "(" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   ")" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   ".." -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "::" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "<" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "Id" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "MacroId" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "_" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //
    //   (<Pattern> ",")* -> S15
    //   Comma<Pattern> -> S16
    pub fn ___state6<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = super::___action179(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state15(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cPattern_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state16(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 7
    //   PatternKind = ".." (*) [EOF]
    //   PatternKind = ".." (*) [")"]
    //   PatternKind = ".." (*) [","]
    //   PatternKind = ".." (*) [","]
    //   PatternKind = ".." (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = ".." => Call(ActionFn(67));)
    //   ")" -> Reduce(PatternKind = ".." => Call(ActionFn(67));)
    //   "," -> Reduce(PatternKind = ".." => Call(ActionFn(67));)
    //   "}" -> Reduce(PatternKind = ".." => Call(ActionFn(67));)
    //
    pub fn ___state7<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action67(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 8
    //   "::"? = "::" (*) ["Id"]
    //   "::"? = "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce("::"? = "::" => Call(ActionFn(96));)
    //   "MacroId" -> Reduce("::"? = "::" => Call(ActionFn(96));)
    //
    pub fn ___state8<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action96(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 9
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [EOF]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [")"]
    //   PatternKind = "<" (*) TypeRef ">" [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [","]
    //   PatternKind = "<" (*) TypeRef ">" ["}"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S19)
    //   "&" -> Shift(S20)
    //   "(" -> Shift(S21)
    //   "::" -> Shift(S8)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S3
    //   Path -> S17
    //   TypeRef -> S18
    pub fn ___state9<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state19(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state20(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state21(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state18(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 10
    //   PatternKind = "_" (*) [EOF]
    //   PatternKind = "_" (*) [")"]
    //   PatternKind = "_" (*) [","]
    //   PatternKind = "_" (*) [","]
    //   PatternKind = "_" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = "_" => Call(ActionFn(66));)
    //   ")" -> Reduce(PatternKind = "_" => Call(ActionFn(66));)
    //   "," -> Reduce(PatternKind = "_" => Call(ActionFn(66));)
    //   "}" -> Reduce(PatternKind = "_" => Call(ActionFn(66));)
    //
    pub fn ___state10<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action66(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 11
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id [EOF]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "Id" ["}"]
    //   Id = (*) "MacroId" ["("]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["{"]
    //   Id = (*) "MacroId" ["}"]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["}"]
    //
    //   "Id" -> Shift(S24)
    //   "MacroId" -> Shift(S25)
    //
    //   (<Id> "::") -> S22
    //   Id -> S23
    pub fn ___state11<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state25(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state22(text, ___lookbehind, ___tokens, ___lookahead, ___sym1, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state23(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 12
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [EOF]
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [","]
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["MacroId"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [","]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" ["}"]
    //
    //   "(" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   ")" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   ".." -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "::" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "<" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "Id" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "MacroId" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //   "_" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(179));)
    //
    //   (<Pattern> ",")* -> S15
    //   Comma<Pattern> -> S26
    pub fn ___state12<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = super::___action179(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state15(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cPattern_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state26(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 13
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["MacroId"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [EOF]
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["MacroId"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [","]
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["MacroId"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" ["}"]
    //
    //   ".." -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(86));)
    //   "Id" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(86));)
    //   "MacroId" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(86));)
    //   "}" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(86));)
    //
    //   (<FieldPattern> ",")* -> S27
    pub fn ___state13<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action86(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state27(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 14
    //   Pattern = @L PatternKind @R (*) [EOF]
    //   Pattern = @L PatternKind @R (*) [")"]
    //   Pattern = @L PatternKind @R (*) [","]
    //   Pattern = @L PatternKind @R (*) [","]
    //   Pattern = @L PatternKind @R (*) ["}"]
    //
    //   EOF -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(62));)
    //   ")" -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(62));)
    //   "," -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(62));)
    //   "}" -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(62));)
    //
    pub fn ___state14<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<PatternKind<TypeRef>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action62(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Pattern(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 15
    //   (<Pattern> ",") = (*) Pattern "," ["("]
    //   (<Pattern> ",") = (*) Pattern "," [")"]
    //   (<Pattern> ",") = (*) Pattern "," [".."]
    //   (<Pattern> ",") = (*) Pattern "," ["::"]
    //   (<Pattern> ",") = (*) Pattern "," ["<"]
    //   (<Pattern> ",") = (*) Pattern "," ["Id"]
    //   (<Pattern> ",") = (*) Pattern "," ["MacroId"]
    //   (<Pattern> ",") = (*) Pattern "," ["_"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["MacroId"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (<Pattern> ",")* (*) Pattern? [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   Pattern? = (*) [")"]
    //   Pattern? = (*) Pattern [")"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(Pattern? =  => Call(ActionFn(178));)
    //   ".." -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "_" -> Reduce(@L =  => Lookahead;)
    //
    //   (<Pattern> ",") -> S28
    //   @L -> S1
    //   Pattern -> S29
    //   Pattern? -> S30
    pub fn ___state15<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action178(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Pattern_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state28(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Pattern(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state29(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Pattern_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state30(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 16
    //   PatternKind = "(" Comma<Pattern> (*) ")" [EOF]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [")"]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = "(" Comma<Pattern> (*) ")" ["}"]
    //
    //   ")" -> Shift(S31)
    //
    pub fn ___state16<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state31(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 17
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   ")" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   "<" -> Shift(S32)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //
    pub fn ___state17<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action53(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 18
    //   PatternKind = "<" TypeRef (*) ">" [EOF]
    //   PatternKind = "<" TypeRef (*) ">" [")"]
    //   PatternKind = "<" TypeRef (*) ">" [","]
    //   PatternKind = "<" TypeRef (*) ">" [","]
    //   PatternKind = "<" TypeRef (*) ">" ["}"]
    //
    //   ">" -> Shift(S33)
    //
    pub fn ___state18<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 19
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S34
    //   Symbol -> S35
    //   Symbol0 -> S36
    //   Symbol1 -> S37
    pub fn ___state19<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state34(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state35(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state37(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 20
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //
    //   "#" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "Lifetime" -> Shift(S40)
    //   "MacroId" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //
    //   Lifetime -> S38
    //   Lifetime? -> S39
    pub fn ___state20<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state40(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___nt = super::___action102(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Lifetime_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state38(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state39(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 21
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //
    //   (<TypeRef> ",")* -> S41
    //   Comma<TypeRef> -> S42
    pub fn ___state21<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action164(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state41(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cTypeRef_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state42(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 22
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(94));)
    //   "MacroId" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(94));)
    //
    pub fn ___state22<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action94(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 23
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [EOF]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   Path = "::"? (<Id> "::")* Id (*) ["}"]
    //
    //   EOF -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "(" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "::" -> Shift(S43)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "{" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "}" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //
    pub fn ___state23<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state43(text, ___lookbehind, ___tokens, ___sym2, ___sym3));
            }
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action56(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 24
    //   Id = "Id" (*) [EOF]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) [":"]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["}"]
    //
    //   EOF -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "(" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "{" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "}" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //
    pub fn ___state24<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 25
    //   Id = "MacroId" (*) [EOF]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) [":"]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //   Id = "MacroId" (*) ["("]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["{"]
    //   Id = "MacroId" (*) ["}"]
    //
    //   EOF -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "(" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   ")" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "," -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "::" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "<" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   ">" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "{" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "}" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //
    pub fn ___state25<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::Colon, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::LeftBrace, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 26
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [EOF]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [")"]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" ["}"]
    //
    //   ")" -> Shift(S44)
    //
    pub fn ___state26<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state44(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 27
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [EOF]
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [","]
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["MacroId"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["MacroId"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" ["}"]
    //
    //   ".." -> Shift(S49)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "}" -> Reduce(FieldPattern? =  => Call(ActionFn(85));)
    //
    //   (<FieldPattern> ",") -> S45
    //   @L -> S46
    //   FieldPattern -> S47
    //   FieldPattern? -> S48
    pub fn ___state27<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::DotDot, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state49(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___nt = super::___action85(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::FieldPattern_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state46(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::FieldPattern(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::FieldPattern_3f(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 28
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["("]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) [")"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) [".."]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["::"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["<"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["Id"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["MacroId"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["_"]
    //
    //   "(" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(180));)
    //   ")" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(180));)
    //   ".." -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(180));)
    //   "::" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(180));)
    //   "<" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(180));)
    //   "Id" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(180));)
    //   "MacroId" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(180));)
    //   "_" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(180));)
    //
    pub fn ___state28<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
        ___sym1: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action180(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 29
    //   (<Pattern> ",") = Pattern (*) "," ["("]
    //   (<Pattern> ",") = Pattern (*) "," [")"]
    //   (<Pattern> ",") = Pattern (*) "," [".."]
    //   (<Pattern> ",") = Pattern (*) "," ["::"]
    //   (<Pattern> ",") = Pattern (*) "," ["<"]
    //   (<Pattern> ",") = Pattern (*) "," ["Id"]
    //   (<Pattern> ",") = Pattern (*) "," ["MacroId"]
    //   (<Pattern> ",") = Pattern (*) "," ["_"]
    //   Pattern? = Pattern (*) [")"]
    //
    //   ")" -> Reduce(Pattern? = Pattern => Call(ActionFn(177));)
    //   "," -> Shift(S50)
    //
    pub fn ___state29<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action177(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Pattern_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 30
    //   Comma<Pattern> = (<Pattern> ",")* Pattern? (*) [")"]
    //
    //   ")" -> Reduce(Comma<Pattern> = (<Pattern> ",")*, Pattern? => Call(ActionFn(89));)
    //
    pub fn ___state30<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Pattern<TypeRef>>>,
        ___sym1: &mut Option<::std::option::Option<Pattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action89(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cPattern_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 31
    //   PatternKind = "(" Comma<Pattern> ")" (*) [EOF]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [")"]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = "(" Comma<Pattern> ")" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => Call(ActionFn(69));)
    //   ")" -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => Call(ActionFn(69));)
    //   "," -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => Call(ActionFn(69));)
    //   "}" -> Reduce(PatternKind = "(", Comma<Pattern>, ")" => Call(ActionFn(69));)
    //
    pub fn ___state31<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<Pattern<TypeRef>>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action69(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 32
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S51
    //   Comma<TypeRefOrLifetime> -> S52
    pub fn ___state32<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action169(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state51(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state52(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 33
    //   PatternKind = "<" TypeRef ">" (*) [EOF]
    //   PatternKind = "<" TypeRef ">" (*) [")"]
    //   PatternKind = "<" TypeRef ">" (*) [","]
    //   PatternKind = "<" TypeRef ">" (*) [","]
    //   PatternKind = "<" TypeRef ">" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(68));)
    //   ")" -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(68));)
    //   "," -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(68));)
    //   "}" -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(68));)
    //
    pub fn ___state33<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<TypeRef>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action68(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 34
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["#"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["#"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral [")"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" [")"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [","]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [","]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S59)
    //   "<" -> Shift(S60)
    //   "@L" -> Shift(S61)
    //   "@R" -> Shift(S62)
    //   "Escape" -> Shift(S63)
    //   "Id" -> Shift(S64)
    //   "MacroId" -> Shift(S65)
    //   "RegexLiteral" -> Shift(S66)
    //   "StringLiteral" -> Shift(S67)
    //
    //   Escape -> S53
    //   MacroId -> S54
    //   QuotedTerminal -> S55
    //   RegexLiteral -> S56
    //   StringLiteral -> S57
    //   SymbolKind1 -> S58
    pub fn ___state34<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state59(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state60(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state61(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state62(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state63(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state64(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state65(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state66(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state67(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state53(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state54(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state55(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state56(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state57(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state58(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 35
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //
    //   "#" -> Shift(S68)
    //
    pub fn ___state35<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state68(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 36
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "#" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "(" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   ")" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "*" -> Shift(S70)
    //   "+" -> Shift(S71)
    //   "," -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "<" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   ">" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "?" -> Shift(S72)
    //   "@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "Escape" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "Id" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "RegexLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //
    //   RepeatOp -> S69
    pub fn ___state36<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state70(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state71(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state72(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action35(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 37
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "(" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   ")" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "," -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "<" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   ">" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //
    pub fn ___state37<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action36(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 38
    //   Lifetime? = Lifetime (*) ["#"]
    //   Lifetime? = Lifetime (*) ["&"]
    //   Lifetime? = Lifetime (*) ["("]
    //   Lifetime? = Lifetime (*) ["::"]
    //   Lifetime? = Lifetime (*) ["Id"]
    //   Lifetime? = Lifetime (*) ["MacroId"]
    //   Lifetime? = Lifetime (*) ["mut"]
    //
    //   "#" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "&" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "(" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "::" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "Id" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "MacroId" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "mut" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //
    pub fn ___state38<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action101(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 39
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [")"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //
    //   "#" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "MacroId" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "mut" -> Shift(S74)
    //
    //   "mut"? -> S73
    pub fn ___state39<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state74(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action100(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22mut_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22mut_22_3f(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state73(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 40
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //
    //   "#" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "&" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "(" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "," -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "::" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   ">" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //
    pub fn ___state40<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action77(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 41
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["("]
    //   (<TypeRef> ",") = (*) TypeRef "," [")"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")* (*) TypeRef? [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef? = (*) [")"]
    //   TypeRef? = (*) TypeRef [")"]
    //
    //   "#" -> Shift(S19)
    //   "&" -> Shift(S20)
    //   "(" -> Shift(S21)
    //   ")" -> Reduce(TypeRef? =  => Call(ActionFn(163));)
    //   "::" -> Shift(S8)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S3
    //   (<TypeRef> ",") -> S75
    //   Path -> S17
    //   TypeRef -> S76
    //   TypeRef? -> S77
    pub fn ___state41<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state19(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state20(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state21(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action163(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::TypeRef_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state75(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state76(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state77(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 42
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S78)
    //
    pub fn ___state42<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state78(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 43
    //   (<Id> "::") = Id "::" (*) ["Id"]
    //   (<Id> "::") = Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(95));)
    //   "MacroId" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(95));)
    //
    pub fn ___state43<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action95(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 44
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [EOF]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [")"]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(63));)
    //   ")" -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(63));)
    //   "," -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(63));)
    //   "}" -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(63));)
    //
    pub fn ___state44<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Pattern<TypeRef>>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action63(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 45
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) ["MacroId"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) ["}"]
    //
    //   ".." -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(87));)
    //   "Id" -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(87));)
    //   "MacroId" -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(87));)
    //   "}" -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(87));)
    //
    pub fn ___state45<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym1: &mut Option<FieldPattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action87(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 46
    //   FieldPattern = @L (*) Id @R ":" Pattern [","]
    //   FieldPattern = @L (*) Id @R ":" Pattern ["}"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //
    //   "Id" -> Shift(S24)
    //   "MacroId" -> Shift(S25)
    //
    //   Id -> S79
    pub fn ___state46<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state24(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state25(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Id(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state79(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 47
    //   (<FieldPattern> ",") = FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",") = FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",") = FieldPattern (*) "," ["MacroId"]
    //   (<FieldPattern> ",") = FieldPattern (*) "," ["}"]
    //   FieldPattern? = FieldPattern (*) ["}"]
    //
    //   "," -> Shift(S80)
    //   "}" -> Reduce(FieldPattern? = FieldPattern => Call(ActionFn(84));)
    //
    pub fn ___state47<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<FieldPattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state80(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action84(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::FieldPattern_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 48
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" ["}"]
    //
    //   "}" -> Shift(S81)
    //
    pub fn ___state48<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state81(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 49
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" ["}"]
    //
    //   "}" -> Shift(S82)
    //
    pub fn ___state49<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, ___tok @ Tok::RightBrace, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 50
    //   (<Pattern> ",") = Pattern "," (*) ["("]
    //   (<Pattern> ",") = Pattern "," (*) [")"]
    //   (<Pattern> ",") = Pattern "," (*) [".."]
    //   (<Pattern> ",") = Pattern "," (*) ["::"]
    //   (<Pattern> ",") = Pattern "," (*) ["<"]
    //   (<Pattern> ",") = Pattern "," (*) ["Id"]
    //   (<Pattern> ",") = Pattern "," (*) ["MacroId"]
    //   (<Pattern> ",") = Pattern "," (*) ["_"]
    //
    //   "(" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(181));)
    //   ")" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(181));)
    //   ".." -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(181));)
    //   "::" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(181));)
    //   "<" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(181));)
    //   "Id" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(181));)
    //   "MacroId" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(181));)
    //   "_" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(181));)
    //
    pub fn ___state50<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Pattern<TypeRef>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action181(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 51
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* (*) TypeRefOrLifetime? [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   TypeRefOrLifetime? = (*) [">"]
    //   TypeRefOrLifetime? = (*) TypeRefOrLifetime [">"]
    //
    //   "#" -> Shift(S19)
    //   "&" -> Shift(S20)
    //   "(" -> Shift(S21)
    //   "::" -> Shift(S8)
    //   ">" -> Reduce(TypeRefOrLifetime? =  => Call(ActionFn(168));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "Lifetime" -> Shift(S40)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S3
    //   (<TypeRefOrLifetime> ",") -> S83
    //   Lifetime -> S84
    //   Path -> S17
    //   TypeRef -> S85
    //   TypeRefOrLifetime -> S86
    //   TypeRefOrLifetime? -> S87
    pub fn ___state51<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state19(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state20(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state21(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state40(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action168(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state84(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state85(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state86(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state87(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 52
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S88)
    //
    pub fn ___state52<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state88(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 53
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "(" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   ")" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "," -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "<" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   ">" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "Id" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //
    pub fn ___state53<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action45(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 54
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Shift(S89)
    //
    pub fn ___state54<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state89(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 55
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //
    pub fn ___state55<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 56
    //   QuotedTerminal = RegexLiteral (*) ["#"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) [")"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [","]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //
    //   "#" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "(" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   ")" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "*" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "+" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "," -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "<" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   ">" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "?" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "@L" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "@R" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "Escape" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "Id" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "MacroId" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //
    pub fn ___state56<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action81(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 57
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "," -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //
    pub fn ___state57<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action80(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 58
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S90
    pub fn ___state58<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state90(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 59
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "RegexLiteral" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //
    //   ExprSymbol -> S91
    //   Symbol* -> S92
    pub fn ___state59<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action105(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Symbol_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::ExprSymbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state91(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state92(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 60
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S93
    //   Symbol0 -> S94
    //   Symbol1 -> S37
    pub fn ___state60<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state93(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state94(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state37(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 61
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "(" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   ")" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "," -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "<" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   ">" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //
    pub fn ___state61<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action47(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 62
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "(" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   ")" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "," -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "<" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   ">" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //
    pub fn ___state62<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action48(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 63
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //
    //   "#" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "(" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "<" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "@L" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "@R" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "Escape" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "Id" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "MacroId" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "RegexLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //
    pub fn ___state63<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action76(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Escape(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 64
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "(" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ")" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "," -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "<" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //
    pub fn ___state64<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 65
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(72));)
    //
    pub fn ___state65<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action72(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 66
    //   RegexLiteral = "RegexLiteral" (*) ["#"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) [")"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [","]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "(" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   ")" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "*" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "+" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "," -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "<" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   ">" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "?" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "@L" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "@R" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "Escape" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "Id" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "MacroId" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "RegexLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "StringLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //
    pub fn ___state66<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action83(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RegexLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 67
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "RegexLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //
    pub fn ___state67<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action82(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::StringLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 68
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //
    pub fn ___state68<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action50(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 69
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S95
    pub fn ___state69<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state95(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 70
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "(" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   ")" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "," -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "<" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   ">" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "Escape" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "Id" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "MacroId" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //
    pub fn ___state70<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action39(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 71
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "(" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   ")" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "," -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "<" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   ">" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "Escape" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "Id" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "MacroId" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //
    pub fn ___state71<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action38(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 72
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "(" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   ")" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "," -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "<" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   ">" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "Escape" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "Id" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "MacroId" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //
    pub fn ___state72<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action40(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 73
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S19)
    //   "&" -> Shift(S20)
    //   "(" -> Shift(S21)
    //   "::" -> Shift(S8)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S3
    //   Path -> S17
    //   TypeRef -> S96
    pub fn ___state73<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
        ___sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state19(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state20(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state21(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state8(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state96(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 74
    //   "mut"? = "mut" (*) ["#"]
    //   "mut"? = "mut" (*) ["&"]
    //   "mut"? = "mut" (*) ["("]
    //   "mut"? = "mut" (*) ["::"]
    //   "mut"? = "mut" (*) ["Id"]
    //   "mut"? = "mut" (*) ["MacroId"]
    //
    //   "#" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "&" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "(" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "::" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "Id" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "MacroId" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //
    pub fn ___state74<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action99(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_22mut_22_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 75
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "&" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "(" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   ")" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "::" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "Id" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //
    pub fn ___state75<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action165(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 76
    //   (<TypeRef> ",") = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["("]
    //   (<TypeRef> ",") = TypeRef (*) "," [")"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["MacroId"]
    //   TypeRef? = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(TypeRef? = TypeRef => Call(ActionFn(162));)
    //   "," -> Shift(S97)
    //
    pub fn ___state76<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state97(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action162(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 77
    //   Comma<TypeRef> = (<TypeRef> ",")* TypeRef? (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")*, TypeRef? => Call(ActionFn(103));)
    //
    pub fn ___state77<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action103(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 78
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //
    pub fn ___state78<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action49(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 79
    //   @R = (*) [":"]
    //   FieldPattern = @L Id (*) @R ":" Pattern [","]
    //   FieldPattern = @L Id (*) @R ":" Pattern ["}"]
    //
    //   ":" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S98
    pub fn ___state79<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state98(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 80
    //   (<FieldPattern> ",") = FieldPattern "," (*) [".."]
    //   (<FieldPattern> ",") = FieldPattern "," (*) ["Id"]
    //   (<FieldPattern> ",") = FieldPattern "," (*) ["MacroId"]
    //   (<FieldPattern> ",") = FieldPattern "," (*) ["}"]
    //
    //   ".." -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(88));)
    //   "Id" -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(88));)
    //   "MacroId" -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(88));)
    //   "}" -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(88));)
    //
    pub fn ___state80<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<FieldPattern<TypeRef>>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action88(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 81
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(64));)
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(64));)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(64));)
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(64));)
    //
    pub fn ___state81<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action64(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 82
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) ["}"]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(65));)
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(65));)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(65));)
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(65));)
    //
    pub fn ___state82<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action65(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::PatternKind(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 83
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //
    pub fn ___state83<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action170(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 84
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(55));)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(55));)
    //
    pub fn ___state84<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action55(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 85
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(54));)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(54));)
    //
    pub fn ___state85<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action54(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 86
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["MacroId"]
    //   TypeRefOrLifetime? = TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S99)
    //   ">" -> Reduce(TypeRefOrLifetime? = TypeRefOrLifetime => Call(ActionFn(167));)
    //
    pub fn ___state86<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state99(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action167(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 87
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")*, TypeRefOrLifetime? => Call(ActionFn(98));)
    //
    pub fn ___state87<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action98(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 88
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //
    pub fn ___state88<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action52(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 89
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //
    //   (<Symbol> ",")* -> S100
    //   Comma<Symbol> -> S101
    pub fn ___state89<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action159(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state100(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cSymbol_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state101(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 90
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "RegexLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //
    pub fn ___state90<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action41(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 91
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //
    //   ")" -> Shift(S102)
    //
    pub fn ___state91<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state102(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 92
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol* (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["RegexLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(ExprSymbol = Symbol* => Call(ActionFn(32));)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S34
    //   Symbol -> S103
    //   Symbol0 -> S36
    //   Symbol1 -> S37
    pub fn ___state92<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action32(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state34(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state103(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state37(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 93
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S59)
    //   "@L" -> Shift(S61)
    //   "@R" -> Shift(S62)
    //   "Escape" -> Shift(S63)
    //   "Id" -> Shift(S105)
    //   "MacroId" -> Shift(S106)
    //   "RegexLiteral" -> Shift(S66)
    //   "StringLiteral" -> Shift(S67)
    //
    //   Escape -> S53
    //   Id -> S104
    //   MacroId -> S54
    //   QuotedTerminal -> S55
    //   RegexLiteral -> S56
    //   StringLiteral -> S57
    //   SymbolKind1 -> S58
    pub fn ___state93<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state59(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state61(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state62(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state63(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state105(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state106(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state66(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state67(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state53(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state104(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state54(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state55(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state56(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state57(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state58(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 94
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S70)
    //   "+" -> Shift(S71)
    //   ">" -> Shift(S107)
    //   "?" -> Shift(S72)
    //
    //   RepeatOp -> S69
    pub fn ___state94<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state70(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state71(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state107(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state72(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 95
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //
    pub fn ___state95<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action37(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 96
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //
    //   ")" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //
    pub fn ___state96<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
        ___sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action51(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 97
    //   (<TypeRef> ",") = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["("]
    //   (<TypeRef> ",") = TypeRef "," (*) [")"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "&" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "(" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   ")" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "::" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "Id" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "MacroId" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //
    pub fn ___state97<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action166(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 98
    //   FieldPattern = @L Id @R (*) ":" Pattern [","]
    //   FieldPattern = @L Id @R (*) ":" Pattern ["}"]
    //
    //   ":" -> Shift(S108)
    //
    pub fn ___state98<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state108(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 99
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //
    pub fn ___state99<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action171(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 100
    //   (<Symbol> ",") = (*) Symbol "," ["("]
    //   (<Symbol> ",") = (*) Symbol "," ["<"]
    //   (<Symbol> ",") = (*) Symbol "," [">"]
    //   (<Symbol> ",") = (*) Symbol "," ["@L"]
    //   (<Symbol> ",") = (*) Symbol "," ["@R"]
    //   (<Symbol> ",") = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",") = (*) Symbol "," ["Id"]
    //   (<Symbol> ",") = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",") = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",") = (*) Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")* (*) Symbol? [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol? = (*) [">"]
    //   Symbol? = (*) Symbol [">"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   ">" -> Reduce(Symbol? =  => Call(ActionFn(158));)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   (<Symbol> ",") -> S109
    //   @L -> S34
    //   Symbol -> S110
    //   Symbol0 -> S36
    //   Symbol1 -> S37
    //   Symbol? -> S111
    pub fn ___state100<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action158(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Symbol_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state109(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state34(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state110(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state36(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state37(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state111(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 101
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //
    //   ">" -> Shift(S112)
    //
    pub fn ___state101<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state112(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 102
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //
    pub fn ___state102<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action46(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 103
    //   Symbol* = Symbol* Symbol (*) ["("]
    //   Symbol* = Symbol* Symbol (*) [")"]
    //   Symbol* = Symbol* Symbol (*) ["<"]
    //   Symbol* = Symbol* Symbol (*) ["@L"]
    //   Symbol* = Symbol* Symbol (*) ["@R"]
    //   Symbol* = Symbol* Symbol (*) ["Escape"]
    //   Symbol* = Symbol* Symbol (*) ["Id"]
    //   Symbol* = Symbol* Symbol (*) ["MacroId"]
    //   Symbol* = Symbol* Symbol (*) ["RegexLiteral"]
    //   Symbol* = Symbol* Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   ")" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "<" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "Escape" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "Id" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "MacroId" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "RegexLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "StringLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //
    pub fn ___state103<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action106(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 104
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //
    //   ":" -> Shift(S113)
    //
    pub fn ___state104<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state113(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 105
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //
    pub fn ___state105<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 106
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(72));)
    //
    pub fn ___state106<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action72(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 107
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S114
    pub fn ___state107<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state114(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 108
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["_"]
    //   FieldPattern = @L Id @R ":" (*) Pattern [","]
    //   FieldPattern = @L Id @R ":" (*) Pattern ["}"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   Pattern = (*) @L PatternKind @R ["}"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ".." -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "_" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S1
    //   Pattern -> S115
    pub fn ___state108<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::DotDot, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Underscore, _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym4));
                }
                ___Nonterminal::Pattern(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state115(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 109
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "<" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   ">" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "@L" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "@R" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "Escape" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "Id" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "MacroId" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //
    pub fn ___state109<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action160(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 110
    //   (<Symbol> ",") = Symbol (*) "," ["("]
    //   (<Symbol> ",") = Symbol (*) "," ["<"]
    //   (<Symbol> ",") = Symbol (*) "," [">"]
    //   (<Symbol> ",") = Symbol (*) "," ["@L"]
    //   (<Symbol> ",") = Symbol (*) "," ["@R"]
    //   (<Symbol> ",") = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",") = Symbol (*) "," ["Id"]
    //   (<Symbol> ",") = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",") = Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",") = Symbol (*) "," ["StringLiteral"]
    //   Symbol? = Symbol (*) [">"]
    //
    //   "," -> Shift(S116)
    //   ">" -> Reduce(Symbol? = Symbol => Call(ActionFn(157));)
    //
    pub fn ___state110<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state116(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action157(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 111
    //   Comma<Symbol> = (<Symbol> ",")* Symbol? (*) [">"]
    //
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")*, Symbol? => Call(ActionFn(104));)
    //
    pub fn ___state111<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<::std::option::Option<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action104(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 112
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //
    pub fn ___state112<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action42(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 113
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S117
    //   Symbol0 -> S118
    //   Symbol1 -> S37
    pub fn ___state113<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state117(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state118(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state37(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 114
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //
    pub fn ___state114<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action34(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 115
    //   FieldPattern = @L Id @R ":" Pattern (*) [","]
    //   FieldPattern = @L Id @R ":" Pattern (*) ["}"]
    //
    //   "," -> Reduce(FieldPattern = @L, Id, @R, ":", Pattern => Call(ActionFn(71));)
    //   "}" -> Reduce(FieldPattern = @L, Id, @R, ":", Pattern => Call(ActionFn(71));)
    //
    pub fn ___state115<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<InternedString>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<Pattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::RightBrace, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action71(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::FieldPattern(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 116
    //   (<Symbol> ",") = Symbol "," (*) ["("]
    //   (<Symbol> ",") = Symbol "," (*) ["<"]
    //   (<Symbol> ",") = Symbol "," (*) [">"]
    //   (<Symbol> ",") = Symbol "," (*) ["@L"]
    //   (<Symbol> ",") = Symbol "," (*) ["@R"]
    //   (<Symbol> ",") = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",") = Symbol "," (*) ["Id"]
    //   (<Symbol> ",") = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",") = Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",") = Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "<" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   ">" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "@L" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "@R" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "Escape" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "Id" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "MacroId" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "StringLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //
    pub fn ___state116<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action161(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 117
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S59)
    //   "@L" -> Shift(S61)
    //   "@R" -> Shift(S62)
    //   "Escape" -> Shift(S63)
    //   "Id" -> Shift(S64)
    //   "MacroId" -> Shift(S65)
    //   "RegexLiteral" -> Shift(S66)
    //   "StringLiteral" -> Shift(S67)
    //
    //   Escape -> S53
    //   MacroId -> S54
    //   QuotedTerminal -> S55
    //   RegexLiteral -> S56
    //   StringLiteral -> S57
    //   SymbolKind1 -> S58
    pub fn ___state117<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state59(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state61(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state62(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state63(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state64(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state65(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state66(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state67(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state53(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state54(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state55(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state56(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state57(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state58(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 118
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S70)
    //   "+" -> Shift(S71)
    //   ">" -> Shift(S119)
    //   "?" -> Shift(S72)
    //
    //   RepeatOp -> S69
    pub fn ___state118<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state70(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state71(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state119(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state72(text, ___lookbehind, ___tokens, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 119
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S120
    pub fn ___state119<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state120(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 120
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //
    pub fn ___state120<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action33(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
pub use self::___parse___Pattern::parse_Pattern;

mod ___parse___TypeRef {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    use util::strip;
    extern crate lalrpop_util as ___lalrpop_util;
    use self::___lalrpop_util::ParseError as ___ParseError;
    use super::___ToTriple;
    pub fn parse_TypeRef<
        'input,
        ___TOKEN: ___ToTriple<'input, Error=tok::Error>,
        ___TOKENS: IntoIterator<Item=___TOKEN>,
    >(
        text: &'input str,
        ___tokens: ___TOKENS,
    ) -> Result<TypeRef, ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let ___tokens = ___tokens.into_iter();
        let mut ___tokens = ___tokens.map(|t| ___ToTriple::to_triple(t));
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match try!(___state0(text, None, &mut ___tokens, ___lookahead)) {
            (_, Some(___lookahead), _) => {
                Err(___ParseError::ExtraToken { token: ___lookahead })
            }
            (_, None, ___Nonterminal::______TypeRef(___nt)) => {
                Ok(___nt)
            }
            _ => unreachable!(),
        }
    }

    #[allow(dead_code)]
    pub enum ___Nonterminal<'input> {
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        _22where_22_3f(::std::option::Option<Vec<&'input str>>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        _28_22if_22_20_3cCond_3e_29(Condition),
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        _28_3cAlternative_3e_20_22_2c_22_29(Alternative),
        _28_3cAlternative_3e_20_22_2c_22_29_2a(::std::vec::Vec<Alternative>),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        _28_3cNotMacroId_3e_20_22_2c_22_29(NonterminalString),
        _28_3cNotMacroId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern<TypeRef>),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern<TypeRef>>),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _40L(usize),
        _40R(usize),
        Action(ActionKind),
        Action_3f(::std::option::Option<ActionKind>),
        Algorithm(Algorithm),
        Algorithm_3f(::std::option::Option<Algorithm>),
        Alternative(Alternative),
        Alternative_3f(::std::option::Option<Alternative>),
        Alternatives(Vec<Alternative>),
        Annotation(Annotation),
        Annotation_2a(::std::vec::Vec<Annotation>),
        AssociatedType(AssociatedType),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        Comma_3cAlternative_3e(Vec<Alternative>),
        Comma_3cConversion_3e(Vec<Conversion>),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        Comma_3cNotMacroId_3e(Vec<NonterminalString>),
        Comma_3cPattern_3e(Vec<Pattern<TypeRef>>),
        Comma_3cSymbol_3e(Vec<Symbol>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        Cond(Condition),
        CondOp(ConditionOp),
        Conversion(Conversion),
        Conversion_3f(::std::option::Option<Conversion>),
        EnumToken(EnumToken),
        Escape(InternedString),
        ExprSymbol(ExprSymbol),
        ExternToken(GrammarItem),
        FieldPattern(FieldPattern<TypeRef>),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        Grammar(Grammar),
        GrammarItem(GrammarItem),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        GrammarParameter(Parameter),
        GrammarParameter_3f(::std::option::Option<Parameter>),
        GrammarParameters(Vec<Parameter>),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        GrammarTypeParameters(Vec<TypeParameter>),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        Id(InternedString),
        Lifetime(InternedString),
        Lifetime_3f(::std::option::Option<InternedString>),
        MacroId(NonterminalString),
        Nonterminal(GrammarItem),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        NotMacroId(NonterminalString),
        NotMacroId_3f(::std::option::Option<NonterminalString>),
        Path(Path),
        Pattern(Pattern<TypeRef>),
        Pattern_3f(::std::option::Option<Pattern<TypeRef>>),
        PatternKind(PatternKind<TypeRef>),
        QuotedTerminal(TerminalString),
        RegexLiteral(InternedString),
        RepeatOp(RepeatOp),
        StringLiteral(InternedString),
        Symbol(Symbol),
        Symbol_2a(::std::vec::Vec<Symbol>),
        Symbol_2b(::std::vec::Vec<Symbol>),
        Symbol0(Symbol),
        Symbol1(Symbol),
        Symbol_3f(::std::option::Option<Symbol>),
        SymbolKind1(SymbolKind),
        Terminal(TerminalString),
        TypeParameter(TypeParameter),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        TypeRef(TypeRef),
        TypeRef_3f(::std::option::Option<TypeRef>),
        TypeRefOrLifetime(TypeRef),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        Use(GrammarItem),
        Use_2a(::std::vec::Vec<GrammarItem>),
        ______Grammar(Grammar),
        ______Pattern(Pattern<TypeRef>),
        ______TypeRef(TypeRef),
    }

    // State 0
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [EOF]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   ___TypeRef = (*) TypeRef [EOF]
    //
    //   "#" -> Shift(S4)
    //   "&" -> Shift(S5)
    //   "(" -> Shift(S6)
    //   "::" -> Shift(S7)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S1
    //   Path -> S2
    //   TypeRef -> S3
    pub fn ___state0<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state4(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym0 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym0));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym0 = &mut Some(___nt);
                    ___result = try!(___state3(text, ___lookbehind, ___tokens, ___lookahead, ___sym0));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
    }

    // State 1
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [EOF]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) ["MacroId"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["MacroId"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(93));)
    //   "MacroId" -> Reduce((<Id> "::")* =  => Call(ActionFn(93));)
    //
    //   (<Id> "::")* -> S8
    pub fn ___state1<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action93(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state8(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 2
    //   TypeRef = Path (*) [EOF]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   EOF -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   ")" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //   "<" -> Shift(S9)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(53));)
    //
    pub fn ___state2<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state9(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action53(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 3
    //   ___TypeRef = TypeRef (*) [EOF]
    //
    //   EOF -> Reduce(___TypeRef = TypeRef => Call(ActionFn(1));)
    //
    pub fn ___state3<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action1(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::______TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 4
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [EOF]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [")"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["#"]
    //   Symbol = (*) Symbol0 ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["#"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["#"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   TypeRef = "#" (*) Symbol "#" [","]
    //   TypeRef = "#" (*) Symbol "#" [">"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S10
    //   Symbol -> S11
    //   Symbol0 -> S12
    //   Symbol1 -> S13
    pub fn ___state4<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state10(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state11(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state12(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state13(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 5
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [EOF]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   Lifetime = (*) "Lifetime" ["#"]
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["MacroId"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["#"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["MacroId"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["#"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["MacroId"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //
    //   "#" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "Lifetime" -> Shift(S16)
    //   "MacroId" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(102));)
    //
    //   Lifetime -> S14
    //   Lifetime? -> S15
    pub fn ___state5<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state16(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___nt = super::___action102(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Lifetime_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state14(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Lifetime_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state15(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 6
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [EOF]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   (<TypeRef> ",")* = (*) ["#"]
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) ["MacroId"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(164));)
    //
    //   (<TypeRef> ",")* -> S17
    //   Comma<TypeRef> -> S18
    pub fn ___state6<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action164(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state17(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Comma_3cTypeRef_3e(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state18(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 7
    //   "::"? = "::" (*) ["Id"]
    //   "::"? = "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce("::"? = "::" => Call(ActionFn(96));)
    //   "MacroId" -> Reduce("::"? = "::" => Call(ActionFn(96));)
    //
    pub fn ___state7<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action96(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 8
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [EOF]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [EOF]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "MacroId" [")"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::") = (*) Id "::" ["MacroId"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["MacroId"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "MacroId" [","]
    //   Id = (*) "MacroId" ["::"]
    //   Id = (*) "MacroId" ["<"]
    //   Id = (*) "MacroId" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //
    //   "Id" -> Shift(S21)
    //   "MacroId" -> Shift(S22)
    //
    //   (<Id> "::") -> S19
    //   Id -> S20
    pub fn ___state8<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state21(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok0));
                ___result = try!(___state22(text, ___lookbehind, ___tokens, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state19(text, ___lookbehind, ___tokens, ___lookahead, ___sym1, ___sym2));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state20(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 9
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [EOF]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   (<TypeRefOrLifetime> ",")* = (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(169));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S23
    //   Comma<TypeRefOrLifetime> -> S24
    pub fn ___state9<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action169(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state23(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state24(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 10
    //   Escape = (*) "Escape" ["#"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["#"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["#"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["#"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["#"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["#"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["#"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["#"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["#"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["#"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["#"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["RegexLiteral"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["("]
    //   QuotedTerminal = (*) RegexLiteral [")"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) RegexLiteral ["@L"]
    //   QuotedTerminal = (*) RegexLiteral ["@R"]
    //   QuotedTerminal = (*) RegexLiteral ["Escape"]
    //   QuotedTerminal = (*) RegexLiteral ["Id"]
    //   QuotedTerminal = (*) RegexLiteral ["MacroId"]
    //   QuotedTerminal = (*) RegexLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) RegexLiteral ["StringLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["("]
    //   QuotedTerminal = (*) StringLiteral [")"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral ["<"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["@L"]
    //   QuotedTerminal = (*) StringLiteral ["@R"]
    //   QuotedTerminal = (*) StringLiteral ["Escape"]
    //   QuotedTerminal = (*) StringLiteral ["Id"]
    //   QuotedTerminal = (*) StringLiteral ["MacroId"]
    //   QuotedTerminal = (*) StringLiteral ["RegexLiteral"]
    //   QuotedTerminal = (*) StringLiteral ["StringLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["("]
    //   RegexLiteral = (*) "RegexLiteral" [")"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" ["<"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["@L"]
    //   RegexLiteral = (*) "RegexLiteral" ["@R"]
    //   RegexLiteral = (*) "RegexLiteral" ["Escape"]
    //   RegexLiteral = (*) "RegexLiteral" ["Id"]
    //   RegexLiteral = (*) "RegexLiteral" ["MacroId"]
    //   RegexLiteral = (*) "RegexLiteral" ["RegexLiteral"]
    //   RegexLiteral = (*) "RegexLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["RegexLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["RegexLiteral"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["("]
    //   SymbolKind1 = (*) QuotedTerminal [")"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal ["<"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["@L"]
    //   SymbolKind1 = (*) QuotedTerminal ["@R"]
    //   SymbolKind1 = (*) QuotedTerminal ["Escape"]
    //   SymbolKind1 = (*) QuotedTerminal ["Id"]
    //   SymbolKind1 = (*) QuotedTerminal ["MacroId"]
    //   SymbolKind1 = (*) QuotedTerminal ["RegexLiteral"]
    //   SymbolKind1 = (*) QuotedTerminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["("]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [")"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["<"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@L"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["@R"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["Id"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["RegexLiteral"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "Id" ["("]
    //   SymbolKind1 = (*) "Id" [")"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" ["<"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   SymbolKind1 = (*) "Id" ["@L"]
    //   SymbolKind1 = (*) "Id" ["@R"]
    //   SymbolKind1 = (*) "Id" ["Escape"]
    //   SymbolKind1 = (*) "Id" ["Id"]
    //   SymbolKind1 = (*) "Id" ["MacroId"]
    //   SymbolKind1 = (*) "Id" ["RegexLiteral"]
    //   SymbolKind1 = (*) "Id" ["StringLiteral"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [","]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [","]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [","]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [","]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [","]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [","]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S31)
    //   "<" -> Shift(S32)
    //   "@L" -> Shift(S33)
    //   "@R" -> Shift(S34)
    //   "Escape" -> Shift(S35)
    //   "Id" -> Shift(S36)
    //   "MacroId" -> Shift(S37)
    //   "RegexLiteral" -> Shift(S38)
    //   "StringLiteral" -> Shift(S39)
    //
    //   Escape -> S25
    //   MacroId -> S26
    //   QuotedTerminal -> S27
    //   RegexLiteral -> S28
    //   StringLiteral -> S29
    //   SymbolKind1 -> S30
    pub fn ___state10<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state31(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state32(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state34(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state35(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state36(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state37(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state38(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state39(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state25(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state26(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state27(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state28(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state29(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state30(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 11
    //   TypeRef = "#" Symbol (*) "#" [EOF]
    //   TypeRef = "#" Symbol (*) "#" [")"]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [","]
    //   TypeRef = "#" Symbol (*) "#" [">"]
    //
    //   "#" -> Shift(S40)
    //
    pub fn ___state11<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state40(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 12
    //   RepeatOp = (*) "*" ["#"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["#"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["#"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["RegexLiteral"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["RegexLiteral"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["RegexLiteral"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["RegexLiteral"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "#" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "(" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   ")" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "*" -> Shift(S42)
    //   "+" -> Shift(S43)
    //   "," -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "<" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   ">" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "?" -> Shift(S44)
    //   "@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "Escape" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "Id" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "RegexLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(35));)
    //
    //   RepeatOp -> S41
    pub fn ___state12<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state42(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state43(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state44(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action35(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state41(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 13
    //   Symbol0 = Symbol1 (*) ["#"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["RegexLiteral"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "(" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   ")" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "," -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "<" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   ">" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(36));)
    //
    pub fn ___state13<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action36(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 14
    //   Lifetime? = Lifetime (*) ["#"]
    //   Lifetime? = Lifetime (*) ["&"]
    //   Lifetime? = Lifetime (*) ["("]
    //   Lifetime? = Lifetime (*) ["::"]
    //   Lifetime? = Lifetime (*) ["Id"]
    //   Lifetime? = Lifetime (*) ["MacroId"]
    //   Lifetime? = Lifetime (*) ["mut"]
    //
    //   "#" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "&" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "(" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "::" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "Id" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "MacroId" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //   "mut" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(101));)
    //
    pub fn ___state14<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action101(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 15
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [EOF]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [")"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   "mut"? = (*) ["#"]
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) ["MacroId"]
    //   "mut"? = (*) "mut" ["#"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Id"]
    //   "mut"? = (*) "mut" ["MacroId"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //
    //   "#" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "MacroId" -> Reduce("mut"? =  => Call(ActionFn(100));)
    //   "mut" -> Shift(S46)
    //
    //   "mut"? -> S45
    pub fn ___state15<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Mut, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state46(text, ___lookbehind, ___tokens, ___sym2));
            }
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action100(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22mut_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22mut_22_3f(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state45(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 16
    //   Lifetime = "Lifetime" (*) ["#"]
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["MacroId"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //
    //   "#" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "&" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "(" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "," -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "::" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   ">" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "MacroId" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(77));)
    //
    pub fn ___state16<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::Mut, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action77(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Lifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 17
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["#"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["("]
    //   (<TypeRef> ",") = (*) TypeRef "," [")"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["MacroId"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["MacroId"]
    //   Comma<TypeRef> = (<TypeRef> ",")* (*) TypeRef? [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef? = (*) [")"]
    //   TypeRef? = (*) TypeRef [")"]
    //
    //   "#" -> Shift(S4)
    //   "&" -> Shift(S5)
    //   "(" -> Shift(S6)
    //   ")" -> Reduce(TypeRef? =  => Call(ActionFn(163));)
    //   "::" -> Shift(S7)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S1
    //   (<TypeRef> ",") -> S47
    //   Path -> S2
    //   TypeRef -> S48
    //   TypeRef? -> S49
    pub fn ___state17<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state4(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___nt = super::___action163(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::TypeRef_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state47(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state48(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state49(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 18
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [EOF]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S50)
    //
    pub fn ___state18<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state50(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 19
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(94));)
    //   "MacroId" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(94));)
    //
    pub fn ___state19<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action94(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 20
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [EOF]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   (<Id> "::") = Id (*) "::" ["MacroId"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //
    //   EOF -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   "::" -> Shift(S51)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(56));)
    //
    pub fn ___state20<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym1: &mut Option<::std::vec::Vec<InternedString>>,
        ___sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state51(text, ___lookbehind, ___tokens, ___sym2, ___sym3));
            }
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action56(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Path(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 21
    //   Id = "Id" (*) [EOF]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //
    //   EOF -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //
    pub fn ___state21<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 22
    //   Id = "MacroId" (*) [EOF]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [")"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [","]
    //   Id = "MacroId" (*) ["::"]
    //   Id = "MacroId" (*) ["<"]
    //   Id = "MacroId" (*) [">"]
    //
    //   EOF -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   ")" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "," -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "::" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "<" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   ">" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //
    pub fn ___state22<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 23
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["#"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["MacroId"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["MacroId"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* (*) TypeRefOrLifetime? [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   TypeRefOrLifetime? = (*) [">"]
    //   TypeRefOrLifetime? = (*) TypeRefOrLifetime [">"]
    //
    //   "#" -> Shift(S4)
    //   "&" -> Shift(S5)
    //   "(" -> Shift(S6)
    //   "::" -> Shift(S7)
    //   ">" -> Reduce(TypeRefOrLifetime? =  => Call(ActionFn(168));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "Lifetime" -> Shift(S16)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S1
    //   (<TypeRefOrLifetime> ",") -> S52
    //   Lifetime -> S53
    //   Path -> S2
    //   TypeRef -> S54
    //   TypeRefOrLifetime -> S55
    //   TypeRefOrLifetime? -> S56
    pub fn ___state23<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state4(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Lifetime(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state16(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action168(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state52(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Lifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state53(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state54(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state55(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::TypeRefOrLifetime_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state56(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 24
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [EOF]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S57)
    //
    pub fn ___state24<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state57(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 25
    //   SymbolKind1 = Escape (*) ["#"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["RegexLiteral"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "(" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   ")" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "," -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "<" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   ">" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "Id" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(45));)
    //
    pub fn ___state25<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action45(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 26
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Shift(S58)
    //
    pub fn ___state26<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LessThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state58(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 27
    //   SymbolKind1 = QuotedTerminal (*) ["#"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["("]
    //   SymbolKind1 = QuotedTerminal (*) [")"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) ["<"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //   SymbolKind1 = QuotedTerminal (*) ["@L"]
    //   SymbolKind1 = QuotedTerminal (*) ["@R"]
    //   SymbolKind1 = QuotedTerminal (*) ["Escape"]
    //   SymbolKind1 = QuotedTerminal (*) ["Id"]
    //   SymbolKind1 = QuotedTerminal (*) ["MacroId"]
    //   SymbolKind1 = QuotedTerminal (*) ["RegexLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["StringLiteral"]
    //   SymbolKind1 = QuotedTerminal (*) ["*"]
    //   SymbolKind1 = QuotedTerminal (*) ["+"]
    //   SymbolKind1 = QuotedTerminal (*) [","]
    //   SymbolKind1 = QuotedTerminal (*) [">"]
    //   SymbolKind1 = QuotedTerminal (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "(" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   ")" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "," -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "<" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "@L" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "@R" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "Escape" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "Id" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "MacroId" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = QuotedTerminal => Call(ActionFn(43));)
    //
    pub fn ___state27<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action43(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 28
    //   QuotedTerminal = RegexLiteral (*) ["#"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["("]
    //   QuotedTerminal = RegexLiteral (*) [")"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) ["<"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //   QuotedTerminal = RegexLiteral (*) ["@L"]
    //   QuotedTerminal = RegexLiteral (*) ["@R"]
    //   QuotedTerminal = RegexLiteral (*) ["Escape"]
    //   QuotedTerminal = RegexLiteral (*) ["Id"]
    //   QuotedTerminal = RegexLiteral (*) ["MacroId"]
    //   QuotedTerminal = RegexLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = RegexLiteral (*) ["*"]
    //   QuotedTerminal = RegexLiteral (*) ["+"]
    //   QuotedTerminal = RegexLiteral (*) [","]
    //   QuotedTerminal = RegexLiteral (*) [">"]
    //   QuotedTerminal = RegexLiteral (*) ["?"]
    //
    //   "#" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "(" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   ")" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "*" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "+" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "," -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "<" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   ">" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "?" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "@L" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "@R" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "Escape" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "Id" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "MacroId" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = RegexLiteral => Call(ActionFn(81));)
    //
    pub fn ___state28<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action81(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 29
    //   QuotedTerminal = StringLiteral (*) ["#"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["("]
    //   QuotedTerminal = StringLiteral (*) [")"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) ["<"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //   QuotedTerminal = StringLiteral (*) ["@L"]
    //   QuotedTerminal = StringLiteral (*) ["@R"]
    //   QuotedTerminal = StringLiteral (*) ["Escape"]
    //   QuotedTerminal = StringLiteral (*) ["Id"]
    //   QuotedTerminal = StringLiteral (*) ["MacroId"]
    //   QuotedTerminal = StringLiteral (*) ["RegexLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["StringLiteral"]
    //   QuotedTerminal = StringLiteral (*) ["*"]
    //   QuotedTerminal = StringLiteral (*) ["+"]
    //   QuotedTerminal = StringLiteral (*) [","]
    //   QuotedTerminal = StringLiteral (*) [">"]
    //   QuotedTerminal = StringLiteral (*) ["?"]
    //
    //   "#" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "(" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   ")" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "*" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "+" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "," -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "<" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   ">" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "?" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "@L" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "@R" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "Escape" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "Id" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "MacroId" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "RegexLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //   "StringLiteral" -> Reduce(QuotedTerminal = StringLiteral => Call(ActionFn(80));)
    //
    pub fn ___state29<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action80(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::QuotedTerminal(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 30
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["#"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S59
    pub fn ___state30<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state59(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 31
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["#"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["("]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [")"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["<"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@L"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["@R"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Escape"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["Id"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["StringLiteral"]
    //   ExprSymbol = (*) Symbol* [")"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["RegexLiteral"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["RegexLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["*"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["+"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [","]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" [">"]
    //   SymbolKind1 = "(" (*) ExprSymbol ")" ["?"]
    //
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "RegexLiteral" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(105));)
    //
    //   ExprSymbol -> S60
    //   Symbol* -> S61
    pub fn ___state31<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action105(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Symbol_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::ExprSymbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state60(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol_2a(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state61(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 32
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S62
    //   Symbol0 -> S63
    //   Symbol1 -> S13
    pub fn ___state32<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state62(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state63(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state13(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 33
    //   SymbolKind1 = "@L" (*) ["#"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "(" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   ")" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "," -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "<" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   ">" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(47));)
    //
    pub fn ___state33<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action47(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 34
    //   SymbolKind1 = "@R" (*) ["#"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["RegexLiteral"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "(" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   ")" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "," -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "<" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   ">" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(48));)
    //
    pub fn ___state34<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action48(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 35
    //   Escape = "Escape" (*) ["#"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["RegexLiteral"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //
    //   "#" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "(" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "<" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "@L" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "@R" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "Escape" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "Id" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "MacroId" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "RegexLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(76));)
    //
    pub fn ___state35<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action76(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Escape(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 36
    //   SymbolKind1 = "Id" (*) ["#"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["("]
    //   SymbolKind1 = "Id" (*) [")"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) ["<"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["@L"]
    //   SymbolKind1 = "Id" (*) ["@R"]
    //   SymbolKind1 = "Id" (*) ["Escape"]
    //   SymbolKind1 = "Id" (*) ["Id"]
    //   SymbolKind1 = "Id" (*) ["MacroId"]
    //   SymbolKind1 = "Id" (*) ["RegexLiteral"]
    //   SymbolKind1 = "Id" (*) ["StringLiteral"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [","]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "(" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ")" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "," -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "<" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "@L" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "@R" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "Escape" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "Id" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "MacroId" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //
    pub fn ___state36<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 37
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(72));)
    //
    pub fn ___state37<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action72(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 38
    //   RegexLiteral = "RegexLiteral" (*) ["#"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["("]
    //   RegexLiteral = "RegexLiteral" (*) [")"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) ["<"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //   RegexLiteral = "RegexLiteral" (*) ["@L"]
    //   RegexLiteral = "RegexLiteral" (*) ["@R"]
    //   RegexLiteral = "RegexLiteral" (*) ["Escape"]
    //   RegexLiteral = "RegexLiteral" (*) ["Id"]
    //   RegexLiteral = "RegexLiteral" (*) ["MacroId"]
    //   RegexLiteral = "RegexLiteral" (*) ["RegexLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["StringLiteral"]
    //   RegexLiteral = "RegexLiteral" (*) ["*"]
    //   RegexLiteral = "RegexLiteral" (*) ["+"]
    //   RegexLiteral = "RegexLiteral" (*) [","]
    //   RegexLiteral = "RegexLiteral" (*) [">"]
    //   RegexLiteral = "RegexLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "(" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   ")" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "*" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "+" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "," -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "<" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   ">" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "?" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "@L" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "@R" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "Escape" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "Id" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "MacroId" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "RegexLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //   "StringLiteral" -> Reduce(RegexLiteral = "RegexLiteral" => Call(ActionFn(83));)
    //
    pub fn ___state38<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action83(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RegexLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 39
    //   StringLiteral = "StringLiteral" (*) ["#"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["RegexLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //
    //   "#" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "RegexLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(82));)
    //
    pub fn ___state39<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action82(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::StringLiteral(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 40
    //   TypeRef = "#" Symbol "#" (*) [EOF]
    //   TypeRef = "#" Symbol "#" (*) [")"]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [","]
    //   TypeRef = "#" Symbol "#" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   ")" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   "," -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //   ">" -> Reduce(TypeRef = "#", Symbol, "#" => Call(ActionFn(50));)
    //
    pub fn ___state40<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Symbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action50(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 41
    //   @R = (*) ["#"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["#"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S64
    pub fn ___state41<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state64(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 42
    //   RepeatOp = "*" (*) ["#"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["RegexLiteral"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "(" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   ")" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "," -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "<" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   ">" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "Escape" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "Id" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "MacroId" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(39));)
    //
    pub fn ___state42<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action39(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 43
    //   RepeatOp = "+" (*) ["#"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["RegexLiteral"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "(" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   ")" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "," -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "<" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   ">" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "Escape" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "Id" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "MacroId" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(38));)
    //
    pub fn ___state43<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action38(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 44
    //   RepeatOp = "?" (*) ["#"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["RegexLiteral"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //
    //   "#" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "(" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   ")" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "," -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "<" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   ">" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "Escape" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "Id" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "MacroId" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "RegexLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(40));)
    //
    pub fn ___state44<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action40(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::RepeatOp(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 45
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [EOF]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [EOF]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [EOF]
    //   TypeRef = (*) "#" Symbol "#" [EOF]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [EOF]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [EOF]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [EOF]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "#" Symbol "#" [")"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) ["MacroId"]
    //   "::"? = (*) "::" ["Id"]
    //   "::"? = (*) "::" ["MacroId"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "#" Symbol "#" [","]
    //   TypeRef = (*) "#" Symbol "#" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "#" -> Shift(S4)
    //   "&" -> Shift(S5)
    //   "(" -> Shift(S6)
    //   "::" -> Shift(S7)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(97));)
    //   "MacroId" -> Reduce("::"? =  => Call(ActionFn(97));)
    //
    //   "::"? -> S1
    //   Path -> S2
    //   TypeRef -> S65
    pub fn ___state45<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
        ___sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Hash, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state4(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Ampersand, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state5(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state6(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::ColonColon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state7(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___nt = super::___action97(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_22_3a_3a_22_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_22_3a_3a_22_3f(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state1(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Path(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state2(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::TypeRef(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state65(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 46
    //   "mut"? = "mut" (*) ["#"]
    //   "mut"? = "mut" (*) ["&"]
    //   "mut"? = "mut" (*) ["("]
    //   "mut"? = "mut" (*) ["::"]
    //   "mut"? = "mut" (*) ["Id"]
    //   "mut"? = "mut" (*) ["MacroId"]
    //
    //   "#" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "&" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "(" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "::" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "Id" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //   "MacroId" -> Reduce("mut"? = "mut" => Call(ActionFn(99));)
    //
    pub fn ___state46<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action99(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_22mut_22_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 47
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["#"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "&" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "(" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   ")" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "::" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "Id" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //   "MacroId" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(165));)
    //
    pub fn ___state47<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action165(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 48
    //   (<TypeRef> ",") = TypeRef (*) "," ["#"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["("]
    //   (<TypeRef> ",") = TypeRef (*) "," [")"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Id"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["MacroId"]
    //   TypeRef? = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(TypeRef? = TypeRef => Call(ActionFn(162));)
    //   "," -> Shift(S66)
    //
    pub fn ___state48<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state66(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action162(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 49
    //   Comma<TypeRef> = (<TypeRef> ",")* TypeRef? (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")*, TypeRef? => Call(ActionFn(103));)
    //
    pub fn ___state49<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action103(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRef_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 50
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [EOF]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(49));)
    //
    pub fn ___state50<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<Vec<TypeRef>>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action49(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 51
    //   (<Id> "::") = Id "::" (*) ["Id"]
    //   (<Id> "::") = Id "::" (*) ["MacroId"]
    //
    //   "Id" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(95));)
    //   "MacroId" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(95));)
    //
    pub fn ___state51<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<InternedString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action95(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 52
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["#"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(170));)
    //
    pub fn ___state52<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action170(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 53
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(55));)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(55));)
    //
    pub fn ___state53<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action55(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 54
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(54));)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(54));)
    //
    pub fn ___state54<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action54(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 55
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["MacroId"]
    //   TypeRefOrLifetime? = TypeRefOrLifetime (*) [">"]
    //
    //   "," -> Shift(S67)
    //   ">" -> Reduce(TypeRefOrLifetime? = TypeRefOrLifetime => Call(ActionFn(167));)
    //
    pub fn ___state55<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state67(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action167(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRefOrLifetime_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 56
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")*, TypeRefOrLifetime? => Call(ActionFn(98));)
    //
    pub fn ___state56<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        ___sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action98(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cTypeRefOrLifetime_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 57
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [EOF]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(52));)
    //
    pub fn ___state57<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Path>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<TypeRef>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action52(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 58
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["#"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(159));)
    //
    //   (<Symbol> ",")* -> S68
    //   Comma<Symbol> -> S69
    pub fn ___state58<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = super::___action159(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym1.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state68(text, ___lookbehind, ___tokens, ___lookahead, ___sym2));
                }
                ___Nonterminal::Comma_3cSymbol_3e(___nt) => {
                    let ___sym2 = &mut Some(___nt);
                    ___result = try!(___state69(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 59
    //   Symbol1 = @L SymbolKind1 @R (*) ["#"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["RegexLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //
    //   "#" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "RegexLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(41));)
    //
    pub fn ___state59<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<SymbolKind>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action41(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 60
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["#"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["("]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [")"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["<"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@L"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["@R"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["Id"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["*"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["+"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [","]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" [">"]
    //   SymbolKind1 = "(" ExprSymbol (*) ")" ["?"]
    //
    //   ")" -> Shift(S70)
    //
    pub fn ___state60<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::RightParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym2 = &mut Some((___tok));
                ___result = try!(___state70(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 61
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   ExprSymbol = Symbol* (*) [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["RegexLiteral"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["RegexLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["RegexLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["RegexLiteral"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["RegexLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(ExprSymbol = Symbol* => Call(ActionFn(32));)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S10
    //   Symbol -> S71
    //   Symbol0 -> S12
    //   Symbol1 -> S13
    pub fn ___state61<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::RightParen, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action32(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::ExprSymbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state10(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state71(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state12(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state13(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 62
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["#"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "MacroId" [":"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S31)
    //   "@L" -> Shift(S33)
    //   "@R" -> Shift(S34)
    //   "Escape" -> Shift(S35)
    //   "Id" -> Shift(S73)
    //   "MacroId" -> Shift(S74)
    //   "RegexLiteral" -> Shift(S38)
    //   "StringLiteral" -> Shift(S39)
    //
    //   Escape -> S25
    //   Id -> S72
    //   MacroId -> S26
    //   QuotedTerminal -> S27
    //   RegexLiteral -> S28
    //   StringLiteral -> S29
    //   SymbolKind1 -> S30
    pub fn ___state62<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state31(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state34(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state35(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state73(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state74(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state38(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok0));
                ___result = try!(___state39(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state25(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::Id(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state72(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state26(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state27(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state28(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state29(text, ___lookbehind, ___tokens, ___lookahead, ___sym3));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state30(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 63
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S42)
    //   "+" -> Shift(S43)
    //   ">" -> Shift(S75)
    //   "?" -> Shift(S44)
    //
    //   RepeatOp -> S41
    pub fn ___state63<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state42(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state43(text, ___lookbehind, ___tokens, ___sym3));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state75(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state44(text, ___lookbehind, ___tokens, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym2.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym3 = &mut Some(___nt);
                    ___result = try!(___state41(text, ___lookbehind, ___tokens, ___lookahead, ___sym2, ___sym3));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 64
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["#"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["RegexLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //
    //   "#" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "RegexLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(37));)
    //
    pub fn ___state64<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<RepeatOp>,
        ___sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action37(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol0(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 65
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [EOF]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //
    //   EOF -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   ")" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(51));)
    //
    pub fn ___state65<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<::std::option::Option<InternedString>>,
        ___sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        ___sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            None |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action51(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::TypeRef(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 66
    //   (<TypeRef> ",") = TypeRef "," (*) ["#"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["("]
    //   (<TypeRef> ",") = TypeRef "," (*) [")"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Id"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "&" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "(" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   ")" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "::" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "Id" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //   "MacroId" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(166));)
    //
    pub fn ___state66<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action166(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 67
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["#"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["MacroId"]
    //
    //   "#" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //   "MacroId" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(171));)
    //
    pub fn ___state67<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<TypeRef>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::Ampersand, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::ColonColon, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::Lifetime(_), _)) |
            Some((_, Tok::MacroId(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action171(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 68
    //   (<Symbol> ",") = (*) Symbol "," ["("]
    //   (<Symbol> ",") = (*) Symbol "," ["<"]
    //   (<Symbol> ",") = (*) Symbol "," [">"]
    //   (<Symbol> ",") = (*) Symbol "," ["@L"]
    //   (<Symbol> ",") = (*) Symbol "," ["@R"]
    //   (<Symbol> ",") = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",") = (*) Symbol "," ["Id"]
    //   (<Symbol> ",") = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",") = (*) Symbol "," ["RegexLiteral"]
    //   (<Symbol> ",") = (*) Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["RegexLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")* (*) Symbol? [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol? = (*) [">"]
    //   Symbol? = (*) Symbol [">"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   ">" -> Reduce(Symbol? =  => Call(ActionFn(158));)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   (<Symbol> ",") -> S76
    //   @L -> S10
    //   Symbol -> S77
    //   Symbol0 -> S12
    //   Symbol1 -> S13
    //   Symbol? -> S78
    pub fn ___state68<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___nt = super::___action158(text, );
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::Symbol_3f(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state76(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                ___Nonterminal::_40L(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state10(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state77(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state12(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state13(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::Symbol_3f(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state78(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 69
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //
    //   ">" -> Shift(S79)
    //
    pub fn ___state69<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym3 = &mut Some((___tok));
                ___result = try!(___state79(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 70
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["#"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["("]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [")"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["<"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@L"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["@R"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Escape"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["Id"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["RegexLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["*"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["+"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [","]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) [">"]
    //   SymbolKind1 = "(" ExprSymbol ")" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "(" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   ")" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "*" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "+" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "," -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "<" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   ">" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "?" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "@L" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "@R" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "Escape" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "Id" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", ExprSymbol, ")" => Call(ActionFn(46));)
    //
    pub fn ___state70<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Tok<'input>>,
        ___sym1: &mut Option<ExprSymbol>,
        ___sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___nt = super::___action46(text, ___sym0, ___sym1, ___sym2);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 71
    //   Symbol* = Symbol* Symbol (*) ["("]
    //   Symbol* = Symbol* Symbol (*) [")"]
    //   Symbol* = Symbol* Symbol (*) ["<"]
    //   Symbol* = Symbol* Symbol (*) ["@L"]
    //   Symbol* = Symbol* Symbol (*) ["@R"]
    //   Symbol* = Symbol* Symbol (*) ["Escape"]
    //   Symbol* = Symbol* Symbol (*) ["Id"]
    //   Symbol* = Symbol* Symbol (*) ["MacroId"]
    //   Symbol* = Symbol* Symbol (*) ["RegexLiteral"]
    //   Symbol* = Symbol* Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   ")" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "<" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "Escape" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "Id" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "MacroId" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "RegexLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //   "StringLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(106));)
    //
    pub fn ___state71<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action106(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 72
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["#"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //
    //   ":" -> Shift(S80)
    //
    pub fn ___state72<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Colon, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym4 = &mut Some((___tok));
                ___result = try!(___state80(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 73
    //   Id = "Id" (*) [":"]
    //   SymbolKind1 = "Id" (*) ["*"]
    //   SymbolKind1 = "Id" (*) ["+"]
    //   SymbolKind1 = "Id" (*) [">"]
    //   SymbolKind1 = "Id" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "+" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(74));)
    //   ">" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //   "?" -> Reduce(SymbolKind1 = "Id" => Call(ActionFn(44));)
    //
    pub fn ___state73<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action74(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action44(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 74
    //   Id = "MacroId" (*) [":"]
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   ":" -> Reduce(Id = "MacroId" => Call(ActionFn(75));)
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(72));)
    //
    pub fn ___state74<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Colon, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action75(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Id(___nt)));
            }
            Some((_, Tok::LessThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action72(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::MacroId(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 75
    //   @R = (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S81
    pub fn ___state75<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym3.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym4 = &mut Some(___nt);
                    ___result = try!(___state81(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 76
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["RegexLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "<" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   ">" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "@L" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "@R" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "Escape" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "Id" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "MacroId" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(160));)
    //
    pub fn ___state76<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action160(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 77
    //   (<Symbol> ",") = Symbol (*) "," ["("]
    //   (<Symbol> ",") = Symbol (*) "," ["<"]
    //   (<Symbol> ",") = Symbol (*) "," [">"]
    //   (<Symbol> ",") = Symbol (*) "," ["@L"]
    //   (<Symbol> ",") = Symbol (*) "," ["@R"]
    //   (<Symbol> ",") = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",") = Symbol (*) "," ["Id"]
    //   (<Symbol> ",") = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",") = Symbol (*) "," ["RegexLiteral"]
    //   (<Symbol> ",") = Symbol (*) "," ["StringLiteral"]
    //   Symbol? = Symbol (*) [">"]
    //
    //   "," -> Shift(S82)
    //   ">" -> Reduce(Symbol? = Symbol => Call(ActionFn(157));)
    //
    pub fn ___state77<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Comma, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state82(text, ___lookbehind, ___tokens, ___sym0, ___sym1));
            }
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___nt = super::___action157(text, ___sym0);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol_3f(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(___result);
    }

    // State 78
    //   Comma<Symbol> = (<Symbol> ",")* Symbol? (*) [">"]
    //
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")*, Symbol? => Call(ActionFn(104));)
    //
    pub fn ___state78<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<::std::vec::Vec<Symbol>>,
        ___sym1: &mut Option<::std::option::Option<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::GreaterThan, _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action104(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Comma_3cSymbol_3e(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 79
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["#"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["RegexLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //
    //   "#" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "RegexLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(42));)
    //
    pub fn ___state79<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<NonterminalString>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Vec<Symbol>>,
        ___sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Star, _)) |
            Some((_, Tok::Plus, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Question, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___nt = super::___action42(text, ___sym0, ___sym1, ___sym2, ___sym3);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::SymbolKind1(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 80
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["#"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["RegexLiteral"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "RegexLiteral" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S83
    //   Symbol0 -> S84
    //   Symbol1 -> S13
    pub fn ___state80<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ___lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&___lookbehind)).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40L(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym4.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40L(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state83(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                ___Nonterminal::Symbol0(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state84(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5));
                }
                ___Nonterminal::Symbol1(___nt) => {
                    let ___sym5 = &mut Some(___nt);
                    ___result = try!(___state13(text, ___lookbehind, ___tokens, ___lookahead, ___sym5));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 81
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(34));)
    //
    pub fn ___state81<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<Symbol>,
        ___sym3: &mut Option<Tok<'input>>,
        ___sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___nt = super::___action34(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 82
    //   (<Symbol> ",") = Symbol "," (*) ["("]
    //   (<Symbol> ",") = Symbol "," (*) ["<"]
    //   (<Symbol> ",") = Symbol "," (*) [">"]
    //   (<Symbol> ",") = Symbol "," (*) ["@L"]
    //   (<Symbol> ",") = Symbol "," (*) ["@R"]
    //   (<Symbol> ",") = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",") = Symbol "," (*) ["Id"]
    //   (<Symbol> ",") = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",") = Symbol "," (*) ["RegexLiteral"]
    //   (<Symbol> ",") = Symbol "," (*) ["StringLiteral"]
    //
    //   "(" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "<" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   ">" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "@L" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "@R" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "Escape" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "Id" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "MacroId" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "RegexLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //   "StringLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(161));)
    //
    pub fn ___state82<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<Symbol>,
        ___sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___nt = super::___action161(text, ___sym0, ___sym1);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 83
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   QuotedTerminal = (*) RegexLiteral ["*"]
    //   QuotedTerminal = (*) RegexLiteral ["+"]
    //   QuotedTerminal = (*) RegexLiteral [">"]
    //   QuotedTerminal = (*) RegexLiteral ["?"]
    //   QuotedTerminal = (*) StringLiteral ["*"]
    //   QuotedTerminal = (*) StringLiteral ["+"]
    //   QuotedTerminal = (*) StringLiteral [">"]
    //   QuotedTerminal = (*) StringLiteral ["?"]
    //   RegexLiteral = (*) "RegexLiteral" ["*"]
    //   RegexLiteral = (*) "RegexLiteral" ["+"]
    //   RegexLiteral = (*) "RegexLiteral" [">"]
    //   RegexLiteral = (*) "RegexLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) QuotedTerminal ["*"]
    //   SymbolKind1 = (*) QuotedTerminal ["+"]
    //   SymbolKind1 = (*) QuotedTerminal [">"]
    //   SymbolKind1 = (*) QuotedTerminal ["?"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["*"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["+"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" [">"]
    //   SymbolKind1 = (*) "(" ExprSymbol ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "Id" ["*"]
    //   SymbolKind1 = (*) "Id" ["+"]
    //   SymbolKind1 = (*) "Id" [">"]
    //   SymbolKind1 = (*) "Id" ["?"]
    //
    //   "(" -> Shift(S31)
    //   "@L" -> Shift(S33)
    //   "@R" -> Shift(S34)
    //   "Escape" -> Shift(S35)
    //   "Id" -> Shift(S36)
    //   "MacroId" -> Shift(S37)
    //   "RegexLiteral" -> Shift(S38)
    //   "StringLiteral" -> Shift(S39)
    //
    //   Escape -> S25
    //   MacroId -> S26
    //   QuotedTerminal -> S27
    //   RegexLiteral -> S28
    //   StringLiteral -> S29
    //   SymbolKind1 -> S30
    pub fn ___state83<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::LeftParen, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state31(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookahead, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state33(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, ___tok @ Tok::Lookbehind, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok));
                ___result = try!(___state34(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Escape(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state35(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::Id(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state36(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::MacroId(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state37(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::RegexLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state38(text, ___lookbehind, ___tokens, ___sym1));
            }
            Some((_, Tok::StringLiteral(___tok0), ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym1 = &mut Some((___tok0));
                ___result = try!(___state39(text, ___lookbehind, ___tokens, ___sym1));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym0.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::Escape(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state25(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::MacroId(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state26(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::QuotedTerminal(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state27(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::RegexLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state28(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::StringLiteral(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state29(text, ___lookbehind, ___tokens, ___lookahead, ___sym1));
                }
                ___Nonterminal::SymbolKind1(___nt) => {
                    let ___sym1 = &mut Some(___nt);
                    ___result = try!(___state30(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 84
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["#"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S42)
    //   "+" -> Shift(S43)
    //   ">" -> Shift(S85)
    //   "?" -> Shift(S44)
    //
    //   RepeatOp -> S41
    pub fn ___state84<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, ___tok @ Tok::Star, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state42(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::Plus, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state43(text, ___lookbehind, ___tokens, ___sym6));
            }
            Some((_, ___tok @ Tok::GreaterThan, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state85(text, ___lookbehind, ___tokens, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6));
            }
            Some((_, ___tok @ Tok::Question, ___loc)) => {
                let mut ___lookbehind = Some(___loc);
                let mut ___sym6 = &mut Some((___tok));
                ___result = try!(___state44(text, ___lookbehind, ___tokens, ___sym6));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym5.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::RepeatOp(___nt) => {
                    let ___sym6 = &mut Some(___nt);
                    ___result = try!(___state41(text, ___lookbehind, ___tokens, ___lookahead, ___sym5, ___sym6));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 85
    //   @R = (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["#"]
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["RegexLiteral"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //
    //   "#" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "RegexLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S86
    pub fn ___state85<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        let ___lookahead = match ___tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(___ParseError::User { error: e }),
        };
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___nt = ::std::clone::Clone::clone(&___lookbehind).unwrap_or_default();
                ___result = (___lookbehind, ___lookahead, ___Nonterminal::_40R(___nt));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
        while ___sym6.is_some() {
            let (___lookbehind, ___lookahead, ___nt) = ___result;
            match ___nt {
                ___Nonterminal::_40R(___nt) => {
                    let ___sym7 = &mut Some(___nt);
                    ___result = try!(___state86(text, ___lookbehind, ___tokens, ___lookahead, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7));
                }
                _ => {
                    return Ok((___lookbehind, ___lookahead, ___nt));
                }
            }
        }
        return Ok(___result);
    }

    // State 86
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["#"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["RegexLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //
    //   "#" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "RegexLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(33));)
    //
    pub fn ___state86<
        'input,
        ___TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        ___lookbehind: Option<usize>,
        ___tokens: &mut ___TOKENS,
        ___lookahead: Option<(usize, Tok<'input>, usize)>,
        ___sym0: &mut Option<usize>,
        ___sym1: &mut Option<Tok<'input>>,
        ___sym2: &mut Option<usize>,
        ___sym3: &mut Option<InternedString>,
        ___sym4: &mut Option<Tok<'input>>,
        ___sym5: &mut Option<Symbol>,
        ___sym6: &mut Option<Tok<'input>>,
        ___sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>), ___ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut ___result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, ___Nonterminal<'input>);
        match ___lookahead {
            Some((_, Tok::Hash, _)) |
            Some((_, Tok::LeftParen, _)) |
            Some((_, Tok::RightParen, _)) |
            Some((_, Tok::Comma, _)) |
            Some((_, Tok::LessThan, _)) |
            Some((_, Tok::GreaterThan, _)) |
            Some((_, Tok::Lookahead, _)) |
            Some((_, Tok::Lookbehind, _)) |
            Some((_, Tok::Escape(_), _)) |
            Some((_, Tok::Id(_), _)) |
            Some((_, Tok::MacroId(_), _)) |
            Some((_, Tok::RegexLiteral(_), _)) |
            Some((_, Tok::StringLiteral(_), _)) => {
                let ___sym0 = ___sym0.take().unwrap();
                let ___sym1 = ___sym1.take().unwrap();
                let ___sym2 = ___sym2.take().unwrap();
                let ___sym3 = ___sym3.take().unwrap();
                let ___sym4 = ___sym4.take().unwrap();
                let ___sym5 = ___sym5.take().unwrap();
                let ___sym6 = ___sym6.take().unwrap();
                let ___sym7 = ___sym7.take().unwrap();
                let ___nt = super::___action33(text, ___sym0, ___sym1, ___sym2, ___sym3, ___sym4, ___sym5, ___sym6, ___sym7);
                return Ok((___lookbehind, ___lookahead, ___Nonterminal::Symbol(___nt)));
            }
            _ => {
                return Err(___ParseError::UnrecognizedToken {
                    token: ___lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
pub use self::___parse___TypeRef::parse_TypeRef;

pub fn ___action0<
    'input,
>(
    text: &'input str,
    ___0: Grammar,
) -> Grammar
{
    (___0)
}

pub fn ___action1<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
) -> TypeRef
{
    (___0)
}

pub fn ___action2<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
) -> Pattern<TypeRef>
{
    (___0)
}

pub fn ___action3<
    'input,
>(
    text: &'input str,
    uses: ::std::vec::Vec<GrammarItem>,
    lo: usize,
    _: Tok<'input>,
    hi: usize,
    tps: ::std::option::Option<Vec<TypeParameter>>,
    parameters: ::std::option::Option<Vec<Parameter>>,
    where_clauses: ::std::option::Option<Vec<&'input str>>,
    algorithm: ::std::option::Option<Algorithm>,
    _: Tok<'input>,
    items: ::std::vec::Vec<GrammarItem>,
) -> Grammar
{
    {
        let where_clauses =
            where_clauses.iter()
                         .flat_map(|wc| wc.iter())
                         .map(|s| strip(s))
                         .filter(|s| !s.is_empty())
                         .map(|s| s.to_string())
                         .collect();
        Grammar { prefix: format!("__"), // adjusted by `parse_grammar`
                  span: Span(lo, hi),
                  type_parameters: tps.unwrap_or(vec![]),
                  parameters: parameters.unwrap_or(vec![]),
                  where_clauses: where_clauses,
                  items: uses.into_iter().chain(items).collect(),
                  algorithm: algorithm }
    }
}

pub fn ___action4<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    lo: usize,
    t: InternedString,
    hi: usize,
    _: Tok<'input>,
) -> Algorithm
{
    {
        Algorithm {
            span: Span(lo, hi),
            text: t
        }
    }
}

pub fn ___action5<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<TypeParameter>,
    _: Tok<'input>,
) -> Vec<TypeParameter>
{
    (___0)
}

pub fn ___action6<
    'input,
>(
    text: &'input str,
    l: InternedString,
) -> TypeParameter
{
    TypeParameter::Lifetime(l)
}

pub fn ___action7<
    'input,
>(
    text: &'input str,
    l: InternedString,
) -> TypeParameter
{
    TypeParameter::Id(l)
}

pub fn ___action8<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<Parameter>,
    _: Tok<'input>,
) -> Vec<Parameter>
{
    (___0)
}

pub fn ___action9<
    'input,
>(
    text: &'input str,
    id: InternedString,
    _: Tok<'input>,
    ty: TypeRef,
) -> Parameter
{
    Parameter { name: id, ty: ty }
}

pub fn ___action10<
    'input,
>(
    text: &'input str,
    ___0: GrammarItem,
) -> GrammarItem
{
    (___0)
}

pub fn ___action11<
    'input,
>(
    text: &'input str,
    ___0: GrammarItem,
) -> GrammarItem
{
    (___0)
}

pub fn ___action12<
    'input,
>(
    text: &'input str,
    ___0: GrammarItem,
) -> GrammarItem
{
    (___0)
}

pub fn ___action13<
    'input,
>(
    text: &'input str,
    u: &'input str,
    _: Tok<'input>,
) -> GrammarItem
{
    GrammarItem::Use(strip(u).to_string())
}

pub fn ___action14<
    'input,
>(
    text: &'input str,
    annotations: ::std::vec::Vec<Annotation>,
    p: ::std::option::Option<Tok<'input>>,
    lo: usize,
    n: (NonterminalString, Vec<NonterminalString>),
    hi: usize,
    t: ::std::option::Option<TypeRef>,
    _: Tok<'input>,
    a: Vec<Alternative>,
) -> GrammarItem
{
    {
        GrammarItem::Nonterminal(NonterminalData { public: p.is_some(),
                                                   span: Span(lo, hi),
                                                   name: n.0,
                                                   annotations: annotations,
                                                   args: n.1,
                                                   type_decl: t,
                                                   alternatives: a })
    }
}

pub fn ___action15<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    _: Tok<'input>,
    lo: usize,
    id: InternedString,
    hi: usize,
    _: Tok<'input>,
) -> Annotation
{
    {
        Annotation { id_span: Span(lo, hi), id: id }
    }
}

pub fn ___action16<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
    _: Tok<'input>,
    ___1: Vec<NonterminalString>,
    _: Tok<'input>,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (___0, ___1)
}

pub fn ___action17<
    'input,
>(
    text: &'input str,
    n: NonterminalString,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (n, vec![])
}

pub fn ___action18<
    'input,
>(
    text: &'input str,
    ___0: &'input str,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (NonterminalString(intern(___0)), vec![])
}

pub fn ___action19<
    'input,
>(
    text: &'input str,
    a: Alternative,
    _: Tok<'input>,
) -> Vec<Alternative>
{
    vec![a]
}

pub fn ___action20<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<Alternative>,
    _: Tok<'input>,
    _: Tok<'input>,
) -> Vec<Alternative>
{
    (___0)
}

pub fn ___action21<
    'input,
>(
    text: &'input str,
    lo: usize,
    s: ::std::vec::Vec<Symbol>,
    c: ::std::option::Option<Condition>,
    a: ::std::option::Option<ActionKind>,
    hi: usize,
) -> Alternative
{
    {
        Alternative {
            span: Span(lo, hi),
            expr: ExprSymbol { symbols: s },
            condition: c,
            action: a
        }
    }
}

pub fn ___action22<
    'input,
>(
    text: &'input str,
    lo: usize,
    c: ::std::option::Option<Condition>,
    a: ActionKind,
    hi: usize,
) -> Alternative
{
    {
        Alternative {
            span: Span(lo, hi),
            expr: ExprSymbol { symbols: vec![] },
            condition: c,
            action: Some(a)
        }
    }
}

pub fn ___action23<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ActionKind
{
    ActionKind::Lookahead
}

pub fn ___action24<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ActionKind
{
    ActionKind::Lookbehind
}

pub fn ___action25<
    'input,
>(
    text: &'input str,
    c: &'input str,
) -> ActionKind
{
    ActionKind::User(strip(c).to_string())
}

pub fn ___action26<
    'input,
>(
    text: &'input str,
    c: &'input str,
) -> ActionKind
{
    ActionKind::Fallible(strip(c).to_string())
}

pub fn ___action27<
    'input,
>(
    text: &'input str,
    lo: usize,
    a: NonterminalString,
    op: ConditionOp,
    b: InternedString,
    hi: usize,
) -> Condition
{
    {
        Condition { span:Span(lo, hi), lhs:a, rhs:b, op:op }
    }
}

pub fn ___action28<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::Equals
}

pub fn ___action29<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::NotEquals
}

pub fn ___action30<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::Match
}

pub fn ___action31<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::NotMatch
}

pub fn ___action32<
    'input,
>(
    text: &'input str,
    ___0: ::std::vec::Vec<Symbol>,
) -> ExprSymbol
{
    ExprSymbol { symbols: ___0 }
}

pub fn ___action33<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    _: usize,
    l: InternedString,
    _: Tok<'input>,
    s: Symbol,
    _: Tok<'input>,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), SymbolKind::Name(l, Box::new(s)))
}

pub fn ___action34<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    s: Symbol,
    _: Tok<'input>,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), SymbolKind::Choose(Box::new(s)))
}

pub fn ___action35<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
) -> Symbol
{
    (___0)
}

pub fn ___action36<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
) -> Symbol
{
    (___0)
}

pub fn ___action37<
    'input,
>(
    text: &'input str,
    lhs: Symbol,
    op: RepeatOp,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lhs.span.0, hi),
                    SymbolKind::Repeat(Box::new(RepeatSymbol { symbol: lhs, op: op })))
}

pub fn ___action38<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Plus
}

pub fn ___action39<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Star
}

pub fn ___action40<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Question
}

pub fn ___action41<
    'input,
>(
    text: &'input str,
    lo: usize,
    sk: SymbolKind,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), sk)
}

pub fn ___action42<
    'input,
>(
    text: &'input str,
    name: NonterminalString,
    _: Tok<'input>,
    args: Vec<Symbol>,
    _: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Macro(MacroSymbol { name: name, args: args })
}

pub fn ___action43<
    'input,
>(
    text: &'input str,
    ___0: TerminalString,
) -> SymbolKind
{
    SymbolKind::Terminal(___0)
}

pub fn ___action44<
    'input,
>(
    text: &'input str,
    ___0: &'input str,
) -> SymbolKind
{
    SymbolKind::AmbiguousId(intern(___0))
}

pub fn ___action45<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
) -> SymbolKind
{
    SymbolKind::Nonterminal(NonterminalString(___0))
}

pub fn ___action46<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: ExprSymbol,
    _: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Expr(___0)
}

pub fn ___action47<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Lookahead
}

pub fn ___action48<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Lookbehind
}

pub fn ___action49<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<TypeRef>,
    _: Tok<'input>,
) -> TypeRef
{
    TypeRef::Tuple(___0)
}

pub fn ___action50<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Symbol,
    _: Tok<'input>,
) -> TypeRef
{
    {
        TypeRef::OfSymbol(___0.kind)
    }
}

pub fn ___action51<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    l: ::std::option::Option<InternedString>,
    m: ::std::option::Option<Tok<'input>>,
    t: TypeRef,
) -> TypeRef
{
    TypeRef::Ref { lifetime: l,
                       mutable: m.is_some(),
                       referent: Box::new(t) }
}

pub fn ___action52<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a: Vec<TypeRef>,
    _: Tok<'input>,
) -> TypeRef
{
    TypeRef::Nominal { path: p, types: a }
}

pub fn ___action53<
    'input,
>(
    text: &'input str,
    p: Path,
) -> TypeRef
{
    match p.as_id() {
            Some(id) => TypeRef::Id(id),
            None => TypeRef::Nominal { path: p, types: vec![] }
        }
}

pub fn ___action54<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
) -> TypeRef
{
    (___0)
}

pub fn ___action55<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
) -> TypeRef
{
    TypeRef::Lifetime(___0)
}

pub fn ___action56<
    'input,
>(
    text: &'input str,
    a: ::std::option::Option<Tok<'input>>,
    h: ::std::vec::Vec<InternedString>,
    t: InternedString,
) -> Path
{
    {
        Path { absolute: a.is_some(),
               ids: h.into_iter().chain(once(t)).collect() }
    }
}

pub fn ___action57<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    hi: usize,
    _: Tok<'input>,
    a0: ::std::vec::Vec<AssociatedType>,
    et: EnumToken,
    a1: ::std::vec::Vec<AssociatedType>,
    _: Tok<'input>,
) -> GrammarItem
{
    {
        GrammarItem::ExternToken(ExternToken {
            span: Span(lo, hi),
            associated_types: a0.into_iter().chain(a1).collect(),
            enum_token: Some(et),
        })
    }
}

pub fn ___action58<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    hi: usize,
    _: Tok<'input>,
    a0: ::std::vec::Vec<AssociatedType>,
    _: Tok<'input>,
) -> GrammarItem
{
    {
        GrammarItem::ExternToken(ExternToken {
            span: Span(lo, hi),
            associated_types: a0,
            enum_token: None,
        })
    }
}

pub fn ___action59<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    lo: usize,
    t: TypeRef,
    hi: usize,
    _: Tok<'input>,
    c: Vec<Conversion>,
    _: Tok<'input>,
) -> EnumToken
{
    {
        EnumToken {
            type_name: t,
            type_span: Span(lo, hi),
            conversions: c,
        }
    }
}

pub fn ___action60<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    lo: usize,
    n: InternedString,
    hi: usize,
    _: Tok<'input>,
    t: TypeRef,
    _: Tok<'input>,
) -> AssociatedType
{
    {
        AssociatedType { type_span: Span(lo, hi),
                         type_name: n,
                         type_ref: t }
    }
}

pub fn ___action61<
    'input,
>(
    text: &'input str,
    lo: usize,
    from: TerminalString,
    start: usize,
    p: &'input str,
    hi: usize,
) -> Result<Conversion,___ParseError<usize,Tok<'input>,tok::Error>>
{
    {
        let pattern = try!(super::parse_pattern(p, start + 2));
        Ok(Conversion { span: Span(lo, hi),
                        from: from,
                        to: pattern })
    }
}

pub fn ___action62<
    'input,
>(
    text: &'input str,
    lo: usize,
    k: PatternKind<TypeRef>,
    hi: usize,
) -> Pattern<TypeRef>
{
    Pattern { span: Span(lo, hi), kind: k }
}

pub fn ___action63<
    'input,
>(
    text: &'input str,
    ___0: Path,
    _: Tok<'input>,
    ___1: Vec<Pattern<TypeRef>>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Enum(___0, ___1)
}

pub fn ___action64<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    a1: ::std::option::Option<FieldPattern<TypeRef>>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Struct(p, a0.into_iter().chain(a1).collect(), false)
}

pub fn ___action65<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    _: Tok<'input>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Struct(p, a0, true)
}

pub fn ___action66<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Underscore
}

pub fn ___action67<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::DotDot
}

pub fn ___action68<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: TypeRef,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Choose(___0)
}

pub fn ___action69<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Vec<Pattern<TypeRef>>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Tuple(___0)
}

pub fn ___action70<
    'input,
>(
    text: &'input str,
    ___0: Path,
) -> PatternKind<TypeRef>
{
    PatternKind::Path(___0)
}

pub fn ___action71<
    'input,
>(
    text: &'input str,
    lo: usize,
    id: InternedString,
    hi: usize,
    _: Tok<'input>,
    pat: Pattern<TypeRef>,
) -> FieldPattern<TypeRef>
{
    {
        FieldPattern { field_span: Span(lo, hi),
                       field_name: id,
                       pattern: pat }
    }
}

pub fn ___action72<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> NonterminalString
{
    NonterminalString(intern(i))
}

pub fn ___action73<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> NonterminalString
{
    NonterminalString(intern(i))
}

pub fn ___action74<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn ___action75<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn ___action76<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn ___action77<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn ___action78<
    'input,
>(
    text: &'input str,
    ___0: TerminalString,
) -> TerminalString
{
    (___0)
}

pub fn ___action79<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> TerminalString
{
    TerminalString::Bare(intern(i))
}

pub fn ___action80<
    'input,
>(
    text: &'input str,
    s: InternedString,
) -> TerminalString
{
    TerminalString::quoted(s)
}

pub fn ___action81<
    'input,
>(
    text: &'input str,
    s: InternedString,
) -> TerminalString
{
    TerminalString::regex(s)
}

pub fn ___action82<
    'input,
>(
    text: &'input str,
    s: &'input str,
) -> InternedString
{
    intern(s)
}

pub fn ___action83<
    'input,
>(
    text: &'input str,
    s: &'input str,
) -> InternedString
{
    intern(s)
}

pub fn ___action84<
    'input,
>(
    text: &'input str,
    ___0: FieldPattern<TypeRef>,
) -> ::std::option::Option<FieldPattern<TypeRef>>
{
    Some(___0)
}

pub fn ___action85<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<FieldPattern<TypeRef>>
{
    None
}

pub fn ___action86<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    vec![]
}

pub fn ___action87<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<FieldPattern<TypeRef>>,
    e: FieldPattern<TypeRef>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action88<
    'input,
>(
    text: &'input str,
    ___0: FieldPattern<TypeRef>,
    _: Tok<'input>,
) -> FieldPattern<TypeRef>
{
    (___0)
}

pub fn ___action89<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Pattern<TypeRef>>,
    e1: ::std::option::Option<Pattern<TypeRef>>,
) -> Vec<Pattern<TypeRef>>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action90<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Conversion>,
    e1: ::std::option::Option<Conversion>,
) -> Vec<Conversion>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action91<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<AssociatedType>
{
    vec![]
}

pub fn ___action92<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<AssociatedType>,
    e: AssociatedType,
) -> ::std::vec::Vec<AssociatedType>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action93<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<InternedString>
{
    vec![]
}

pub fn ___action94<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<InternedString>,
    e: InternedString,
) -> ::std::vec::Vec<InternedString>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action95<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
    _: Tok<'input>,
) -> InternedString
{
    (___0)
}

pub fn ___action96<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(___0)
}

pub fn ___action97<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn ___action98<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeRef>,
    e1: ::std::option::Option<TypeRef>,
) -> Vec<TypeRef>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action99<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(___0)
}

pub fn ___action100<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn ___action101<
    'input,
>(
    text: &'input str,
    ___0: InternedString,
) -> ::std::option::Option<InternedString>
{
    Some(___0)
}

pub fn ___action102<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<InternedString>
{
    None
}

pub fn ___action103<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeRef>,
    e1: ::std::option::Option<TypeRef>,
) -> Vec<TypeRef>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action104<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Symbol>,
    e1: ::std::option::Option<Symbol>,
) -> Vec<Symbol>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action105<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Symbol>
{
    vec![]
}

pub fn ___action106<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action107<
    'input,
>(
    text: &'input str,
    ___0: ActionKind,
) -> ::std::option::Option<ActionKind>
{
    Some(___0)
}

pub fn ___action108<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<ActionKind>
{
    None
}

pub fn ___action109<
    'input,
>(
    text: &'input str,
    ___0: Condition,
) -> ::std::option::Option<Condition>
{
    Some(___0)
}

pub fn ___action110<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Condition>
{
    None
}

pub fn ___action111<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: Condition,
) -> Condition
{
    (___0)
}

pub fn ___action112<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    vec![___0]
}

pub fn ___action113<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action114<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Alternative>,
    e1: ::std::option::Option<Alternative>,
) -> Vec<Alternative>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action115<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<NonterminalString>,
    e1: ::std::option::Option<NonterminalString>,
) -> Vec<NonterminalString>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action116<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(___0)
}

pub fn ___action117<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn ___action118<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    ___0: TypeRef,
) -> TypeRef
{
    (___0)
}

pub fn ___action119<
    'input,
>(
    text: &'input str,
    ___0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(___0)
}

pub fn ___action120<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn ___action121<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Annotation>
{
    vec![]
}

pub fn ___action122<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Annotation>,
    e: Annotation,
) -> ::std::vec::Vec<Annotation>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action123<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Parameter>,
    e1: ::std::option::Option<Parameter>,
) -> Vec<Parameter>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action124<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeParameter>,
    e1: ::std::option::Option<TypeParameter>,
) -> Vec<TypeParameter>
{
    v0.into_iter().chain(e1).collect()
}

pub fn ___action125<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![]
}

pub fn ___action126<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    e: GrammarItem,
) -> ::std::vec::Vec<GrammarItem>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action127<
    'input,
>(
    text: &'input str,
    ___0: Algorithm,
) -> ::std::option::Option<Algorithm>
{
    Some(___0)
}

pub fn ___action128<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Algorithm>
{
    None
}

pub fn ___action129<
    'input,
>(
    text: &'input str,
    ___0: Vec<&'input str>,
) -> ::std::option::Option<Vec<&'input str>>
{
    Some(___0)
}

pub fn ___action130<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Vec<&'input str>>
{
    None
}

pub fn ___action131<
    'input,
>(
    text: &'input str,
    ___0: Vec<Parameter>,
) -> ::std::option::Option<Vec<Parameter>>
{
    Some(___0)
}

pub fn ___action132<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Vec<Parameter>>
{
    None
}

pub fn ___action133<
    'input,
>(
    text: &'input str,
    ___0: Vec<TypeParameter>,
) -> ::std::option::Option<Vec<TypeParameter>>
{
    Some(___0)
}

pub fn ___action134<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Vec<TypeParameter>>
{
    None
}

pub fn ___action135<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![]
}

pub fn ___action136<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    e: GrammarItem,
) -> ::std::vec::Vec<GrammarItem>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action137<
    'input,
>(
    text: &'input str,
    ___0: TypeParameter,
) -> ::std::option::Option<TypeParameter>
{
    Some(___0)
}

pub fn ___action138<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeParameter>
{
    None
}

pub fn ___action139<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeParameter>
{
    vec![]
}

pub fn ___action140<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeParameter>,
    e: TypeParameter,
) -> ::std::vec::Vec<TypeParameter>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action141<
    'input,
>(
    text: &'input str,
    ___0: TypeParameter,
    _: Tok<'input>,
) -> TypeParameter
{
    (___0)
}

pub fn ___action142<
    'input,
>(
    text: &'input str,
    ___0: Parameter,
) -> ::std::option::Option<Parameter>
{
    Some(___0)
}

pub fn ___action143<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Parameter>
{
    None
}

pub fn ___action144<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Parameter>
{
    vec![]
}

pub fn ___action145<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Parameter>,
    e: Parameter,
) -> ::std::vec::Vec<Parameter>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action146<
    'input,
>(
    text: &'input str,
    ___0: Parameter,
    _: Tok<'input>,
) -> Parameter
{
    (___0)
}

pub fn ___action147<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
) -> ::std::option::Option<NonterminalString>
{
    Some(___0)
}

pub fn ___action148<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<NonterminalString>
{
    None
}

pub fn ___action149<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<NonterminalString>
{
    vec![]
}

pub fn ___action150<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<NonterminalString>,
    e: NonterminalString,
) -> ::std::vec::Vec<NonterminalString>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action151<
    'input,
>(
    text: &'input str,
    ___0: NonterminalString,
    _: Tok<'input>,
) -> NonterminalString
{
    (___0)
}

pub fn ___action152<
    'input,
>(
    text: &'input str,
    ___0: Alternative,
) -> ::std::option::Option<Alternative>
{
    Some(___0)
}

pub fn ___action153<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Alternative>
{
    None
}

pub fn ___action154<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Alternative>
{
    vec![]
}

pub fn ___action155<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Alternative>,
    e: Alternative,
) -> ::std::vec::Vec<Alternative>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action156<
    'input,
>(
    text: &'input str,
    ___0: Alternative,
    _: Tok<'input>,
) -> Alternative
{
    (___0)
}

pub fn ___action157<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
) -> ::std::option::Option<Symbol>
{
    Some(___0)
}

pub fn ___action158<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Symbol>
{
    None
}

pub fn ___action159<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Symbol>
{
    vec![]
}

pub fn ___action160<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action161<
    'input,
>(
    text: &'input str,
    ___0: Symbol,
    _: Tok<'input>,
) -> Symbol
{
    (___0)
}

pub fn ___action162<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(___0)
}

pub fn ___action163<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn ___action164<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeRef>
{
    vec![]
}

pub fn ___action165<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    e: TypeRef,
) -> ::std::vec::Vec<TypeRef>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action166<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    _: Tok<'input>,
) -> TypeRef
{
    (___0)
}

pub fn ___action167<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(___0)
}

pub fn ___action168<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn ___action169<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeRef>
{
    vec![]
}

pub fn ___action170<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    e: TypeRef,
) -> ::std::vec::Vec<TypeRef>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action171<
    'input,
>(
    text: &'input str,
    ___0: TypeRef,
    _: Tok<'input>,
) -> TypeRef
{
    (___0)
}

pub fn ___action172<
    'input,
>(
    text: &'input str,
    ___0: Conversion,
) -> ::std::option::Option<Conversion>
{
    Some(___0)
}

pub fn ___action173<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Conversion>
{
    None
}

pub fn ___action174<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Conversion>
{
    vec![]
}

pub fn ___action175<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Conversion>,
    e: Conversion,
) -> ::std::vec::Vec<Conversion>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action176<
    'input,
>(
    text: &'input str,
    ___0: Conversion,
    _: Tok<'input>,
) -> Conversion
{
    (___0)
}

pub fn ___action177<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
) -> ::std::option::Option<Pattern<TypeRef>>
{
    Some(___0)
}

pub fn ___action178<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Pattern<TypeRef>>
{
    None
}

pub fn ___action179<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    vec![]
}

pub fn ___action180<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Pattern<TypeRef>>,
    e: Pattern<TypeRef>,
) -> ::std::vec::Vec<Pattern<TypeRef>>
{
    { let mut v = v; v.push(e); v }
}

pub fn ___action181<
    'input,
>(
    text: &'input str,
    ___0: Pattern<TypeRef>,
    _: Tok<'input>,
) -> Pattern<TypeRef>
{
    (___0)
}

pub trait ___ToTriple<'input, > {
    type Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),Self::Error>;
}

impl<'input, > ___ToTriple<'input, > for (usize, Tok<'input>, usize) {
    type Error = tok::Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),tok::Error> {
        Ok(value)
    }
}
impl<'input, > ___ToTriple<'input, > for Result<(usize, Tok<'input>, usize),tok::Error> {
    type Error = tok::Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),tok::Error> {
        value
    }
}
