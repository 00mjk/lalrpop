#![allow(unused_imports)]
#![allow(unused_variables)]
use intern::{intern, InternedString};
use grammar::parse_tree::*;
use grammar::pattern::*;
use std::iter::once;
use tok::{self, Tok};
extern crate lalrpop_util as __lalrpop_util;
use self::__lalrpop_util::ParseError as __ParseError;
#[allow(non_snake_case)]
pub fn parse_Pattern<
    'input,
    __TOKEN: __ToTriple<Error=tok::Error>,
    __TOKENS: IntoIterator<Item=__TOKEN>,
>(
    text: &'input str,
    __tokens: __TOKENS,
) -> Result<Pattern, __ParseError<usize,Tok<'input>,tok::Error>>
{
    let mut __tokens = __tokens.into_iter();
    let mut __tokens = __tokens.map(|t| __ToTriple::to_triple(t));
    let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
    match try!(__parse__Pattern::__state0(text, None, __lookahead, &mut __tokens)) {
        (_, Some(__lookahead), _) => {
            Err(__ParseError::ExtraToken { token: __lookahead })
        }
        (_, None, __parse__Pattern::__Nonterminal::____Pattern(__nt)) => {
            Ok(__nt)
        }
        _ => unreachable!(),
    }
}

mod __parse__Pattern {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    extern crate lalrpop_util as __lalrpop_util;
    use self::__lalrpop_util::ParseError as __ParseError;
    use super::__ToTriple;

    pub enum __Nonterminal<'input, > {
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        NonterminalId_3f(::std::option::Option<NonterminalString>),
        Alternative_2a(::std::vec::Vec<Alternative>),
        Comma_3cConversion_3e(Vec<Conversion>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        RepeatOp(RepeatOp),
        _40L(usize),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern>),
        ____Grammar(Grammar),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        TypeRefOrLifetime(TypeRef),
        Use_2a(::std::vec::Vec<GrammarItem>),
        Path(Path),
        Escape(InternedString),
        Id(InternedString),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        _22where_22_3f(::std::option::Option<Tok<'input>>),
        GrammarTypeParameters(Vec<TypeParameter>),
        TypeParameter(TypeParameter),
        Alternatives(Vec<Alternative>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        Grammar(Grammar),
        GrammarParameter(Parameter),
        StringLiteral(InternedString),
        Action_3f(::std::option::Option<ActionKind>),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        Symbol_2a(::std::vec::Vec<Symbol>),
        Nonterminal(GrammarItem),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        _40R(usize),
        Action(ActionKind),
        Symbol1(Symbol),
        Comma_3cPattern_3e(Vec<Pattern>),
        _28_3cNonterminalId_3e_20_22_2c_22_29(NonterminalString),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_22if_22_20_3cCond_3e_29(Condition),
        Symbol0(Symbol),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        GrammarParameter_3f(::std::option::Option<Parameter>),
        Conversion(Conversion),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        Symbol(Symbol),
        Comma_3cSymbol_3e(Vec<Symbol>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        Terminal(TerminalString),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        GrammarParameters(Vec<Parameter>),
        Conversion_3f(::std::option::Option<Conversion>),
        Cond(Condition),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        Lifetime_3f(::std::option::Option<InternedString>),
        ____Pattern(Pattern),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        SymbolKind1(SymbolKind),
        _28_3cNonterminalId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        AssociatedType(AssociatedType),
        Symbol_3f(::std::option::Option<Symbol>),
        FieldPattern(FieldPattern<TypeRef>),
        PatternKind(PatternKind<TypeRef>),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        ExternToken(GrammarItem),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        CondOp(ConditionOp),
        TypeRef(TypeRef),
        Use(GrammarItem),
        Pattern_3f(::std::option::Option<Pattern>),
        GrammarItem(GrammarItem),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        NonterminalId(NonterminalString),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        Lifetime(InternedString),
        Comma_3cNonterminalId_3e(Vec<NonterminalString>),
        TypeRef_3f(::std::option::Option<TypeRef>),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        Pattern(Pattern),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        MacroId(NonterminalString),
        Alternative(Alternative),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
    }

    // State 0
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["_"]
    //   Pattern = (*) @L PatternKind @R [EOF]
    //   __Pattern = (*) Pattern [EOF]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "_" -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   ".." -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S1
    //   Pattern -> S2
    pub fn __state0<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Underscore(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state1(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                __Nonterminal::Pattern(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
    }

    // State 1
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Path = (*) "::"? (<Id> "::")* Id [EOF]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Pattern = @L (*) PatternKind @R [EOF]
    //   PatternKind = (*) Path [EOF]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [EOF]
    //   PatternKind = (*) "(" Comma<TypeRef> ")" [EOF]
    //   PatternKind = (*) ".." [EOF]
    //   PatternKind = (*) "<" TypeRef ">" [EOF]
    //   PatternKind = (*) "_" [EOF]
    //
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "_" -> Shift(S9)
    //   "<" -> Shift(S5)
    //   ".." -> Shift(S3)
    //   "::" -> Shift(S7)
    //   "(" -> Shift(S10)
    //
    //   "::"? -> S8
    //   PatternKind -> S4
    //   Path -> S6
    pub fn __state1<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Underscore(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state9(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::DotDot(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state10(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state8(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::PatternKind(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state6(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 2
    //   __Pattern = Pattern (*) [EOF]
    //
    //   EOF -> Reduce(__Pattern = Pattern => Call(ActionFn(1));)
    //
    pub fn __state2<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Pattern>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action1(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::____Pattern(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 3
    //   PatternKind = ".." (*) [EOF]
    //
    //   EOF -> Reduce(PatternKind = ".." => Call(ActionFn(60));)
    //
    pub fn __state3<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action60(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 4
    //   @R = (*) [EOF]
    //   Pattern = @L PatternKind (*) @R [EOF]
    //
    //   EOF -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S11
    pub fn __state4<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<PatternKind<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state11(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 5
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [EOF]
    //   TypeRef = (*) Escape [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "(" -> Shift(S14)
    //   "&" -> Shift(S16)
    //   "Escape" -> Shift(S18)
    //   "::" -> Shift(S7)
    //
    //   Path -> S15
    //   TypeRef -> S12
    //   Escape -> S17
    //   "::"? -> S13
    pub fn __state5<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state12(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 6
    //   PatternKind = Path (*) [EOF]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [EOF]
    //
    //   EOF -> Reduce(PatternKind = Path => Call(ActionFn(63));)
    //   "(" -> Shift(S19)
    //   "{" -> Shift(S20)
    //
    pub fn __state6<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state19(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state20(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action63(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 7
    //   "::"? = "::" (*) ["Id"]
    //
    //   "Id" -> Reduce("::"? = "::" => Call(ActionFn(84));)
    //
    pub fn __state7<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action84(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 8
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id [EOF]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S21
    pub fn __state8<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state21(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 9
    //   PatternKind = "_" (*) [EOF]
    //
    //   EOF -> Reduce(PatternKind = "_" => Call(ActionFn(59));)
    //
    pub fn __state9<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action59(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 10
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   PatternKind = "(" (*) Comma<TypeRef> ")" [EOF]
    //
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   (<TypeRef> ",")* -> S23
    //   Comma<TypeRef> -> S22
    pub fn __state10<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state22(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 11
    //   Pattern = @L PatternKind @R (*) [EOF]
    //
    //   EOF -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(55));)
    //
    pub fn __state11<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<PatternKind<TypeRef>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action55(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Pattern(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 12
    //   PatternKind = "<" TypeRef (*) ">" [EOF]
    //
    //   ">" -> Shift(S24)
    //
    pub fn __state12<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state24(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 13
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S25
    pub fn __state13<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state25(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 14
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   Comma<TypeRef> -> S26
    //   (<TypeRef> ",")* -> S23
    pub fn __state14<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state26(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 15
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "<" -> Shift(S27)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //
    pub fn __state15<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state27(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 16
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Escape"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Escape"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Escape"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //
    //   "Lifetime" -> Shift(S29)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Escape" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //
    //   Lifetime? -> S28
    //   Lifetime -> S30
    pub fn __state16<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state28(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 17
    //   TypeRef = Escape (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //
    pub fn __state17<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 18
    //   Escape = "Escape" (*) [">"]
    //
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state18<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 19
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [EOF]
    //
    //   ")" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "Id" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "::" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   ".." -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "(" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "<" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "_" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //
    //   (<Pattern> ",")* -> S32
    //   Comma<Pattern> -> S31
    pub fn __state19<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Underscore(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cPattern_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state31(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 20
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [EOF]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [EOF]
    //
    //   "}" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //   ".." -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //   "Id" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //
    //   (<FieldPattern> ",")* -> S33
    pub fn __state20<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state33(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 21
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" [EOF]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id [EOF]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //
    //   "Id" -> Shift(S36)
    //
    //   Id -> S35
    //   (<Id> "::") -> S34
    pub fn __state21<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state36(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 22
    //   PatternKind = "(" Comma<TypeRef> (*) ")" [EOF]
    //
    //   ")" -> Shift(S37)
    //
    pub fn __state22<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 23
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["("]
    //   (<TypeRef> ",") = (*) TypeRef "," [")"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Escape"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (<TypeRef> ",")* (*) TypeRef? [")"]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" [","]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Escape [")"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef? = (*) [")"]
    //   TypeRef? = (*) TypeRef [")"]
    //
    //   "(" -> Shift(S39)
    //   "&" -> Shift(S46)
    //   ")" -> Reduce(TypeRef? =  => Call(ActionFn(141));)
    //   "::" -> Shift(S7)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "Escape" -> Shift(S40)
    //
    //   TypeRef? -> S38
    //   Path -> S45
    //   TypeRef -> S41
    //   "::"? -> S44
    //   Escape -> S43
    //   (<TypeRef> ",") -> S42
    pub fn __state23<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action141(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRef_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state42(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 24
    //   PatternKind = "<" TypeRef ">" (*) [EOF]
    //
    //   EOF -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(61));)
    //
    pub fn __state24<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action61(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 25
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //
    //   "Id" -> Shift(S47)
    //
    //   (<Id> "::") -> S34
    //   Id -> S48
    pub fn __state25<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 26
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S49)
    //
    pub fn __state26<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 27
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //
    //   Comma<TypeRefOrLifetime> -> S51
    //   (<TypeRefOrLifetime> ",")* -> S50
    pub fn __state27<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state51(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 28
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Escape"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Escape"]
    //   "mut"? = (*) "mut" ["Id"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "mut" -> Shift(S53)
    //   "Escape" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //
    //   "mut"? -> S52
    pub fn __state28<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 29
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Escape"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //
    //   "Escape" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "&" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "::" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "(" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //
    pub fn __state29<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 30
    //   Lifetime? = Lifetime (*) ["&"]
    //   Lifetime? = Lifetime (*) ["("]
    //   Lifetime? = Lifetime (*) ["::"]
    //   Lifetime? = Lifetime (*) ["Escape"]
    //   Lifetime? = Lifetime (*) ["Id"]
    //   Lifetime? = Lifetime (*) ["mut"]
    //
    //   "Escape" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "(" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "Id" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "::" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "&" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "mut" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //
    pub fn __state30<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 31
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [EOF]
    //
    //   ")" -> Shift(S54)
    //
    pub fn __state31<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Pattern>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state54(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 32
    //   (<Pattern> ",") = (*) Pattern "," ["("]
    //   (<Pattern> ",") = (*) Pattern "," [")"]
    //   (<Pattern> ",") = (*) Pattern "," [".."]
    //   (<Pattern> ",") = (*) Pattern "," ["::"]
    //   (<Pattern> ",") = (*) Pattern "," ["<"]
    //   (<Pattern> ",") = (*) Pattern "," ["Id"]
    //   (<Pattern> ",") = (*) Pattern "," ["_"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (*) (<Pattern> ",") ["_"]
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["_"]
    //   Comma<Pattern> = (<Pattern> ",")* (*) Pattern? [")"]
    //   Pattern = (*) @L PatternKind @R [")"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   Pattern? = (*) [")"]
    //   Pattern? = (*) Pattern [")"]
    //
    //   ".." -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "_" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Reduce(Pattern? =  => Call(ActionFn(156));)
    //
    //   Pattern? -> S55
    //   Pattern -> S56
    //   (<Pattern> ",") -> S58
    //   @L -> S57
    pub fn __state32<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Pattern>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Underscore(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action156(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Pattern_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Pattern_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state55(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Pattern(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 33
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [EOF]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [EOF]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "}" -> Reduce(FieldPattern? =  => Call(ActionFn(73));)
    //   ".." -> Shift(S63)
    //
    //   FieldPattern? -> S61
    //   @L -> S60
    //   FieldPattern -> S62
    //   (<FieldPattern> ",") -> S59
    pub fn __state33<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::DotDot(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state63(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action73(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::FieldPattern_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::FieldPattern_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state61(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::FieldPattern(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 34
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["Id"]
    //
    //   "Id" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(82));)
    //
    pub fn __state34<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<InternedString>>,
        __sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action82(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 35
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) [EOF]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //
    //   "(" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S64)
    //   "{" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   EOF -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state35<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 36
    //   Id = "Id" (*) [EOF]
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   EOF -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "{" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "(" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state36<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 37
    //   PatternKind = "(" Comma<TypeRef> ")" (*) [EOF]
    //
    //   EOF -> Reduce(PatternKind = "(", Comma<TypeRef>, ")" => Call(ActionFn(62));)
    //
    pub fn __state37<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action62(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 38
    //   Comma<TypeRef> = (<TypeRef> ",")* TypeRef? (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")*, TypeRef? => Call(ActionFn(91));)
    //
    pub fn __state38<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action91(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRef_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 39
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   Comma<TypeRef> -> S65
    //   (<TypeRef> ",")* -> S23
    pub fn __state39<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 40
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) [","]
    //
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state40<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 41
    //   (<TypeRef> ",") = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["("]
    //   (<TypeRef> ",") = TypeRef (*) "," [")"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Escape"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Id"]
    //   TypeRef? = TypeRef (*) [")"]
    //
    //   "," -> Shift(S66)
    //   ")" -> Reduce(TypeRef? = TypeRef => Call(ActionFn(140));)
    //
    pub fn __state41<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state66(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action140(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 42
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Escape"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Id"]
    //
    //   "&" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "::" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "Id" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   ")" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "Escape" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "(" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //
    pub fn __state42<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 43
    //   TypeRef = Escape (*) [")"]
    //   TypeRef = Escape (*) [","]
    //
    //   ")" -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //   "," -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //
    pub fn __state43<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 44
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S67
    pub fn __state44<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state67(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 45
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //
    //   "<" -> Shift(S68)
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //   ")" -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //
    pub fn __state45<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state68(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 46
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Escape"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Escape"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Escape"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Lifetime" -> Shift(S29)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Escape" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //
    //   Lifetime -> S30
    //   Lifetime? -> S69
    pub fn __state46<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state69(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 47
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state47<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 48
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S64)
    //
    pub fn __state48<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 49
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //
    pub fn __state49<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 50
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Escape"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* (*) TypeRefOrLifetime? [">"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Escape [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   TypeRefOrLifetime? = (*) [">"]
    //   TypeRefOrLifetime? = (*) TypeRefOrLifetime [">"]
    //
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "&" -> Shift(S72)
    //   ">" -> Reduce(TypeRefOrLifetime? =  => Call(ActionFn(146));)
    //   "Lifetime" -> Shift(S79)
    //   "(" -> Shift(S80)
    //   "::" -> Shift(S7)
    //   "Escape" -> Shift(S76)
    //
    //   TypeRef -> S75
    //   (<TypeRefOrLifetime> ",") -> S77
    //   Path -> S78
    //   Lifetime -> S81
    //   TypeRefOrLifetime? -> S73
    //   Escape -> S70
    //   TypeRefOrLifetime -> S74
    //   "::"? -> S71
    pub fn __state50<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state72(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state79(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state80(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state76(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action146(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state75(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state77(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state81(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRefOrLifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state73(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRefOrLifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state71(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 51
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S82)
    //
    pub fn __state51<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state82(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 52
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Escape [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "::" -> Shift(S7)
    //   "&" -> Shift(S16)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "(" -> Shift(S14)
    //   "Escape" -> Shift(S18)
    //
    //   "::"? -> S13
    //   Escape -> S17
    //   TypeRef -> S83
    //   Path -> S15
    pub fn __state52<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state83(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 53
    //   "mut"? = "mut" (*) ["&"]
    //   "mut"? = "mut" (*) ["("]
    //   "mut"? = "mut" (*) ["::"]
    //   "mut"? = "mut" (*) ["Escape"]
    //   "mut"? = "mut" (*) ["Id"]
    //
    //   "::" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //   "Id" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //   "Escape" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //   "&" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //   "(" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //
    pub fn __state53<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 54
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [EOF]
    //
    //   EOF -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(56));)
    //
    pub fn __state54<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Pattern>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action56(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 55
    //   Comma<Pattern> = (<Pattern> ",")* Pattern? (*) [")"]
    //
    //   ")" -> Reduce(Comma<Pattern> = (<Pattern> ",")*, Pattern? => Call(ActionFn(77));)
    //
    pub fn __state55<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Pattern>>,
        __sym1: &mut Option<::std::option::Option<Pattern>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action77(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cPattern_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 56
    //   (<Pattern> ",") = Pattern (*) "," ["("]
    //   (<Pattern> ",") = Pattern (*) "," [")"]
    //   (<Pattern> ",") = Pattern (*) "," [".."]
    //   (<Pattern> ",") = Pattern (*) "," ["::"]
    //   (<Pattern> ",") = Pattern (*) "," ["<"]
    //   (<Pattern> ",") = Pattern (*) "," ["Id"]
    //   (<Pattern> ",") = Pattern (*) "," ["_"]
    //   Pattern? = Pattern (*) [")"]
    //
    //   ")" -> Reduce(Pattern? = Pattern => Call(ActionFn(155));)
    //   "," -> Shift(S84)
    //
    pub fn __state56<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Pattern>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state84(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action155(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Pattern_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 57
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Pattern = @L (*) PatternKind @R [")"]
    //   Pattern = @L (*) PatternKind @R [","]
    //   PatternKind = (*) Path [")"]
    //   PatternKind = (*) Path [","]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [")"]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = (*) "(" Comma<TypeRef> ")" [")"]
    //   PatternKind = (*) "(" Comma<TypeRef> ")" [","]
    //   PatternKind = (*) ".." [")"]
    //   PatternKind = (*) ".." [","]
    //   PatternKind = (*) "<" TypeRef ">" [")"]
    //   PatternKind = (*) "<" TypeRef ">" [","]
    //   PatternKind = (*) "_" [")"]
    //   PatternKind = (*) "_" [","]
    //
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "(" -> Shift(S89)
    //   "<" -> Shift(S86)
    //   "::" -> Shift(S7)
    //   "_" -> Shift(S90)
    //   ".." -> Shift(S87)
    //
    //   Path -> S88
    //   "::"? -> S85
    //   PatternKind -> S91
    pub fn __state57<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state89(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state86(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Underscore(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state90(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::DotDot(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state87(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state88(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state85(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::PatternKind(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state91(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 58
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["("]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) [")"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) [".."]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["::"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["<"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["Id"]
    //   (<Pattern> ",")* = (<Pattern> ",")* (<Pattern> ",") (*) ["_"]
    //
    //   "Id" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(158));)
    //   "::" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(158));)
    //   "_" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(158));)
    //   ".." -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(158));)
    //   "(" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(158));)
    //   "<" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(158));)
    //   ")" -> Reduce((<Pattern> ",")* = (<Pattern> ",")*, (<Pattern> ",") => Call(ActionFn(158));)
    //
    pub fn __state58<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Pattern>>,
        __sym1: &mut Option<Pattern>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action158(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action158(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Underscore(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action158(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action158(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action158(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action158(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action158(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 59
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (<FieldPattern> ",") (*) ["}"]
    //
    //   "}" -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(75));)
    //   ".." -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(75));)
    //   "Id" -> Reduce((<FieldPattern> ",")* = (<FieldPattern> ",")*, (<FieldPattern> ",") => Call(ActionFn(75));)
    //
    pub fn __state59<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym1: &mut Option<FieldPattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action75(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action75(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action75(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 60
    //   FieldPattern = @L (*) Id @R ":" Pattern [","]
    //   FieldPattern = @L (*) Id @R ":" Pattern ["}"]
    //   Id = (*) "Id" [":"]
    //
    //   "Id" -> Shift(S93)
    //
    //   Id -> S92
    pub fn __state60<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state93(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state92(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 61
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [EOF]
    //
    //   "}" -> Shift(S94)
    //
    pub fn __state61<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state94(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 62
    //   (<FieldPattern> ",") = FieldPattern (*) "," [".."]
    //   (<FieldPattern> ",") = FieldPattern (*) "," ["Id"]
    //   (<FieldPattern> ",") = FieldPattern (*) "," ["}"]
    //   FieldPattern? = FieldPattern (*) ["}"]
    //
    //   "," -> Shift(S95)
    //   "}" -> Reduce(FieldPattern? = FieldPattern => Call(ActionFn(72));)
    //
    pub fn __state62<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<FieldPattern<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state95(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action72(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::FieldPattern_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 63
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [EOF]
    //
    //   "}" -> Shift(S96)
    //
    pub fn __state63<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state96(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 64
    //   (<Id> "::") = Id "::" (*) ["Id"]
    //
    //   "Id" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(83));)
    //
    pub fn __state64<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action83(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 65
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //
    //   ")" -> Shift(S97)
    //
    pub fn __state65<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state97(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 66
    //   (<TypeRef> ",") = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["("]
    //   (<TypeRef> ",") = TypeRef "," (*) [")"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Escape"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Id"]
    //
    //   "Escape" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   ")" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   "Id" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   "&" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   "::" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   "(" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //
    pub fn __state66<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 67
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //
    //   "Id" -> Shift(S98)
    //
    //   (<Id> "::") -> S34
    //   Id -> S99
    pub fn __state67<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state98(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state99(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 68
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S50
    //   Comma<TypeRefOrLifetime> -> S100
    pub fn __state68<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state100(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 69
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Escape"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Escape"]
    //   "mut"? = (*) "mut" ["Id"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [")"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "mut" -> Shift(S53)
    //   "Escape" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //
    //   "mut"? -> S101
    pub fn __state69<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state101(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 70
    //   TypeRef = Escape (*) [","]
    //   TypeRef = Escape (*) [">"]
    //
    //   "," -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //   ">" -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //
    pub fn __state70<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 71
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S102
    pub fn __state71<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state102(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 72
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Escape"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Escape"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Escape"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //
    //   "Lifetime" -> Shift(S29)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Escape" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //
    //   Lifetime? -> S103
    //   Lifetime -> S30
    pub fn __state72<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state103(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 73
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")*, TypeRefOrLifetime? => Call(ActionFn(86));)
    //
    pub fn __state73<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action86(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 74
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Escape"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   TypeRefOrLifetime? = TypeRefOrLifetime (*) [">"]
    //
    //   ">" -> Reduce(TypeRefOrLifetime? = TypeRefOrLifetime => Call(ActionFn(145));)
    //   "," -> Shift(S104)
    //
    pub fn __state74<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state104(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action145(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 75
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(49));)
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(49));)
    //
    pub fn __state75<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action49(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action49(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 76
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state76<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 77
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Lifetime"]
    //
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //
    pub fn __state77<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 78
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //   "<" -> Shift(S105)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //
    pub fn __state78<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state105(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 79
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //
    //   ">" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "," -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //
    pub fn __state79<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 80
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   (<TypeRef> ",")* -> S23
    //   Comma<TypeRef> -> S106
    pub fn __state80<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state106(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 81
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(50));)
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(50));)
    //
    pub fn __state81<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action50(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action50(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 82
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //
    pub fn __state82<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 83
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //
    pub fn __state83<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 84
    //   (<Pattern> ",") = Pattern "," (*) ["("]
    //   (<Pattern> ",") = Pattern "," (*) [")"]
    //   (<Pattern> ",") = Pattern "," (*) [".."]
    //   (<Pattern> ",") = Pattern "," (*) ["::"]
    //   (<Pattern> ",") = Pattern "," (*) ["<"]
    //   (<Pattern> ",") = Pattern "," (*) ["Id"]
    //   (<Pattern> ",") = Pattern "," (*) ["_"]
    //
    //   ")" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(159));)
    //   "(" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(159));)
    //   "_" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(159));)
    //   "::" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(159));)
    //   "Id" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(159));)
    //   ".." -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(159));)
    //   "<" -> Reduce((<Pattern> ",") = Pattern, "," => Call(ActionFn(159));)
    //
    pub fn __state84<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Pattern>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Underscore(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action159(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 85
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S107
    pub fn __state85<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state107(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 86
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [")"]
    //   PatternKind = "<" (*) TypeRef ">" [","]
    //   TypeRef = (*) Escape [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "Escape" -> Shift(S18)
    //   "::" -> Shift(S7)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "(" -> Shift(S14)
    //   "&" -> Shift(S16)
    //
    //   "::"? -> S13
    //   Escape -> S17
    //   Path -> S15
    //   TypeRef -> S108
    pub fn __state86<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state108(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 87
    //   PatternKind = ".." (*) [")"]
    //   PatternKind = ".." (*) [","]
    //
    //   ")" -> Reduce(PatternKind = ".." => Call(ActionFn(60));)
    //   "," -> Reduce(PatternKind = ".." => Call(ActionFn(60));)
    //
    pub fn __state87<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action60(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action60(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 88
    //   PatternKind = Path (*) [")"]
    //   PatternKind = Path (*) [","]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [")"]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [","]
    //
    //   ")" -> Reduce(PatternKind = Path => Call(ActionFn(63));)
    //   "{" -> Shift(S110)
    //   "(" -> Shift(S109)
    //   "," -> Reduce(PatternKind = Path => Call(ActionFn(63));)
    //
    pub fn __state88<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state110(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state109(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action63(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action63(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 89
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   PatternKind = "(" (*) Comma<TypeRef> ")" [")"]
    //   PatternKind = "(" (*) Comma<TypeRef> ")" [","]
    //
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   (<TypeRef> ",")* -> S23
    //   Comma<TypeRef> -> S111
    pub fn __state89<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state111(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 90
    //   PatternKind = "_" (*) [")"]
    //   PatternKind = "_" (*) [","]
    //
    //   "," -> Reduce(PatternKind = "_" => Call(ActionFn(59));)
    //   ")" -> Reduce(PatternKind = "_" => Call(ActionFn(59));)
    //
    pub fn __state90<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action59(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action59(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 91
    //   @R = (*) [")"]
    //   @R = (*) [","]
    //   Pattern = @L PatternKind (*) @R [")"]
    //   Pattern = @L PatternKind (*) @R [","]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S112
    pub fn __state91<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<PatternKind<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state112(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 92
    //   @R = (*) [":"]
    //   FieldPattern = @L Id (*) @R ":" Pattern [","]
    //   FieldPattern = @L Id (*) @R ":" Pattern ["}"]
    //
    //   ":" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S113
    pub fn __state92<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state113(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 93
    //   Id = "Id" (*) [":"]
    //
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state93<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 94
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [EOF]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(57));)
    //
    pub fn __state94<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action57(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 95
    //   (<FieldPattern> ",") = FieldPattern "," (*) [".."]
    //   (<FieldPattern> ",") = FieldPattern "," (*) ["Id"]
    //   (<FieldPattern> ",") = FieldPattern "," (*) ["}"]
    //
    //   ".." -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(76));)
    //   "}" -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(76));)
    //   "Id" -> Reduce((<FieldPattern> ",") = FieldPattern, "," => Call(ActionFn(76));)
    //
    pub fn __state95<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<FieldPattern<TypeRef>>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::DotDot(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action76(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action76(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action76(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 96
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [EOF]
    //
    //   EOF -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(58));)
    //
    pub fn __state96<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action58(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 97
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //
    pub fn __state97<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 98
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state98<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 99
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //
    //   "::" -> Shift(S64)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state99<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 100
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //
    //   ">" -> Shift(S114)
    //
    pub fn __state100<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state114(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 101
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" [","]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Escape [")"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "(" -> Shift(S39)
    //   "::" -> Shift(S7)
    //   "Escape" -> Shift(S40)
    //   "&" -> Shift(S46)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //
    //   Escape -> S43
    //   Path -> S45
    //   TypeRef -> S115
    //   "::"? -> S44
    pub fn __state101<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state115(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 102
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //
    //   "Id" -> Shift(S117)
    //
    //   Id -> S116
    //   (<Id> "::") -> S34
    pub fn __state102<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state117(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state116(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 103
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Escape"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Escape"]
    //   "mut"? = (*) "mut" ["Id"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "mut" -> Shift(S53)
    //   "Escape" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //
    //   "mut"? -> S118
    pub fn __state103<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state118(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 104
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Lifetime"]
    //
    //   "::" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //
    pub fn __state104<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 105
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //
    //   Comma<TypeRefOrLifetime> -> S119
    //   (<TypeRefOrLifetime> ",")* -> S50
    pub fn __state105<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state119(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 106
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S120)
    //
    pub fn __state106<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state120(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 107
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //
    //   "Id" -> Shift(S121)
    //
    //   (<Id> "::") -> S34
    //   Id -> S122
    pub fn __state107<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state121(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state122(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 108
    //   PatternKind = "<" TypeRef (*) ">" [")"]
    //   PatternKind = "<" TypeRef (*) ">" [","]
    //
    //   ">" -> Shift(S123)
    //
    pub fn __state108<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state123(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 109
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [","]
    //
    //   ")" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   ".." -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "<" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "Id" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "_" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "::" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "(" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //
    //   Comma<Pattern> -> S124
    //   (<Pattern> ",")* -> S32
    pub fn __state109<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Underscore(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cPattern_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state124(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 110
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [")"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [","]
    //
    //   "}" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //   ".." -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //   "Id" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //
    //   (<FieldPattern> ",")* -> S125
    pub fn __state110<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state125(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 111
    //   PatternKind = "(" Comma<TypeRef> (*) ")" [")"]
    //   PatternKind = "(" Comma<TypeRef> (*) ")" [","]
    //
    //   ")" -> Shift(S126)
    //
    pub fn __state111<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state126(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 112
    //   Pattern = @L PatternKind @R (*) [")"]
    //   Pattern = @L PatternKind @R (*) [","]
    //
    //   "," -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(55));)
    //   ")" -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(55));)
    //
    pub fn __state112<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<PatternKind<TypeRef>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action55(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Pattern(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action55(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Pattern(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 113
    //   FieldPattern = @L Id @R (*) ":" Pattern [","]
    //   FieldPattern = @L Id @R (*) ":" Pattern ["}"]
    //
    //   ":" -> Shift(S127)
    //
    pub fn __state113<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<InternedString>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state127(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 114
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //
    pub fn __state114<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 115
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //   ")" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //
    pub fn __state115<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 116
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S64)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state116<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 117
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state117<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 118
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Escape [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "::" -> Shift(S7)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "(" -> Shift(S80)
    //   "Escape" -> Shift(S76)
    //   "&" -> Shift(S72)
    //
    //   TypeRef -> S128
    //   Path -> S78
    //   "::"? -> S71
    //   Escape -> S70
    pub fn __state118<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state80(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state76(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state72(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state128(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state71(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 119
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S129)
    //
    pub fn __state119<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state129(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 120
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //
    pub fn __state120<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 121
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "(" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "{" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state121<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 122
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S64)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "{" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "(" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state122<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 123
    //   PatternKind = "<" TypeRef ">" (*) [")"]
    //   PatternKind = "<" TypeRef ">" (*) [","]
    //
    //   "," -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(61));)
    //   ")" -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(61));)
    //
    pub fn __state123<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action61(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action61(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 124
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [")"]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [","]
    //
    //   ")" -> Shift(S130)
    //
    pub fn __state124<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Pattern>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state130(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 125
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [","]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   ".." -> Shift(S131)
    //   "}" -> Reduce(FieldPattern? =  => Call(ActionFn(73));)
    //
    //   FieldPattern -> S62
    //   (<FieldPattern> ",") -> S59
    //   FieldPattern? -> S132
    //   @L -> S60
    pub fn __state125<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::DotDot(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state131(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action73(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::FieldPattern_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::FieldPattern(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                __Nonterminal::FieldPattern_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state132(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 126
    //   PatternKind = "(" Comma<TypeRef> ")" (*) [")"]
    //   PatternKind = "(" Comma<TypeRef> ")" (*) [","]
    //
    //   ")" -> Reduce(PatternKind = "(", Comma<TypeRef>, ")" => Call(ActionFn(62));)
    //   "," -> Reduce(PatternKind = "(", Comma<TypeRef>, ")" => Call(ActionFn(62));)
    //
    pub fn __state126<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action62(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action62(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 127
    //   @L = (*) ["("]
    //   @L = (*) [".."]
    //   @L = (*) ["::"]
    //   @L = (*) ["<"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["_"]
    //   FieldPattern = @L Id @R ":" (*) Pattern [","]
    //   FieldPattern = @L Id @R ":" (*) Pattern ["}"]
    //   Pattern = (*) @L PatternKind @R [","]
    //   Pattern = (*) @L PatternKind @R ["}"]
    //
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "_" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //   ".." -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S134
    //   Pattern -> S133
    pub fn __state127<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<InternedString>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Underscore(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state134(text, __lookbehind, __lookahead, __tokens, __sym4));
                }
                __Nonterminal::Pattern(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state133(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 128
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //
    pub fn __state128<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 129
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //
    pub fn __state129<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 130
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [")"]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [","]
    //
    //   ")" -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(56));)
    //   "," -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(56));)
    //
    pub fn __state130<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Pattern>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action56(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action56(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 131
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [","]
    //
    //   "}" -> Shift(S135)
    //
    pub fn __state131<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state135(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 132
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [","]
    //
    //   "}" -> Shift(S136)
    //
    pub fn __state132<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state136(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 133
    //   FieldPattern = @L Id @R ":" Pattern (*) [","]
    //   FieldPattern = @L Id @R ":" Pattern (*) ["}"]
    //
    //   "," -> Reduce(FieldPattern = @L, Id, @R, ":", Pattern => Call(ActionFn(64));)
    //   "}" -> Reduce(FieldPattern = @L, Id, @R, ":", Pattern => Call(ActionFn(64));)
    //
    pub fn __state133<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<InternedString>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<Pattern>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action64(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::FieldPattern(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action64(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::FieldPattern(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 134
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Path = (*) "::"? (<Id> "::")* Id ["("]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   Path = (*) "::"? (<Id> "::")* Id ["}"]
    //   Pattern = @L (*) PatternKind @R [","]
    //   Pattern = @L (*) PatternKind @R ["}"]
    //   PatternKind = (*) Path [","]
    //   PatternKind = (*) Path ["}"]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" [","]
    //   PatternKind = (*) Path "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = (*) Path "{" (<FieldPattern> ",")* ".." "}" ["}"]
    //   PatternKind = (*) "(" Comma<TypeRef> ")" [","]
    //   PatternKind = (*) "(" Comma<TypeRef> ")" ["}"]
    //   PatternKind = (*) ".." [","]
    //   PatternKind = (*) ".." ["}"]
    //   PatternKind = (*) "<" TypeRef ">" [","]
    //   PatternKind = (*) "<" TypeRef ">" ["}"]
    //   PatternKind = (*) "_" [","]
    //   PatternKind = (*) "_" ["}"]
    //
    //   "(" -> Shift(S140)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "_" -> Shift(S137)
    //   "::" -> Shift(S7)
    //   ".." -> Shift(S142)
    //   "<" -> Shift(S141)
    //
    //   "::"? -> S139
    //   PatternKind -> S143
    //   Path -> S138
    pub fn __state134<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state140(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Underscore(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state137(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::DotDot(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state142(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state141(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state139(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::PatternKind(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state143(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state138(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 135
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [","]
    //
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(58));)
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(58));)
    //
    pub fn __state135<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action58(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action58(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 136
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [")"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [","]
    //
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(57));)
    //   ")" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(57));)
    //
    pub fn __state136<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action57(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action57(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 137
    //   PatternKind = "_" (*) [","]
    //   PatternKind = "_" (*) ["}"]
    //
    //   "," -> Reduce(PatternKind = "_" => Call(ActionFn(59));)
    //   "}" -> Reduce(PatternKind = "_" => Call(ActionFn(59));)
    //
    pub fn __state137<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action59(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action59(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 138
    //   PatternKind = Path (*) [","]
    //   PatternKind = Path (*) ["}"]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" [","]
    //   PatternKind = Path (*) "(" Comma<Pattern> ")" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = Path (*) "{" (<FieldPattern> ",")* ".." "}" ["}"]
    //
    //   "}" -> Reduce(PatternKind = Path => Call(ActionFn(63));)
    //   "{" -> Shift(S144)
    //   "(" -> Shift(S145)
    //   "," -> Reduce(PatternKind = Path => Call(ActionFn(63));)
    //
    pub fn __state138<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state144(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state145(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action63(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action63(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 139
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id ["("]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //   Path = "::"? (*) (<Id> "::")* Id ["}"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S146
    pub fn __state139<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state146(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 140
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   PatternKind = "(" (*) Comma<TypeRef> ")" [","]
    //   PatternKind = "(" (*) Comma<TypeRef> ")" ["}"]
    //
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   Comma<TypeRef> -> S147
    //   (<TypeRef> ",")* -> S23
    pub fn __state140<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state147(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 141
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   PatternKind = "<" (*) TypeRef ">" [","]
    //   PatternKind = "<" (*) TypeRef ">" ["}"]
    //   TypeRef = (*) Escape [">"]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "(" -> Shift(S14)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "::" -> Shift(S7)
    //   "Escape" -> Shift(S18)
    //   "&" -> Shift(S16)
    //
    //   "::"? -> S13
    //   Path -> S15
    //   TypeRef -> S148
    //   Escape -> S17
    pub fn __state141<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state148(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 142
    //   PatternKind = ".." (*) [","]
    //   PatternKind = ".." (*) ["}"]
    //
    //   "}" -> Reduce(PatternKind = ".." => Call(ActionFn(60));)
    //   "," -> Reduce(PatternKind = ".." => Call(ActionFn(60));)
    //
    pub fn __state142<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action60(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action60(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 143
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Pattern = @L PatternKind (*) @R [","]
    //   Pattern = @L PatternKind (*) @R ["}"]
    //
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S149
    pub fn __state143<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<PatternKind<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state149(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 144
    //   (<FieldPattern> ",")* = (*) [".."]
    //   (<FieldPattern> ",")* = (*) ["Id"]
    //   (<FieldPattern> ",")* = (*) ["}"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (*) (<FieldPattern> ",")* (<FieldPattern> ",") ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* FieldPattern? "}" ["}"]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" [","]
    //   PatternKind = Path "{" (*) (<FieldPattern> ",")* ".." "}" ["}"]
    //
    //   ".." -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //   "Id" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //   "}" -> Reduce((<FieldPattern> ",")* =  => Call(ActionFn(74));)
    //
    //   (<FieldPattern> ",")* -> S150
    pub fn __state144<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action74(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state150(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 145
    //   (<Pattern> ",")* = (*) ["("]
    //   (<Pattern> ",")* = (*) [")"]
    //   (<Pattern> ",")* = (*) [".."]
    //   (<Pattern> ",")* = (*) ["::"]
    //   (<Pattern> ",")* = (*) ["<"]
    //   (<Pattern> ",")* = (*) ["Id"]
    //   (<Pattern> ",")* = (*) ["_"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["("]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [")"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") [".."]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["::"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["<"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["Id"]
    //   (<Pattern> ",")* = (*) (<Pattern> ",")* (<Pattern> ",") ["_"]
    //   Comma<Pattern> = (*) (<Pattern> ",")* Pattern? [")"]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" [","]
    //   PatternKind = Path "(" (*) Comma<Pattern> ")" ["}"]
    //
    //   "<" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "Id" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   ")" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "(" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "::" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   "_" -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //   ".." -> Reduce((<Pattern> ",")* =  => Call(ActionFn(157));)
    //
    //   (<Pattern> ",")* -> S32
    //   Comma<Pattern> -> S151
    pub fn __state145<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Underscore(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::DotDot(..), _)) => {
                let __nt = super::__action157(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cPattern_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cPattern_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state151(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 146
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["{"]
    //   Id = (*) "Id" ["}"]
    //   Path = "::"? (<Id> "::")* (*) Id ["("]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["}"]
    //
    //   "Id" -> Shift(S153)
    //
    //   (<Id> "::") -> S34
    //   Id -> S152
    pub fn __state146<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state153(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state152(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 147
    //   PatternKind = "(" Comma<TypeRef> (*) ")" [","]
    //   PatternKind = "(" Comma<TypeRef> (*) ")" ["}"]
    //
    //   ")" -> Shift(S154)
    //
    pub fn __state147<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state154(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 148
    //   PatternKind = "<" TypeRef (*) ">" [","]
    //   PatternKind = "<" TypeRef (*) ">" ["}"]
    //
    //   ">" -> Shift(S155)
    //
    pub fn __state148<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state155(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 149
    //   Pattern = @L PatternKind @R (*) [","]
    //   Pattern = @L PatternKind @R (*) ["}"]
    //
    //   "," -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(55));)
    //   "}" -> Reduce(Pattern = @L, PatternKind, @R => Call(ActionFn(55));)
    //
    pub fn __state149<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<PatternKind<TypeRef>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action55(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Pattern(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action55(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Pattern(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 150
    //   (<FieldPattern> ",") = (*) FieldPattern "," [".."]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["Id"]
    //   (<FieldPattern> ",") = (*) FieldPattern "," ["}"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") [".."]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["Id"]
    //   (<FieldPattern> ",")* = (<FieldPattern> ",")* (*) (<FieldPattern> ",") ["}"]
    //   @L = (*) ["Id"]
    //   FieldPattern = (*) @L Id @R ":" Pattern [","]
    //   FieldPattern = (*) @L Id @R ":" Pattern ["}"]
    //   FieldPattern? = (*) ["}"]
    //   FieldPattern? = (*) FieldPattern ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) FieldPattern? "}" ["}"]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* (*) ".." "}" ["}"]
    //
    //   "}" -> Reduce(FieldPattern? =  => Call(ActionFn(73));)
    //   ".." -> Shift(S156)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   (<FieldPattern> ",") -> S59
    //   @L -> S60
    //   FieldPattern? -> S157
    //   FieldPattern -> S62
    pub fn __state150<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::DotDot(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state156(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action73(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::FieldPattern_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cFieldPattern_3e_20_22_2c_22_29(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::FieldPattern_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state157(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::FieldPattern(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 151
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" [","]
    //   PatternKind = Path "(" Comma<Pattern> (*) ")" ["}"]
    //
    //   ")" -> Shift(S158)
    //
    pub fn __state151<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Pattern>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state158(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 152
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) ["("]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //   Path = "::"? (<Id> "::")* Id (*) ["}"]
    //
    //   "{" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "(" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S64)
    //   "}" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state152<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 153
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["{"]
    //   Id = "Id" (*) ["}"]
    //
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "{" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "}" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "(" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state153<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 154
    //   PatternKind = "(" Comma<TypeRef> ")" (*) [","]
    //   PatternKind = "(" Comma<TypeRef> ")" (*) ["}"]
    //
    //   "," -> Reduce(PatternKind = "(", Comma<TypeRef>, ")" => Call(ActionFn(62));)
    //   "}" -> Reduce(PatternKind = "(", Comma<TypeRef>, ")" => Call(ActionFn(62));)
    //
    pub fn __state154<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action62(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action62(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 155
    //   PatternKind = "<" TypeRef ">" (*) [","]
    //   PatternKind = "<" TypeRef ">" (*) ["}"]
    //
    //   "}" -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(61));)
    //   "," -> Reduce(PatternKind = "<", TypeRef, ">" => Call(ActionFn(61));)
    //
    pub fn __state155<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action61(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action61(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 156
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." (*) "}" ["}"]
    //
    //   "}" -> Shift(S159)
    //
    pub fn __state156<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state159(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 157
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? (*) "}" ["}"]
    //
    //   "}" -> Shift(S160)
    //
    pub fn __state157<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state160(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 158
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) [","]
    //   PatternKind = Path "(" Comma<Pattern> ")" (*) ["}"]
    //
    //   "}" -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(56));)
    //   "," -> Reduce(PatternKind = Path, "(", Comma<Pattern>, ")" => Call(ActionFn(56));)
    //
    pub fn __state158<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Pattern>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action56(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action56(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 159
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* ".." "}" (*) ["}"]
    //
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(58));)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, "..", "}" => Call(ActionFn(58));)
    //
    pub fn __state159<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action58(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action58(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 160
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) [","]
    //   PatternKind = Path "{" (<FieldPattern> ",")* FieldPattern? "}" (*) ["}"]
    //
    //   "}" -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(57));)
    //   "," -> Reduce(PatternKind = Path, "{", (<FieldPattern> ",")*, FieldPattern?, "}" => Call(ActionFn(57));)
    //
    pub fn __state160<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<::std::vec::Vec<FieldPattern<TypeRef>>>,
        __sym3: &mut Option<::std::option::Option<FieldPattern<TypeRef>>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action57(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action57(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::PatternKind(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }
}
#[allow(non_snake_case)]
pub fn parse_Grammar<
    'input,
    __TOKEN: __ToTriple<Error=tok::Error>,
    __TOKENS: IntoIterator<Item=__TOKEN>,
>(
    text: &'input str,
    __tokens: __TOKENS,
) -> Result<Grammar, __ParseError<usize,Tok<'input>,tok::Error>>
{
    let mut __tokens = __tokens.into_iter();
    let mut __tokens = __tokens.map(|t| __ToTriple::to_triple(t));
    let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
    match try!(__parse__Grammar::__state0(text, None, __lookahead, &mut __tokens)) {
        (_, Some(__lookahead), _) => {
            Err(__ParseError::ExtraToken { token: __lookahead })
        }
        (_, None, __parse__Grammar::__Nonterminal::____Grammar(__nt)) => {
            Ok(__nt)
        }
        _ => unreachable!(),
    }
}

mod __parse__Grammar {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use intern::{intern, InternedString};
    use grammar::parse_tree::*;
    use grammar::pattern::*;
    use std::iter::once;
    use tok::{self, Tok};
    extern crate lalrpop_util as __lalrpop_util;
    use self::__lalrpop_util::ParseError as __ParseError;
    use super::__ToTriple;

    pub enum __Nonterminal<'input, > {
        _28_22if_22_20_3cCond_3e_29_3f(::std::option::Option<Condition>),
        NonterminalId_3f(::std::option::Option<NonterminalString>),
        Alternative_2a(::std::vec::Vec<Alternative>),
        Comma_3cConversion_3e(Vec<Conversion>),
        _28_3cId_3e_20_22_3a_3a_22_29(InternedString),
        _28_3cTypeParameter_3e_20_22_2c_22_29(TypeParameter),
        _28_3cConversion_3e_20_22_2c_22_29_2a(::std::vec::Vec<Conversion>),
        _28_3cTypeParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeParameter>),
        RepeatOp(RepeatOp),
        _40L(usize),
        _28_3cPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<Pattern>),
        ____Grammar(Grammar),
        Comma_3cTypeRefOrLifetime_3e(Vec<TypeRef>),
        TypeRefOrLifetime(TypeRef),
        Use_2a(::std::vec::Vec<GrammarItem>),
        Path(Path),
        Escape(InternedString),
        Id(InternedString),
        _28_3cConversion_3e_20_22_2c_22_29(Conversion),
        GrammarItem_2a(::std::vec::Vec<GrammarItem>),
        _28_3cPattern_3e_20_22_2c_22_29(Pattern),
        TypeParameter_3f(::std::option::Option<TypeParameter>),
        _22where_22_3f(::std::option::Option<Tok<'input>>),
        GrammarTypeParameters(Vec<TypeParameter>),
        TypeParameter(TypeParameter),
        Alternatives(Vec<Alternative>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29_2a(::std::vec::Vec<Parameter>),
        AssociatedType_2a(::std::vec::Vec<AssociatedType>),
        Grammar(Grammar),
        GrammarParameter(Parameter),
        StringLiteral(InternedString),
        Action_3f(::std::option::Option<ActionKind>),
        Comma_3cTypeRef_3e(Vec<TypeRef>),
        _28_3cId_3e_20_22_3a_3a_22_29_2a(::std::vec::Vec<InternedString>),
        Symbol_2a(::std::vec::Vec<Symbol>),
        Nonterminal(GrammarItem),
        GrammarParameters_3f(::std::option::Option<Vec<Parameter>>),
        _22_3a_3a_22_3f(::std::option::Option<Tok<'input>>),
        _40R(usize),
        Action(ActionKind),
        Symbol1(Symbol),
        Comma_3cPattern_3e(Vec<Pattern>),
        _28_3cNonterminalId_3e_20_22_2c_22_29(NonterminalString),
        _22pub_22_3f(::std::option::Option<Tok<'input>>),
        _28_3cFieldPattern_3e_20_22_2c_22_29_2a(::std::vec::Vec<FieldPattern<TypeRef>>),
        _28_22if_22_20_3cCond_3e_29(Condition),
        Symbol0(Symbol),
        _28_3cTypeRef_3e_20_22_2c_22_29(TypeRef),
        GrammarParameter_3f(::std::option::Option<Parameter>),
        Conversion(Conversion),
        NonterminalName((NonterminalString, Vec<NonterminalString>)),
        GrammarTypeParameters_3f(::std::option::Option<Vec<TypeParameter>>),
        Comma_3cTypeParameter_3e(Vec<TypeParameter>),
        Symbol(Symbol),
        Comma_3cSymbol_3e(Vec<Symbol>),
        _28_3cGrammarParameter_3e_20_22_2c_22_29(Parameter),
        Terminal(TerminalString),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(TypeRef),
        GrammarParameters(Vec<Parameter>),
        Conversion_3f(::std::option::Option<Conversion>),
        Cond(Condition),
        _28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        Lifetime_3f(::std::option::Option<InternedString>),
        ____Pattern(Pattern),
        _22mut_22_3f(::std::option::Option<Tok<'input>>),
        SymbolKind1(SymbolKind),
        _28_3cNonterminalId_3e_20_22_2c_22_29_2a(::std::vec::Vec<NonterminalString>),
        AssociatedType(AssociatedType),
        Symbol_3f(::std::option::Option<Symbol>),
        FieldPattern(FieldPattern<TypeRef>),
        PatternKind(PatternKind<TypeRef>),
        FieldPattern_3f(::std::option::Option<FieldPattern<TypeRef>>),
        ExternToken(GrammarItem),
        _28_3cSymbol_3e_20_22_2c_22_29(Symbol),
        CondOp(ConditionOp),
        TypeRef(TypeRef),
        Use(GrammarItem),
        Pattern_3f(::std::option::Option<Pattern>),
        GrammarItem(GrammarItem),
        Comma_3cGrammarParameter_3e(Vec<Parameter>),
        NonterminalId(NonterminalString),
        TypeRefOrLifetime_3f(::std::option::Option<TypeRef>),
        Lifetime(InternedString),
        Comma_3cNonterminalId_3e(Vec<NonterminalString>),
        TypeRef_3f(::std::option::Option<TypeRef>),
        _28_3cSymbol_3e_20_22_2c_22_29_2a(::std::vec::Vec<Symbol>),
        Pattern(Pattern),
        _28_3cFieldPattern_3e_20_22_2c_22_29(FieldPattern<TypeRef>),
        MacroId(NonterminalString),
        Alternative(Alternative),
        _28_3cTypeRef_3e_20_22_2c_22_29_2a(::std::vec::Vec<TypeRef>),
        _28_22_3a_22_20_3cTypeRef_3e_29_3f(::std::option::Option<TypeRef>),
        _28_22_3a_22_20_3cTypeRef_3e_29(TypeRef),
    }

    // State 0
    //   Grammar = (*) Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? ";" GrammarItem* [EOF]
    //   Use* = (*) ["grammar"]
    //   Use* = (*) ["use"]
    //   Use* = (*) Use* Use ["grammar"]
    //   Use* = (*) Use* Use ["use"]
    //   __Grammar = (*) Grammar [EOF]
    //
    //   "grammar" -> Reduce(Use* =  => Call(ActionFn(118));)
    //   "use" -> Reduce(Use* =  => Call(ActionFn(118));)
    //
    //   Use* -> S1
    //   Grammar -> S2
    pub fn __state0<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Grammar(..), _)) => {
                let __nt = super::__action118(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Use_2a(__nt));
            }
            Some((_, Tok::Use(..), _)) => {
                let __nt = super::__action118(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Use_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        loop {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Use_2a(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state1(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                __Nonterminal::Grammar(__nt) => {
                    let __sym0 = &mut Some(__nt);
                    __result = try!(__state2(text, __lookbehind, __lookahead, __tokens, __sym0));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
    }

    // State 1
    //   @L = (*) ["grammar"]
    //   Grammar = Use* (*) @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? ";" GrammarItem* [EOF]
    //   Use = (*) "use" ";" ["grammar"]
    //   Use = (*) "use" ";" ["use"]
    //   Use* = Use* (*) Use ["grammar"]
    //   Use* = Use* (*) Use ["use"]
    //
    //   "use" -> Shift(S5)
    //   "grammar" -> Reduce(@L =  => Lookahead;)
    //
    //   Use -> S4
    //   @L -> S3
    pub fn __state1<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Use(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state5(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Grammar(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Use(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state4(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state3(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 2
    //   __Grammar = Grammar (*) [EOF]
    //
    //   EOF -> Reduce(__Grammar = Grammar => Call(ActionFn(0));)
    //
    pub fn __state2<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Grammar>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action0(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::____Grammar(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 3
    //   Grammar = Use* @L (*) "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? ";" GrammarItem* [EOF]
    //
    //   "grammar" -> Shift(S6)
    //
    pub fn __state3<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Grammar(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state6(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 4
    //   Use* = Use* Use (*) ["grammar"]
    //   Use* = Use* Use (*) ["use"]
    //
    //   "use" -> Reduce(Use* = Use*, Use => Call(ActionFn(119));)
    //   "grammar" -> Reduce(Use* = Use*, Use => Call(ActionFn(119));)
    //
    pub fn __state4<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action119(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use_2a(__nt)));
            }
            Some((_, Tok::Grammar(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action119(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 5
    //   Use = "use" (*) ";" ["grammar"]
    //   Use = "use" (*) ";" ["use"]
    //
    //   ";" -> Shift(S7)
    //
    pub fn __state5<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state7(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 6
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["where"]
    //   Grammar = Use* @L "grammar" (*) @R GrammarTypeParameters? GrammarParameters? "where"? ";" GrammarItem* [EOF]
    //
    //   "where" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S8
    pub fn __state6<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Where(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state8(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 7
    //   Use = "use" ";" (*) ["grammar"]
    //   Use = "use" ";" (*) ["use"]
    //
    //   "use" -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //   "grammar" -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //
    pub fn __state7<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            Some((_, Tok::Grammar(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 8
    //   Grammar = Use* @L "grammar" @R (*) GrammarTypeParameters? GrammarParameters? "where"? ";" GrammarItem* [EOF]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = (*) "<" Comma<TypeParameter> ">" ["where"]
    //   GrammarTypeParameters? = (*) ["("]
    //   GrammarTypeParameters? = (*) [";"]
    //   GrammarTypeParameters? = (*) ["where"]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters ["("]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters [";"]
    //   GrammarTypeParameters? = (*) GrammarTypeParameters ["where"]
    //
    //   "where" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(117));)
    //   "<" -> Shift(S11)
    //   "(" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(117));)
    //   ";" -> Reduce(GrammarTypeParameters? =  => Call(ActionFn(117));)
    //
    //   GrammarTypeParameters -> S9
    //   GrammarTypeParameters? -> S10
    pub fn __state8<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state11(text, __lookbehind, __lookahead, __tokens, __sym4));
            }
            Some((_, Tok::Where(..), _)) => {
                let __nt = super::__action117(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action117(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters_3f(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action117(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::GrammarTypeParameters(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state9(text, __lookbehind, __lookahead, __tokens, __sym4));
                }
                __Nonterminal::GrammarTypeParameters_3f(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state10(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 9
    //   GrammarTypeParameters? = GrammarTypeParameters (*) ["("]
    //   GrammarTypeParameters? = GrammarTypeParameters (*) [";"]
    //   GrammarTypeParameters? = GrammarTypeParameters (*) ["where"]
    //
    //   "where" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(116));)
    //   "(" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(116));)
    //   ";" -> Reduce(GrammarTypeParameters? = GrammarTypeParameters => Call(ActionFn(116));)
    //
    pub fn __state9<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Where(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action116(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters_3f(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action116(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters_3f(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action116(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 10
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? (*) GrammarParameters? "where"? ";" GrammarItem* [EOF]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = (*) "(" Comma<GrammarParameter> ")" ["where"]
    //   GrammarParameters? = (*) [";"]
    //   GrammarParameters? = (*) ["where"]
    //   GrammarParameters? = (*) GrammarParameters [";"]
    //   GrammarParameters? = (*) GrammarParameters ["where"]
    //
    //   "(" -> Shift(S13)
    //   ";" -> Reduce(GrammarParameters? =  => Call(ActionFn(115));)
    //   "where" -> Reduce(GrammarParameters? =  => Call(ActionFn(115));)
    //
    //   GrammarParameters? -> S14
    //   GrammarParameters -> S12
    pub fn __state10<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state13(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action115(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarParameters_3f(__nt));
            }
            Some((_, Tok::Where(..), _)) => {
                let __nt = super::__action115(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarParameters_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::GrammarParameters_3f(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state14(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                __Nonterminal::GrammarParameters(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state12(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 11
    //   (<TypeParameter> ",")* = (*) [">"]
    //   (<TypeParameter> ",")* = (*) ["Id"]
    //   (<TypeParameter> ",")* = (*) ["Lifetime"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") [">"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") ["Id"]
    //   (<TypeParameter> ",")* = (*) (<TypeParameter> ",")* (<TypeParameter> ",") ["Lifetime"]
    //   Comma<TypeParameter> = (*) (<TypeParameter> ",")* TypeParameter? [">"]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["("]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" [";"]
    //   GrammarTypeParameters = "<" (*) Comma<TypeParameter> ">" ["where"]
    //
    //   "Lifetime" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(122));)
    //   ">" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(122));)
    //   "Id" -> Reduce((<TypeParameter> ",")* =  => Call(ActionFn(122));)
    //
    //   (<TypeParameter> ",")* -> S16
    //   Comma<TypeParameter> -> S15
    pub fn __state11<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action122(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action122(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action122(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state16(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeParameter_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state15(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 12
    //   GrammarParameters? = GrammarParameters (*) [";"]
    //   GrammarParameters? = GrammarParameters (*) ["where"]
    //
    //   ";" -> Reduce(GrammarParameters? = GrammarParameters => Call(ActionFn(114));)
    //   "where" -> Reduce(GrammarParameters? = GrammarParameters => Call(ActionFn(114));)
    //
    pub fn __state12<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action114(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameters_3f(__nt)));
            }
            Some((_, Tok::Where(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action114(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameters_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 13
    //   (<GrammarParameter> ",")* = (*) [")"]
    //   (<GrammarParameter> ",")* = (*) ["Id"]
    //   (<GrammarParameter> ",")* = (*) (<GrammarParameter> ",")* (<GrammarParameter> ",") [")"]
    //   (<GrammarParameter> ",")* = (*) (<GrammarParameter> ",")* (<GrammarParameter> ",") ["Id"]
    //   Comma<GrammarParameter> = (*) (<GrammarParameter> ",")* GrammarParameter? [")"]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" [";"]
    //   GrammarParameters = "(" (*) Comma<GrammarParameter> ")" ["where"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",")* =  => Call(ActionFn(127));)
    //   "Id" -> Reduce((<GrammarParameter> ",")* =  => Call(ActionFn(127));)
    //
    //   (<GrammarParameter> ",")* -> S18
    //   Comma<GrammarParameter> -> S17
    pub fn __state13<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action127(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action127(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state18(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cGrammarParameter_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state17(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 14
    //   "where"? = (*) [";"]
    //   "where"? = (*) "where" [";"]
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? (*) "where"? ";" GrammarItem* [EOF]
    //
    //   "where" -> Shift(S19)
    //   ";" -> Reduce("where"? =  => Call(ActionFn(113));)
    //
    //   "where"? -> S20
    pub fn __state14<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Where(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state19(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action113(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22where_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22where_22_3f(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state20(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 15
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["("]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" [";"]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> (*) ">" ["where"]
    //
    //   ">" -> Shift(S21)
    //
    pub fn __state15<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state21(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 16
    //   (<TypeParameter> ",") = (*) TypeParameter "," [">"]
    //   (<TypeParameter> ",") = (*) TypeParameter "," ["Id"]
    //   (<TypeParameter> ",") = (*) TypeParameter "," ["Lifetime"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") [">"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") ["Id"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (*) (<TypeParameter> ",") ["Lifetime"]
    //   Comma<TypeParameter> = (<TypeParameter> ",")* (*) TypeParameter? [">"]
    //   TypeParameter = (*) "Id" [","]
    //   TypeParameter = (*) "Id" [">"]
    //   TypeParameter = (*) "Lifetime" [","]
    //   TypeParameter = (*) "Lifetime" [">"]
    //   TypeParameter? = (*) [">"]
    //   TypeParameter? = (*) TypeParameter [">"]
    //
    //   "Id" -> Shift(S22)
    //   "Lifetime" -> Shift(S24)
    //   ">" -> Reduce(TypeParameter? =  => Call(ActionFn(121));)
    //
    //   TypeParameter? -> S26
    //   TypeParameter -> S25
    //   (<TypeParameter> ",") -> S23
    pub fn __state16<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state22(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state24(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action121(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeParameter_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeParameter_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state26(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::TypeParameter(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state25(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state23(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 17
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" [";"]
    //   GrammarParameters = "(" Comma<GrammarParameter> (*) ")" ["where"]
    //
    //   ")" -> Shift(S27)
    //
    pub fn __state17<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state27(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 18
    //   (<GrammarParameter> ",") = (*) GrammarParameter "," [")"]
    //   (<GrammarParameter> ",") = (*) GrammarParameter "," ["Id"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (*) (<GrammarParameter> ",") [")"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (*) (<GrammarParameter> ",") ["Id"]
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")* (*) GrammarParameter? [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [")"]
    //   GrammarParameter = (*) Id ":" TypeRef [","]
    //   GrammarParameter? = (*) [")"]
    //   GrammarParameter? = (*) GrammarParameter [")"]
    //   Id = (*) "Id" [":"]
    //
    //   "Id" -> Shift(S28)
    //   ")" -> Reduce(GrammarParameter? =  => Call(ActionFn(126));)
    //
    //   (<GrammarParameter> ",") -> S29
    //   Id -> S32
    //   GrammarParameter -> S30
    //   GrammarParameter? -> S31
    pub fn __state18<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state28(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action126(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarParameter_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state29(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state32(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::GrammarParameter(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state30(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::GrammarParameter_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state31(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 19
    //   "where"? = "where" (*) [";"]
    //
    //   ";" -> Reduce("where"? = "where" => Call(ActionFn(112));)
    //
    pub fn __state19<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action112(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22where_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 20
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? (*) ";" GrammarItem* [EOF]
    //
    //   ";" -> Shift(S33)
    //
    pub fn __state20<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        __sym6: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym7 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state33(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 21
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["("]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) [";"]
    //   GrammarTypeParameters = "<" Comma<TypeParameter> ">" (*) ["where"]
    //
    //   ";" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(3));)
    //   "where" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(3));)
    //   "(" -> Reduce(GrammarTypeParameters = "<", Comma<TypeParameter>, ">" => Call(ActionFn(3));)
    //
    pub fn __state21<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeParameter>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action3(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters(__nt)));
            }
            Some((_, Tok::Where(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action3(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action3(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarTypeParameters(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 22
    //   TypeParameter = "Id" (*) [","]
    //   TypeParameter = "Id" (*) [">"]
    //
    //   ">" -> Reduce(TypeParameter = "Id" => Call(ActionFn(5));)
    //   "," -> Reduce(TypeParameter = "Id" => Call(ActionFn(5));)
    //
    pub fn __state22<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action5(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeParameter(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action5(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeParameter(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 23
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) [">"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) ["Id"]
    //   (<TypeParameter> ",")* = (<TypeParameter> ",")* (<TypeParameter> ",") (*) ["Lifetime"]
    //
    //   ">" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(123));)
    //   "Lifetime" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(123));)
    //   "Id" -> Reduce((<TypeParameter> ",")* = (<TypeParameter> ",")*, (<TypeParameter> ",") => Call(ActionFn(123));)
    //
    pub fn __state23<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
        __sym1: &mut Option<TypeParameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action123(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action123(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action123(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 24
    //   TypeParameter = "Lifetime" (*) [","]
    //   TypeParameter = "Lifetime" (*) [">"]
    //
    //   "," -> Reduce(TypeParameter = "Lifetime" => Call(ActionFn(4));)
    //   ">" -> Reduce(TypeParameter = "Lifetime" => Call(ActionFn(4));)
    //
    pub fn __state24<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action4(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeParameter(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action4(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeParameter(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 25
    //   (<TypeParameter> ",") = TypeParameter (*) "," [">"]
    //   (<TypeParameter> ",") = TypeParameter (*) "," ["Id"]
    //   (<TypeParameter> ",") = TypeParameter (*) "," ["Lifetime"]
    //   TypeParameter? = TypeParameter (*) [">"]
    //
    //   ">" -> Reduce(TypeParameter? = TypeParameter => Call(ActionFn(120));)
    //   "," -> Shift(S34)
    //
    pub fn __state25<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeParameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state34(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action120(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeParameter_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 26
    //   Comma<TypeParameter> = (<TypeParameter> ",")* TypeParameter? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeParameter> = (<TypeParameter> ",")*, TypeParameter? => Call(ActionFn(109));)
    //
    pub fn __state26<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeParameter>>,
        __sym1: &mut Option<::std::option::Option<TypeParameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action109(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeParameter_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 27
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) [";"]
    //   GrammarParameters = "(" Comma<GrammarParameter> ")" (*) ["where"]
    //
    //   ";" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => Call(ActionFn(6));)
    //   "where" -> Reduce(GrammarParameters = "(", Comma<GrammarParameter>, ")" => Call(ActionFn(6));)
    //
    pub fn __state27<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<Parameter>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action6(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameters(__nt)));
            }
            Some((_, Tok::Where(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action6(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameters(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 28
    //   Id = "Id" (*) [":"]
    //
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state28<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 29
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (<GrammarParameter> ",") (*) [")"]
    //   (<GrammarParameter> ",")* = (<GrammarParameter> ",")* (<GrammarParameter> ",") (*) ["Id"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",")* = (<GrammarParameter> ",")*, (<GrammarParameter> ",") => Call(ActionFn(128));)
    //   "Id" -> Reduce((<GrammarParameter> ",")* = (<GrammarParameter> ",")*, (<GrammarParameter> ",") => Call(ActionFn(128));)
    //
    pub fn __state29<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Parameter>>,
        __sym1: &mut Option<Parameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action128(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action128(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 30
    //   (<GrammarParameter> ",") = GrammarParameter (*) "," [")"]
    //   (<GrammarParameter> ",") = GrammarParameter (*) "," ["Id"]
    //   GrammarParameter? = GrammarParameter (*) [")"]
    //
    //   "," -> Shift(S35)
    //   ")" -> Reduce(GrammarParameter? = GrammarParameter => Call(ActionFn(125));)
    //
    pub fn __state30<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Parameter>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state35(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action125(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameter_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 31
    //   Comma<GrammarParameter> = (<GrammarParameter> ",")* GrammarParameter? (*) [")"]
    //
    //   ")" -> Reduce(Comma<GrammarParameter> = (<GrammarParameter> ",")*, GrammarParameter? => Call(ActionFn(108));)
    //
    pub fn __state31<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Parameter>>,
        __sym1: &mut Option<::std::option::Option<Parameter>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action108(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cGrammarParameter_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 32
    //   GrammarParameter = Id (*) ":" TypeRef [")"]
    //   GrammarParameter = Id (*) ":" TypeRef [","]
    //
    //   ":" -> Shift(S36)
    //
    pub fn __state32<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state36(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 33
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? ";" (*) GrammarItem* [EOF]
    //   GrammarItem* = (*) [EOF]
    //   GrammarItem* = (*) ["Escape"]
    //   GrammarItem* = (*) ["Id"]
    //   GrammarItem* = (*) ["MacroId"]
    //   GrammarItem* = (*) ["extern"]
    //   GrammarItem* = (*) ["pub"]
    //   GrammarItem* = (*) ["use"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem [EOF]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["Escape"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["Id"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["MacroId"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["extern"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["pub"]
    //   GrammarItem* = (*) GrammarItem* GrammarItem ["use"]
    //
    //   "pub" -> Reduce(GrammarItem* =  => Call(ActionFn(110));)
    //   "Id" -> Reduce(GrammarItem* =  => Call(ActionFn(110));)
    //   "Escape" -> Reduce(GrammarItem* =  => Call(ActionFn(110));)
    //   "extern" -> Reduce(GrammarItem* =  => Call(ActionFn(110));)
    //   "MacroId" -> Reduce(GrammarItem* =  => Call(ActionFn(110));)
    //   EOF -> Reduce(GrammarItem* =  => Call(ActionFn(110));)
    //   "use" -> Reduce(GrammarItem* =  => Call(ActionFn(110));)
    //
    //   GrammarItem* -> S37
    pub fn __state33<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        __sym6: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym7: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Pub(..), _)) => {
                let __nt = super::__action110(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action110(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action110(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __nt = super::__action110(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action110(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt));
            }
            None => {
                let __nt = super::__action110(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt));
            }
            Some((_, Tok::Use(..), _)) => {
                let __nt = super::__action110(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym7.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::GrammarItem_2a(__nt) => {
                    let __sym8 = &mut Some(__nt);
                    __result = try!(__state37(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 34
    //   (<TypeParameter> ",") = TypeParameter "," (*) [">"]
    //   (<TypeParameter> ",") = TypeParameter "," (*) ["Id"]
    //   (<TypeParameter> ",") = TypeParameter "," (*) ["Lifetime"]
    //
    //   "Id" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(124));)
    //   "Lifetime" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(124));)
    //   ">" -> Reduce((<TypeParameter> ",") = TypeParameter, "," => Call(ActionFn(124));)
    //
    pub fn __state34<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeParameter>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action124(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action124(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action124(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeParameter_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 35
    //   (<GrammarParameter> ",") = GrammarParameter "," (*) [")"]
    //   (<GrammarParameter> ",") = GrammarParameter "," (*) ["Id"]
    //
    //   ")" -> Reduce((<GrammarParameter> ",") = GrammarParameter, "," => Call(ActionFn(129));)
    //   "Id" -> Reduce((<GrammarParameter> ",") = GrammarParameter, "," => Call(ActionFn(129));)
    //
    pub fn __state35<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Parameter>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action129(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action129(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cGrammarParameter_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 36
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" [","]
    //   GrammarParameter = Id ":" (*) TypeRef [")"]
    //   GrammarParameter = Id ":" (*) TypeRef [","]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Escape [")"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "&" -> Shift(S44)
    //   "Escape" -> Shift(S40)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "(" -> Shift(S39)
    //   "::" -> Shift(S41)
    //
    //   "::"? -> S42
    //   Escape -> S43
    //   TypeRef -> S45
    //   Path -> S38
    pub fn __state36<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state42(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state45(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 37
    //   "pub"? = (*) ["Escape"]
    //   "pub"? = (*) ["Id"]
    //   "pub"? = (*) ["MacroId"]
    //   "pub"? = (*) "pub" ["Escape"]
    //   "pub"? = (*) "pub" ["Id"]
    //   "pub"? = (*) "pub" ["MacroId"]
    //   @L = (*) ["extern"]
    //   ExternToken = (*) @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = (*) @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = (*) @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = (*) @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = (*) @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = (*) @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = (*) @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //   Grammar = Use* @L "grammar" @R GrammarTypeParameters? GrammarParameters? "where"? ";" GrammarItem* (*) [EOF]
    //   GrammarItem = (*) ExternToken [EOF]
    //   GrammarItem = (*) ExternToken ["Escape"]
    //   GrammarItem = (*) ExternToken ["Id"]
    //   GrammarItem = (*) ExternToken ["MacroId"]
    //   GrammarItem = (*) ExternToken ["extern"]
    //   GrammarItem = (*) ExternToken ["pub"]
    //   GrammarItem = (*) ExternToken ["use"]
    //   GrammarItem = (*) Nonterminal [EOF]
    //   GrammarItem = (*) Nonterminal ["Escape"]
    //   GrammarItem = (*) Nonterminal ["Id"]
    //   GrammarItem = (*) Nonterminal ["MacroId"]
    //   GrammarItem = (*) Nonterminal ["extern"]
    //   GrammarItem = (*) Nonterminal ["pub"]
    //   GrammarItem = (*) Nonterminal ["use"]
    //   GrammarItem = (*) Use [EOF]
    //   GrammarItem = (*) Use ["Escape"]
    //   GrammarItem = (*) Use ["Id"]
    //   GrammarItem = (*) Use ["MacroId"]
    //   GrammarItem = (*) Use ["extern"]
    //   GrammarItem = (*) Use ["pub"]
    //   GrammarItem = (*) Use ["use"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem [EOF]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["Escape"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["Id"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["MacroId"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["extern"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["pub"]
    //   GrammarItem* = GrammarItem* (*) GrammarItem ["use"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = (*) "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //   Use = (*) "use" ";" [EOF]
    //   Use = (*) "use" ";" ["Escape"]
    //   Use = (*) "use" ";" ["Id"]
    //   Use = (*) "use" ";" ["MacroId"]
    //   Use = (*) "use" ";" ["extern"]
    //   Use = (*) "use" ";" ["pub"]
    //   Use = (*) "use" ";" ["use"]
    //
    //   "use" -> Shift(S48)
    //   "Escape" -> Reduce("pub"? =  => Call(ActionFn(107));)
    //   "Id" -> Reduce("pub"? =  => Call(ActionFn(107));)
    //   "pub" -> Shift(S49)
    //   "MacroId" -> Reduce("pub"? =  => Call(ActionFn(107));)
    //   "extern" -> Reduce(@L =  => Lookahead;)
    //   EOF -> Reduce(Grammar = Use*, @L, "grammar", @R, GrammarTypeParameters?, GrammarParameters?, "where"?, ";", GrammarItem* => Call(ActionFn(2));)
    //
    //   Nonterminal -> S50
    //   Use -> S51
    //   ExternToken -> S47
    //   @L -> S52
    //   GrammarItem -> S53
    //   "pub"? -> S46
    pub fn __state37<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<Vec<TypeParameter>>>,
        __sym5: &mut Option<::std::option::Option<Vec<Parameter>>>,
        __sym6: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym7: &mut Option<Tok<'input>>,
        __sym8: &mut Option<::std::vec::Vec<GrammarItem>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Use(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym9 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state48(text, __lookbehind, __lookahead, __tokens, __sym9));
            }
            Some((_, __tok @ Tok::Pub(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym9 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state49(text, __lookbehind, __lookahead, __tokens, __sym9));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action107(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22pub_22_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action107(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22pub_22_3f(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action107(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22pub_22_3f(__nt));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __nt = super::__action2(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Grammar(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym8.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Nonterminal(__nt) => {
                    let __sym9 = &mut Some(__nt);
                    __result = try!(__state50(text, __lookbehind, __lookahead, __tokens, __sym9));
                }
                __Nonterminal::Use(__nt) => {
                    let __sym9 = &mut Some(__nt);
                    __result = try!(__state51(text, __lookbehind, __lookahead, __tokens, __sym9));
                }
                __Nonterminal::ExternToken(__nt) => {
                    let __sym9 = &mut Some(__nt);
                    __result = try!(__state47(text, __lookbehind, __lookahead, __tokens, __sym9));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym9 = &mut Some(__nt);
                    __result = try!(__state52(text, __lookbehind, __lookahead, __tokens, __sym9));
                }
                __Nonterminal::GrammarItem(__nt) => {
                    let __sym9 = &mut Some(__nt);
                    __result = try!(__state53(text, __lookbehind, __lookahead, __tokens, __sym8, __sym9));
                }
                __Nonterminal::_22pub_22_3f(__nt) => {
                    let __sym9 = &mut Some(__nt);
                    __result = try!(__state46(text, __lookbehind, __lookahead, __tokens, __sym9));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 38
    //   TypeRef = Path (*) [")"]
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //
    //   "<" -> Shift(S54)
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //   ")" -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //
    pub fn __state38<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state54(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 39
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   (<TypeRef> ",")* -> S56
    //   Comma<TypeRef> -> S55
    pub fn __state39<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state55(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 40
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) [","]
    //
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state40<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 41
    //   "::"? = "::" (*) ["Id"]
    //
    //   "Id" -> Reduce("::"? = "::" => Call(ActionFn(84));)
    //
    pub fn __state41<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action84(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 42
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id [")"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S57
    pub fn __state42<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state57(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 43
    //   TypeRef = Escape (*) [")"]
    //   TypeRef = Escape (*) [","]
    //
    //   "," -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //   ")" -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //
    pub fn __state43<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 44
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Escape"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Escape"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Escape"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //
    //   "Escape" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Lifetime" -> Shift(S58)
    //
    //   Lifetime -> S59
    //   Lifetime? -> S60
    pub fn __state44<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state60(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 45
    //   GrammarParameter = Id ":" TypeRef (*) [")"]
    //   GrammarParameter = Id ":" TypeRef (*) [","]
    //
    //   ")" -> Reduce(GrammarParameter = Id, ":", TypeRef => Call(ActionFn(7));)
    //   "," -> Reduce(GrammarParameter = Id, ":", TypeRef => Call(ActionFn(7));)
    //
    pub fn __state45<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action7(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameter(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action7(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarParameter(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 46
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? (*) @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S61
    pub fn __state46<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state61(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 47
    //   GrammarItem = ExternToken (*) [EOF]
    //   GrammarItem = ExternToken (*) ["Escape"]
    //   GrammarItem = ExternToken (*) ["Id"]
    //   GrammarItem = ExternToken (*) ["MacroId"]
    //   GrammarItem = ExternToken (*) ["extern"]
    //   GrammarItem = ExternToken (*) ["pub"]
    //   GrammarItem = ExternToken (*) ["use"]
    //
    //   "pub" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(9));)
    //   EOF -> Reduce(GrammarItem = ExternToken => Call(ActionFn(9));)
    //   "Escape" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(9));)
    //   "use" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(9));)
    //   "MacroId" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(9));)
    //   "extern" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(9));)
    //   "Id" -> Reduce(GrammarItem = ExternToken => Call(ActionFn(9));)
    //
    pub fn __state47<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action9(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action9(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action9(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action9(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action9(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action9(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action9(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 48
    //   Use = "use" (*) ";" [EOF]
    //   Use = "use" (*) ";" ["Escape"]
    //   Use = "use" (*) ";" ["Id"]
    //   Use = "use" (*) ";" ["MacroId"]
    //   Use = "use" (*) ";" ["extern"]
    //   Use = "use" (*) ";" ["pub"]
    //   Use = "use" (*) ";" ["use"]
    //
    //   ";" -> Shift(S62)
    //
    pub fn __state48<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state62(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 49
    //   "pub"? = "pub" (*) ["Escape"]
    //   "pub"? = "pub" (*) ["Id"]
    //   "pub"? = "pub" (*) ["MacroId"]
    //
    //   "MacroId" -> Reduce("pub"? = "pub" => Call(ActionFn(106));)
    //   "Escape" -> Reduce("pub"? = "pub" => Call(ActionFn(106));)
    //   "Id" -> Reduce("pub"? = "pub" => Call(ActionFn(106));)
    //
    pub fn __state49<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action106(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22pub_22_3f(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action106(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22pub_22_3f(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action106(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22pub_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 50
    //   GrammarItem = Nonterminal (*) [EOF]
    //   GrammarItem = Nonterminal (*) ["Escape"]
    //   GrammarItem = Nonterminal (*) ["Id"]
    //   GrammarItem = Nonterminal (*) ["MacroId"]
    //   GrammarItem = Nonterminal (*) ["extern"]
    //   GrammarItem = Nonterminal (*) ["pub"]
    //   GrammarItem = Nonterminal (*) ["use"]
    //
    //   "Id" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(10));)
    //   "use" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(10));)
    //   "Escape" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(10));)
    //   "extern" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(10));)
    //   EOF -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(10));)
    //   "pub" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(10));)
    //   "MacroId" -> Reduce(GrammarItem = Nonterminal => Call(ActionFn(10));)
    //
    pub fn __state50<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action10(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action10(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action10(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action10(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action10(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action10(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action10(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 51
    //   GrammarItem = Use (*) [EOF]
    //   GrammarItem = Use (*) ["Escape"]
    //   GrammarItem = Use (*) ["Id"]
    //   GrammarItem = Use (*) ["MacroId"]
    //   GrammarItem = Use (*) ["extern"]
    //   GrammarItem = Use (*) ["pub"]
    //   GrammarItem = Use (*) ["use"]
    //
    //   "Escape" -> Reduce(GrammarItem = Use => Call(ActionFn(8));)
    //   "use" -> Reduce(GrammarItem = Use => Call(ActionFn(8));)
    //   EOF -> Reduce(GrammarItem = Use => Call(ActionFn(8));)
    //   "Id" -> Reduce(GrammarItem = Use => Call(ActionFn(8));)
    //   "pub" -> Reduce(GrammarItem = Use => Call(ActionFn(8));)
    //   "MacroId" -> Reduce(GrammarItem = Use => Call(ActionFn(8));)
    //   "extern" -> Reduce(GrammarItem = Use => Call(ActionFn(8));)
    //
    pub fn __state51<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action8(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action8(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action8(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action8(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action8(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action8(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action8(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 52
    //   ExternToken = @L (*) "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L (*) "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L (*) "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L (*) "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L (*) "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L (*) "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L (*) "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "extern" -> Shift(S63)
    //
    pub fn __state52<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Extern(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state63(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 53
    //   GrammarItem* = GrammarItem* GrammarItem (*) [EOF]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["Escape"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["Id"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["MacroId"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["extern"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["pub"]
    //   GrammarItem* = GrammarItem* GrammarItem (*) ["use"]
    //
    //   "Id" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(111));)
    //   "MacroId" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(111));)
    //   "Escape" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(111));)
    //   "pub" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(111));)
    //   "use" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(111));)
    //   "extern" -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(111));)
    //   EOF -> Reduce(GrammarItem* = GrammarItem*, GrammarItem => Call(ActionFn(111));)
    //
    pub fn __state53<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<GrammarItem>>,
        __sym1: &mut Option<GrammarItem>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action111(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action111(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action111(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt)));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action111(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action111(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action111(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action111(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::GrammarItem_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 54
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S65
    //   Comma<TypeRefOrLifetime> -> S64
    pub fn __state54<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state64(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 55
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [")"]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //
    //   ")" -> Shift(S66)
    //
    pub fn __state55<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state66(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 56
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["&"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["("]
    //   (<TypeRef> ",") = (*) TypeRef "," [")"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["::"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Escape"]
    //   (<TypeRef> ",") = (*) TypeRef "," ["Id"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (*) (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (<TypeRef> ",")* (*) TypeRef? [")"]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" [","]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Escape [")"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef? = (*) [")"]
    //   TypeRef? = (*) TypeRef [")"]
    //
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "&" -> Shift(S44)
    //   "::" -> Shift(S41)
    //   "(" -> Shift(S39)
    //   "Escape" -> Shift(S40)
    //   ")" -> Reduce(TypeRef? =  => Call(ActionFn(141));)
    //
    //   (<TypeRef> ",") -> S68
    //   "::"? -> S42
    //   TypeRef? -> S67
    //   Escape -> S43
    //   TypeRef -> S69
    //   Path -> S38
    pub fn __state56<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action141(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state68(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state42(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state67(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state69(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 57
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [")"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //
    //   "Id" -> Shift(S71)
    //
    //   (<Id> "::") -> S70
    //   Id -> S72
    pub fn __state57<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state71(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state72(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 58
    //   Lifetime = "Lifetime" (*) ["&"]
    //   Lifetime = "Lifetime" (*) ["("]
    //   Lifetime = "Lifetime" (*) ["::"]
    //   Lifetime = "Lifetime" (*) ["Escape"]
    //   Lifetime = "Lifetime" (*) ["Id"]
    //   Lifetime = "Lifetime" (*) ["mut"]
    //
    //   "::" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "mut" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "(" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "Escape" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "&" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "Id" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //
    pub fn __state58<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 59
    //   Lifetime? = Lifetime (*) ["&"]
    //   Lifetime? = Lifetime (*) ["("]
    //   Lifetime? = Lifetime (*) ["::"]
    //   Lifetime? = Lifetime (*) ["Escape"]
    //   Lifetime? = Lifetime (*) ["Id"]
    //   Lifetime? = Lifetime (*) ["mut"]
    //
    //   "Escape" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "(" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "mut" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "Id" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "&" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //   "::" -> Reduce(Lifetime? = Lifetime => Call(ActionFn(89));)
    //
    pub fn __state59<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action89(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 60
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Escape"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Escape"]
    //   "mut"? = (*) "mut" ["Id"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [")"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Escape" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "mut" -> Shift(S74)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //
    //   "mut"? -> S73
    pub fn __state60<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state73(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 61
    //   Id = (*) "Id" [":"]
    //   Id = (*) "Id" ["="]
    //   MacroId = (*) "MacroId" ["<"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? @L (*) NonterminalName @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //   NonterminalId = (*) Id [":"]
    //   NonterminalId = (*) Id ["="]
    //   NonterminalName = (*) MacroId "<" Comma<NonterminalId> ">" [":"]
    //   NonterminalName = (*) MacroId "<" Comma<NonterminalId> ">" ["="]
    //   NonterminalName = (*) NonterminalId [":"]
    //   NonterminalName = (*) NonterminalId ["="]
    //   NonterminalName = (*) "Escape" [":"]
    //   NonterminalName = (*) "Escape" ["="]
    //
    //   "Escape" -> Shift(S75)
    //   "Id" -> Shift(S80)
    //   "MacroId" -> Shift(S78)
    //
    //   MacroId -> S77
    //   NonterminalName -> S76
    //   Id -> S79
    //   NonterminalId -> S81
    pub fn __state61<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state75(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state80(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::MacroId(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state77(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::NonterminalName(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state76(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state79(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state81(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 62
    //   Use = "use" ";" (*) [EOF]
    //   Use = "use" ";" (*) ["Escape"]
    //   Use = "use" ";" (*) ["Id"]
    //   Use = "use" ";" (*) ["MacroId"]
    //   Use = "use" ";" (*) ["extern"]
    //   Use = "use" ";" (*) ["pub"]
    //   Use = "use" ";" (*) ["use"]
    //
    //   "MacroId" -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //   "extern" -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //   "pub" -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //   "Id" -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //   "use" -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //   EOF -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //   "Escape" -> Reduce(Use = "use", ";" => Call(ActionFn(11));)
    //
    pub fn __state62<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action11(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Use(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 63
    //   ExternToken = @L "extern" (*) "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" (*) "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" (*) "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" (*) "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" (*) "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" (*) "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" (*) "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "token" -> Shift(S82)
    //
    pub fn __state63<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Token(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state82(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 64
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //
    //   ">" -> Shift(S83)
    //
    pub fn __state64<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state83(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 65
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["&"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["("]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["::"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," [">"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Escape"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = (*) TypeRefOrLifetime "," ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (*) (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* (*) TypeRefOrLifetime? [">"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Lifetime = (*) "Lifetime" [","]
    //   Lifetime = (*) "Lifetime" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Escape [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //   TypeRefOrLifetime = (*) Lifetime [","]
    //   TypeRefOrLifetime = (*) Lifetime [">"]
    //   TypeRefOrLifetime = (*) TypeRef [","]
    //   TypeRefOrLifetime = (*) TypeRef [">"]
    //   TypeRefOrLifetime? = (*) [">"]
    //   TypeRefOrLifetime? = (*) TypeRefOrLifetime [">"]
    //
    //   "Lifetime" -> Shift(S85)
    //   "Escape" -> Shift(S88)
    //   "&" -> Shift(S94)
    //   "::" -> Shift(S41)
    //   "(" -> Shift(S86)
    //   ">" -> Reduce(TypeRefOrLifetime? =  => Call(ActionFn(146));)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //
    //   (<TypeRefOrLifetime> ",") -> S91
    //   Escape -> S93
    //   TypeRefOrLifetime? -> S90
    //   Path -> S89
    //   Lifetime -> S92
    //   TypeRef -> S84
    //   TypeRefOrLifetime -> S87
    //   "::"? -> S95
    pub fn __state65<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state85(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state88(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state94(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state86(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action146(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state91(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state93(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRefOrLifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state90(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state89(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state92(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state84(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRefOrLifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state87(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state95(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 66
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [")"]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //
    //   ")" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //
    pub fn __state66<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 67
    //   Comma<TypeRef> = (<TypeRef> ",")* TypeRef? (*) [")"]
    //
    //   ")" -> Reduce(Comma<TypeRef> = (<TypeRef> ",")*, TypeRef? => Call(ActionFn(91));)
    //
    pub fn __state67<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action91(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRef_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 68
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["&"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["("]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) [")"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["::"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Escape"]
    //   (<TypeRef> ",")* = (<TypeRef> ",")* (<TypeRef> ",") (*) ["Id"]
    //
    //   ")" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "&" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "(" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "::" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "Escape" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //   "Id" -> Reduce((<TypeRef> ",")* = (<TypeRef> ",")*, (<TypeRef> ",") => Call(ActionFn(143));)
    //
    pub fn __state68<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action143(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 69
    //   (<TypeRef> ",") = TypeRef (*) "," ["&"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["("]
    //   (<TypeRef> ",") = TypeRef (*) "," [")"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["::"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Escape"]
    //   (<TypeRef> ",") = TypeRef (*) "," ["Id"]
    //   TypeRef? = TypeRef (*) [")"]
    //
    //   ")" -> Reduce(TypeRef? = TypeRef => Call(ActionFn(140));)
    //   "," -> Shift(S96)
    //
    pub fn __state69<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state96(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action140(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 70
    //   (<Id> "::")* = (<Id> "::")* (<Id> "::") (*) ["Id"]
    //
    //   "Id" -> Reduce((<Id> "::")* = (<Id> "::")*, (<Id> "::") => Call(ActionFn(82));)
    //
    pub fn __state70<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<InternedString>>,
        __sym1: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action82(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 71
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state71<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 72
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) [")"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //
    //   ")" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S97)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state72<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state97(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 73
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" [","]
    //   Path = (*) "::"? (<Id> "::")* Id [")"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Escape [")"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Path [")"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [")"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [")"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [")"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [")"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //
    //   "(" -> Shift(S39)
    //   "Escape" -> Shift(S40)
    //   "&" -> Shift(S44)
    //   "::" -> Shift(S41)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //
    //   Escape -> S43
    //   TypeRef -> S98
    //   Path -> S38
    //   "::"? -> S42
    pub fn __state73<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state39(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state40(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state44(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state43(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state98(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state38(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state42(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 74
    //   "mut"? = "mut" (*) ["&"]
    //   "mut"? = "mut" (*) ["("]
    //   "mut"? = "mut" (*) ["::"]
    //   "mut"? = "mut" (*) ["Escape"]
    //   "mut"? = "mut" (*) ["Id"]
    //
    //   "::" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //   "Escape" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //   "(" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //   "Id" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //   "&" -> Reduce("mut"? = "mut" => Call(ActionFn(87));)
    //
    pub fn __state74<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action87(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 75
    //   NonterminalName = "Escape" (*) [":"]
    //   NonterminalName = "Escape" (*) ["="]
    //
    //   "=" -> Reduce(NonterminalName = "Escape" => Call(ActionFn(15));)
    //   ":" -> Reduce(NonterminalName = "Escape" => Call(ActionFn(15));)
    //
    pub fn __state75<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action15(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action15(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 76
    //   @R = (*) [":"]
    //   @R = (*) ["="]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName (*) @R (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   ":" -> Reduce(@R =  => Lookbehind;)
    //   "=" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S99
    pub fn __state76<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Equals(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state99(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 77
    //   NonterminalName = MacroId (*) "<" Comma<NonterminalId> ">" [":"]
    //   NonterminalName = MacroId (*) "<" Comma<NonterminalId> ">" ["="]
    //
    //   "<" -> Shift(S100)
    //
    pub fn __state77<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state100(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 78
    //   MacroId = "MacroId" (*) ["<"]
    //
    //   "<" -> Reduce(MacroId = "MacroId" => Call(ActionFn(65));)
    //
    pub fn __state78<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action65(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::MacroId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 79
    //   NonterminalId = Id (*) [":"]
    //   NonterminalId = Id (*) ["="]
    //
    //   "=" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ":" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state79<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 80
    //   Id = "Id" (*) [":"]
    //   Id = "Id" (*) ["="]
    //
    //   "=" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state80<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 81
    //   NonterminalName = NonterminalId (*) [":"]
    //   NonterminalName = NonterminalId (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = NonterminalId => Call(ActionFn(14));)
    //   "=" -> Reduce(NonterminalName = NonterminalId => Call(ActionFn(14));)
    //
    pub fn __state81<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action14(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action14(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 82
    //   @R = (*) ["{"]
    //   ExternToken = @L "extern" "token" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" (*) @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "{" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S101
    pub fn __state82<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state101(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 83
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [")"]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //
    //   ")" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //
    pub fn __state83<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 84
    //   TypeRefOrLifetime = TypeRef (*) [","]
    //   TypeRefOrLifetime = TypeRef (*) [">"]
    //
    //   "," -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(49));)
    //   ">" -> Reduce(TypeRefOrLifetime = TypeRef => Call(ActionFn(49));)
    //
    pub fn __state84<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action49(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action49(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 85
    //   Lifetime = "Lifetime" (*) [","]
    //   Lifetime = "Lifetime" (*) [">"]
    //
    //   ">" -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //   "," -> Reduce(Lifetime = "Lifetime" => Call(ActionFn(69));)
    //
    pub fn __state85<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action69(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Lifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 86
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [","]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [">"]
    //
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   (<TypeRef> ",")* -> S56
    //   Comma<TypeRef> -> S102
    pub fn __state86<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state102(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 87
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Escape"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime (*) "," ["Lifetime"]
    //   TypeRefOrLifetime? = TypeRefOrLifetime (*) [">"]
    //
    //   ">" -> Reduce(TypeRefOrLifetime? = TypeRefOrLifetime => Call(ActionFn(145));)
    //   "," -> Shift(S103)
    //
    pub fn __state87<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state103(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action145(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 88
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state88<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 89
    //   TypeRef = Path (*) [","]
    //   TypeRef = Path (*) [">"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "," -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //   ">" -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //   "<" -> Shift(S104)
    //
    pub fn __state89<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state104(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 90
    //   Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? (*) [">"]
    //
    //   ">" -> Reduce(Comma<TypeRefOrLifetime> = (<TypeRefOrLifetime> ",")*, TypeRefOrLifetime? => Call(ActionFn(86));)
    //
    pub fn __state90<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action86(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 91
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") (*) ["Lifetime"]
    //
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* = (<TypeRefOrLifetime> ",")*, (<TypeRefOrLifetime> ",") => Call(ActionFn(148));)
    //
    pub fn __state91<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<TypeRef>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action148(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 92
    //   TypeRefOrLifetime = Lifetime (*) [","]
    //   TypeRefOrLifetime = Lifetime (*) [">"]
    //
    //   ">" -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(50));)
    //   "," -> Reduce(TypeRefOrLifetime = Lifetime => Call(ActionFn(50));)
    //
    pub fn __state92<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action50(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action50(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRefOrLifetime(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 93
    //   TypeRef = Escape (*) [","]
    //   TypeRef = Escape (*) [">"]
    //
    //   "," -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //   ">" -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //
    pub fn __state93<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 94
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Escape"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Escape"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Escape"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [","]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [">"]
    //
    //   "Escape" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Lifetime" -> Shift(S58)
    //
    //   Lifetime? -> S105
    //   Lifetime -> S59
    pub fn __state94<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state105(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 95
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id [","]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id [">"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S106
    pub fn __state95<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state106(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 96
    //   (<TypeRef> ",") = TypeRef "," (*) ["&"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["("]
    //   (<TypeRef> ",") = TypeRef "," (*) [")"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["::"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Escape"]
    //   (<TypeRef> ",") = TypeRef "," (*) ["Id"]
    //
    //   "Id" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   "(" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   "&" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   ")" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   "::" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //   "Escape" -> Reduce((<TypeRef> ",") = TypeRef, "," => Call(ActionFn(144));)
    //
    pub fn __state96<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action144(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 97
    //   (<Id> "::") = Id "::" (*) ["Id"]
    //
    //   "Id" -> Reduce((<Id> "::") = Id, "::" => Call(ActionFn(83));)
    //
    pub fn __state97<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action83(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 98
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [")"]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //   ")" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //
    pub fn __state98<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 99
    //   (":" <TypeRef>) = (*) ":" TypeRef ["="]
    //   (":" <TypeRef>)? = (*) ["="]
    //   (":" <TypeRef>)? = (*) (":" <TypeRef>) ["="]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives [EOF]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName @R (*) (":" <TypeRef>)? "=" Alternatives ["use"]
    //
    //   "=" -> Reduce((":" <TypeRef>)? =  => Call(ActionFn(104));)
    //   ":" -> Shift(S107)
    //
    //   (":" <TypeRef>)? -> S108
    //   (":" <TypeRef>) -> S109
    pub fn __state99<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state107(text, __lookbehind, __lookahead, __tokens, __sym4));
            }
            Some((_, Tok::Equals(..), _)) => {
                let __nt = super::__action104(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state108(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state109(text, __lookbehind, __lookahead, __tokens, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 100
    //   (<NonterminalId> ",")* = (*) [">"]
    //   (<NonterminalId> ",")* = (*) ["Id"]
    //   (<NonterminalId> ",")* = (*) (<NonterminalId> ",")* (<NonterminalId> ",") [">"]
    //   (<NonterminalId> ",")* = (*) (<NonterminalId> ",")* (<NonterminalId> ",") ["Id"]
    //   Comma<NonterminalId> = (*) (<NonterminalId> ",")* NonterminalId? [">"]
    //   NonterminalName = MacroId "<" (*) Comma<NonterminalId> ">" [":"]
    //   NonterminalName = MacroId "<" (*) Comma<NonterminalId> ">" ["="]
    //
    //   "Id" -> Reduce((<NonterminalId> ",")* =  => Call(ActionFn(132));)
    //   ">" -> Reduce((<NonterminalId> ",")* =  => Call(ActionFn(132));)
    //
    //   (<NonterminalId> ",")* -> S110
    //   Comma<NonterminalId> -> S111
    pub fn __state100<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action132(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cNonterminalId_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action132(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cNonterminalId_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cNonterminalId_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state110(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cNonterminalId_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state111(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 101
    //   ExternToken = @L "extern" "token" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R (*) "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "{" -> Shift(S112)
    //
    pub fn __state101<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state112(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 102
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [","]
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [">"]
    //
    //   ")" -> Shift(S113)
    //
    pub fn __state102<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state113(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 103
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["&"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["("]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["::"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) [">"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Id"]
    //   (<TypeRefOrLifetime> ",") = TypeRefOrLifetime "," (*) ["Lifetime"]
    //
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",") = TypeRefOrLifetime, "," => Call(ActionFn(149));)
    //
    pub fn __state103<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action149(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 104
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [">"]
    //
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S65
    //   Comma<TypeRefOrLifetime> -> S114
    pub fn __state104<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state114(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 105
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Escape"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Escape"]
    //   "mut"? = (*) "mut" ["Id"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [","]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [">"]
    //
    //   "mut" -> Shift(S74)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Escape" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //
    //   "mut"? -> S115
    pub fn __state105<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state115(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 106
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" [">"]
    //   Path = "::"? (<Id> "::")* (*) Id [","]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [">"]
    //
    //   "Id" -> Shift(S117)
    //
    //   Id -> S116
    //   (<Id> "::") -> S70
    pub fn __state106<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state117(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state116(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 107
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   (":" <TypeRef>) = ":" (*) TypeRef ["="]
    //   Escape = (*) "Escape" ["="]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["="]
    //   TypeRef = (*) Escape ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //
    //   "(" -> Shift(S124)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "Escape" -> Shift(S120)
    //   "&" -> Shift(S122)
    //   "::" -> Shift(S41)
    //
    //   "::"? -> S118
    //   Escape -> S119
    //   TypeRef -> S121
    //   Path -> S123
    pub fn __state107<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state124(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state120(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state122(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state118(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state119(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state121(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state123(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 108
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives [EOF]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? (*) "=" Alternatives ["use"]
    //
    //   "=" -> Shift(S125)
    //
    pub fn __state108<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Equals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state125(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 109
    //   (":" <TypeRef>)? = (":" <TypeRef>) (*) ["="]
    //
    //   "=" -> Reduce((":" <TypeRef>)? = (":" <TypeRef>) => Call(ActionFn(103));)
    //
    pub fn __state109<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action103(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 110
    //   (<NonterminalId> ",") = (*) NonterminalId "," [">"]
    //   (<NonterminalId> ",") = (*) NonterminalId "," ["Id"]
    //   (<NonterminalId> ",")* = (<NonterminalId> ",")* (*) (<NonterminalId> ",") [">"]
    //   (<NonterminalId> ",")* = (<NonterminalId> ",")* (*) (<NonterminalId> ",") ["Id"]
    //   Comma<NonterminalId> = (<NonterminalId> ",")* (*) NonterminalId? [">"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" [">"]
    //   NonterminalId = (*) Id [","]
    //   NonterminalId = (*) Id [">"]
    //   NonterminalId? = (*) [">"]
    //   NonterminalId? = (*) NonterminalId [">"]
    //
    //   ">" -> Reduce(NonterminalId? =  => Call(ActionFn(131));)
    //   "Id" -> Shift(S129)
    //
    //   NonterminalId? -> S127
    //   Id -> S128
    //   (<NonterminalId> ",") -> S130
    //   NonterminalId -> S126
    pub fn __state110<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state129(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action131(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::NonterminalId_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::NonterminalId_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state127(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state128(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cNonterminalId_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state130(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state126(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 111
    //   NonterminalName = MacroId "<" Comma<NonterminalId> (*) ">" [":"]
    //   NonterminalName = MacroId "<" Comma<NonterminalId> (*) ">" ["="]
    //
    //   ">" -> Shift(S131)
    //
    pub fn __state111<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state131(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 112
    //   AssociatedType* = (*) ["enum"]
    //   AssociatedType* = (*) ["type"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["enum"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["type"]
    //   ExternToken = @L "extern" "token" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" (*) AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "type" -> Reduce(AssociatedType* =  => Call(ActionFn(79));)
    //   "enum" -> Reduce(AssociatedType* =  => Call(ActionFn(79));)
    //
    //   AssociatedType* -> S132
    pub fn __state112<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Type(..), _)) => {
                let __nt = super::__action79(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt));
            }
            Some((_, Tok::Enum(..), _)) => {
                let __nt = super::__action79(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AssociatedType_2a(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state132(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 113
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [","]
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //   "," -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //
    pub fn __state113<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 114
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [">"]
    //
    //   ">" -> Shift(S133)
    //
    pub fn __state114<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state133(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 115
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Path = (*) "::"? (<Id> "::")* Id [","]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id [">"]
    //   TypeRef = (*) Escape [","]
    //   TypeRef = (*) Escape [">"]
    //   TypeRef = (*) Path [","]
    //   TypeRef = (*) Path [">"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [","]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [">"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [","]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [">"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [","]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [">"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [","]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [">"]
    //
    //   "(" -> Shift(S86)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "Escape" -> Shift(S88)
    //   "::" -> Shift(S41)
    //   "&" -> Shift(S94)
    //
    //   Escape -> S93
    //   Path -> S89
    //   "::"? -> S95
    //   TypeRef -> S134
    pub fn __state115<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state86(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state88(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state94(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state93(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state89(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state95(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state134(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 116
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) [","]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) [">"]
    //
    //   ">" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S97)
    //   "," -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state116<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state97(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 117
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) [">"]
    //
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state117<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 118
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id ["="]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S135
    pub fn __state118<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state135(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 119
    //   TypeRef = Escape (*) ["="]
    //
    //   "=" -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //
    pub fn __state119<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 120
    //   Escape = "Escape" (*) ["="]
    //
    //   "=" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state120<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 121
    //   (":" <TypeRef>) = ":" TypeRef (*) ["="]
    //
    //   "=" -> Reduce((":" <TypeRef>) = ":", TypeRef => Call(ActionFn(105));)
    //
    pub fn __state121<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action105(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22_3a_22_20_3cTypeRef_3e_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 122
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Escape"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Escape"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Escape"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef ["="]
    //
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Lifetime" -> Shift(S58)
    //   "Escape" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //
    //   Lifetime? -> S136
    //   Lifetime -> S59
    pub fn __state122<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state136(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 123
    //   TypeRef = Path (*) ["="]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" ["="]
    //
    //   "=" -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //   "<" -> Shift(S137)
    //
    pub fn __state123<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state137(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 124
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" ["="]
    //
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   (<TypeRef> ",")* -> S56
    //   Comma<TypeRef> -> S138
    pub fn __state124<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state138(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 125
    //   @L = (*) ["("]
    //   @L = (*) [";"]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R [EOF]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["extern"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["pub"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["use"]
    //   Alternatives = (*) Alternative [EOF]
    //   Alternatives = (*) Alternative ["Escape"]
    //   Alternatives = (*) Alternative ["Id"]
    //   Alternatives = (*) Alternative ["MacroId"]
    //   Alternatives = (*) Alternative ["extern"]
    //   Alternatives = (*) Alternative ["pub"]
    //   Alternatives = (*) Alternative ["use"]
    //   Alternatives = (*) "{" Alternative* "}" ";" [EOF]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["Escape"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["Id"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["MacroId"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["extern"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["pub"]
    //   Alternatives = (*) "{" Alternative* "}" ";" ["use"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives [EOF]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" (*) Alternatives ["use"]
    //
    //   "=>?" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   ";" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Reduce(@L =  => Lookahead;)
    //   "{" -> Shift(S140)
    //   "=>" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S139
    //   Alternative -> S141
    //   Alternatives -> S142
    pub fn __state125<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<TypeRef>>,
        __sym5: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state140(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state139(text, __lookbehind, __lookahead, __tokens, __sym6));
                }
                __Nonterminal::Alternative(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state141(text, __lookbehind, __lookahead, __tokens, __sym6));
                }
                __Nonterminal::Alternatives(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state142(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 126
    //   (<NonterminalId> ",") = NonterminalId (*) "," [">"]
    //   (<NonterminalId> ",") = NonterminalId (*) "," ["Id"]
    //   NonterminalId? = NonterminalId (*) [">"]
    //
    //   ">" -> Reduce(NonterminalId? = NonterminalId => Call(ActionFn(130));)
    //   "," -> Shift(S143)
    //
    pub fn __state126<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state143(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action130(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 127
    //   Comma<NonterminalId> = (<NonterminalId> ",")* NonterminalId? (*) [">"]
    //
    //   ">" -> Reduce(Comma<NonterminalId> = (<NonterminalId> ",")*, NonterminalId? => Call(ActionFn(102));)
    //
    pub fn __state127<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
        __sym1: &mut Option<::std::option::Option<NonterminalString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action102(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cNonterminalId_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 128
    //   NonterminalId = Id (*) [","]
    //   NonterminalId = Id (*) [">"]
    //
    //   "," -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ">" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state128<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 129
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) [">"]
    //
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state129<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 130
    //   (<NonterminalId> ",")* = (<NonterminalId> ",")* (<NonterminalId> ",") (*) [">"]
    //   (<NonterminalId> ",")* = (<NonterminalId> ",")* (<NonterminalId> ",") (*) ["Id"]
    //
    //   "Id" -> Reduce((<NonterminalId> ",")* = (<NonterminalId> ",")*, (<NonterminalId> ",") => Call(ActionFn(133));)
    //   ">" -> Reduce((<NonterminalId> ",")* = (<NonterminalId> ",")*, (<NonterminalId> ",") => Call(ActionFn(133));)
    //
    pub fn __state130<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<NonterminalString>>,
        __sym1: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action133(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cNonterminalId_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action133(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cNonterminalId_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 131
    //   NonterminalName = MacroId "<" Comma<NonterminalId> ">" (*) [":"]
    //   NonterminalName = MacroId "<" Comma<NonterminalId> ">" (*) ["="]
    //
    //   ":" -> Reduce(NonterminalName = MacroId, "<", Comma<NonterminalId>, ">" => Call(ActionFn(13));)
    //   "=" -> Reduce(NonterminalName = MacroId, "<", Comma<NonterminalId>, ">" => Call(ActionFn(13));)
    //
    pub fn __state131<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<NonterminalString>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action13(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action13(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalName(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 132
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["enum"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["type"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* (*) "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "enum" -> Shift(S144)
    //   "type" -> Shift(S145)
    //
    //   AssociatedType -> S146
    pub fn __state132<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Enum(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state144(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            Some((_, __tok @ Tok::Type(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state145(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AssociatedType(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state146(text, __lookbehind, __lookahead, __tokens, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 133
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [","]
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [">"]
    //
    //   "," -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //   ">" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //
    pub fn __state133<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 134
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [","]
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [">"]
    //
    //   ">" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //   "," -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //
    pub fn __state134<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 135
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["="]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id ["="]
    //
    //   "Id" -> Shift(S147)
    //
    //   (<Id> "::") -> S70
    //   Id -> S148
    pub fn __state135<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state147(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state148(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 136
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Escape"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Escape"]
    //   "mut"? = (*) "mut" ["Id"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef ["="]
    //
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Escape" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "mut" -> Shift(S74)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //
    //   "mut"? -> S149
    pub fn __state136<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state149(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 137
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" ["="]
    //
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S65
    //   Comma<TypeRefOrLifetime> -> S150
    pub fn __state137<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state150(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 138
    //   TypeRef = "(" Comma<TypeRef> (*) ")" ["="]
    //
    //   ")" -> Shift(S151)
    //
    pub fn __state138<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state151(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 139
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R [EOF]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["extern"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["pub"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["use"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [";"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["=>"]
    //   Symbol* = (*) ["=>?"]
    //   Symbol* = (*) ["=>@L"]
    //   Symbol* = (*) ["=>@R"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) ["if"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [";"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["=>"]
    //   Symbol* = (*) Symbol* Symbol ["=>?"]
    //   Symbol* = (*) Symbol* Symbol ["=>@L"]
    //   Symbol* = (*) Symbol* Symbol ["=>@R"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["if"]
    //
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "=>@R" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "if" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "=>" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "=>?" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   ";" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "=>@L" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //
    //   Symbol* -> S152
    pub fn __state139<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state152(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 140
    //   Alternative* = (*) ["("]
    //   Alternative* = (*) [";"]
    //   Alternative* = (*) ["<"]
    //   Alternative* = (*) ["=>"]
    //   Alternative* = (*) ["=>?"]
    //   Alternative* = (*) ["=>@L"]
    //   Alternative* = (*) ["=>@R"]
    //   Alternative* = (*) ["@L"]
    //   Alternative* = (*) ["@R"]
    //   Alternative* = (*) ["Escape"]
    //   Alternative* = (*) ["Id"]
    //   Alternative* = (*) ["MacroId"]
    //   Alternative* = (*) ["StringLiteral"]
    //   Alternative* = (*) ["if"]
    //   Alternative* = (*) ["}"]
    //   Alternative* = (*) Alternative* Alternative ["("]
    //   Alternative* = (*) Alternative* Alternative [";"]
    //   Alternative* = (*) Alternative* Alternative ["<"]
    //   Alternative* = (*) Alternative* Alternative ["=>"]
    //   Alternative* = (*) Alternative* Alternative ["=>?"]
    //   Alternative* = (*) Alternative* Alternative ["=>@L"]
    //   Alternative* = (*) Alternative* Alternative ["=>@R"]
    //   Alternative* = (*) Alternative* Alternative ["@L"]
    //   Alternative* = (*) Alternative* Alternative ["@R"]
    //   Alternative* = (*) Alternative* Alternative ["Escape"]
    //   Alternative* = (*) Alternative* Alternative ["Id"]
    //   Alternative* = (*) Alternative* Alternative ["MacroId"]
    //   Alternative* = (*) Alternative* Alternative ["StringLiteral"]
    //   Alternative* = (*) Alternative* Alternative ["if"]
    //   Alternative* = (*) Alternative* Alternative ["}"]
    //   Alternatives = "{" (*) Alternative* "}" ";" [EOF]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["Escape"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["Id"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["MacroId"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["extern"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["pub"]
    //   Alternatives = "{" (*) Alternative* "}" ";" ["use"]
    //
    //   "<" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "if" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "=>?" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "@L" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "MacroId" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "=>@L" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "=>@R" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   ";" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "=>" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "(" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "Id" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "StringLiteral" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "@R" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "}" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //   "Escape" -> Reduce(Alternative* =  => Call(ActionFn(100));)
    //
    //   Alternative* -> S153
    pub fn __state140<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action100(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Alternative_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state153(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 141
    //   Alternatives = Alternative (*) [EOF]
    //   Alternatives = Alternative (*) ["Escape"]
    //   Alternatives = Alternative (*) ["Id"]
    //   Alternatives = Alternative (*) ["MacroId"]
    //   Alternatives = Alternative (*) ["extern"]
    //   Alternatives = Alternative (*) ["pub"]
    //   Alternatives = Alternative (*) ["use"]
    //
    //   EOF -> Reduce(Alternatives = Alternative => Call(ActionFn(16));)
    //   "Escape" -> Reduce(Alternatives = Alternative => Call(ActionFn(16));)
    //   "pub" -> Reduce(Alternatives = Alternative => Call(ActionFn(16));)
    //   "use" -> Reduce(Alternatives = Alternative => Call(ActionFn(16));)
    //   "Id" -> Reduce(Alternatives = Alternative => Call(ActionFn(16));)
    //   "extern" -> Reduce(Alternatives = Alternative => Call(ActionFn(16));)
    //   "MacroId" -> Reduce(Alternatives = Alternative => Call(ActionFn(16));)
    //
    pub fn __state141<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action16(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action16(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action16(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action16(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action16(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action16(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action16(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 142
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) [EOF]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["Escape"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["Id"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["MacroId"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["extern"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["pub"]
    //   Nonterminal = "pub"? @L NonterminalName @R (":" <TypeRef>)? "=" Alternatives (*) ["use"]
    //
    //   "pub" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(12));)
    //   "MacroId" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(12));)
    //   "extern" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(12));)
    //   "Id" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(12));)
    //   "use" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(12));)
    //   EOF -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(12));)
    //   "Escape" -> Reduce(Nonterminal = "pub"?, @L, NonterminalName, @R, (":" <TypeRef>)?, "=", Alternatives => Call(ActionFn(12));)
    //
    pub fn __state142<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<(NonterminalString, Vec<NonterminalString>)>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<::std::option::Option<TypeRef>>,
        __sym5: &mut Option<Tok<'input>>,
        __sym6: &mut Option<Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action12(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Nonterminal(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action12(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Nonterminal(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action12(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Nonterminal(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action12(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Nonterminal(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action12(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Nonterminal(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action12(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Nonterminal(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action12(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Nonterminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 143
    //   (<NonterminalId> ",") = NonterminalId "," (*) [">"]
    //   (<NonterminalId> ",") = NonterminalId "," (*) ["Id"]
    //
    //   ">" -> Reduce((<NonterminalId> ",") = NonterminalId, "," => Call(ActionFn(134));)
    //   "Id" -> Reduce((<NonterminalId> ",") = NonterminalId, "," => Call(ActionFn(134));)
    //
    pub fn __state143<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action134(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cNonterminalId_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action134(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cNonterminalId_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 144
    //   @L = (*) ["&"]
    //   @L = (*) ["("]
    //   @L = (*) ["::"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" (*) @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "&" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "::" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S154
    pub fn __state144<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state154(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 145
    //   @L = (*) ["Id"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["type"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S155
    pub fn __state145<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state155(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 146
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["enum"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["type"]
    //
    //   "enum" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(80));)
    //   "type" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(80));)
    //
    pub fn __state146<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym1: &mut Option<AssociatedType>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Enum(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action80(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt)));
            }
            Some((_, Tok::Type(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action80(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 147
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["="]
    //
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "=" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state147<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 148
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) ["="]
    //
    //   "::" -> Shift(S97)
    //   "=" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state148<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state97(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 149
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" ["="]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["="]
    //   TypeRef = (*) Escape ["="]
    //   TypeRef = (*) Path ["="]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["="]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["="]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef ["="]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["="]
    //
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "Escape" -> Shift(S120)
    //   "(" -> Shift(S124)
    //   "&" -> Shift(S122)
    //   "::" -> Shift(S41)
    //
    //   TypeRef -> S156
    //   "::"? -> S118
    //   Escape -> S119
    //   Path -> S123
    pub fn __state149<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state120(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state124(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state122(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state156(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state118(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state119(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state123(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 150
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" ["="]
    //
    //   ">" -> Shift(S157)
    //
    pub fn __state150<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state157(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 151
    //   TypeRef = "(" Comma<TypeRef> ")" (*) ["="]
    //
    //   "=" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //
    pub fn __state151<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 152
    //   ("if" <Cond>) = (*) "if" Cond [";"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) [";"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) [";"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R [EOF]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["extern"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["pub"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["use"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [";"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["=>"]
    //   Symbol* = Symbol* (*) Symbol ["=>?"]
    //   Symbol* = Symbol* (*) Symbol ["=>@L"]
    //   Symbol* = Symbol* (*) Symbol ["=>@R"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   "=>@R" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "=>" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "=>?" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   ";" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Shift(S158)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S164
    //   ("if" <Cond>) -> S161
    //   Symbol1 -> S162
    //   Symbol0 -> S160
    //   Symbol -> S159
    //   ("if" <Cond>)? -> S163
    pub fn __state152<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::If(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state158(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state164(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state161(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state162(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state160(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state159(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state163(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 153
    //   @L = (*) ["("]
    //   @L = (*) [";"]
    //   @L = (*) ["<"]
    //   @L = (*) ["=>"]
    //   @L = (*) ["=>?"]
    //   @L = (*) ["=>@L"]
    //   @L = (*) ["=>@R"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   @L = (*) ["if"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["("]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R [";"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["<"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["=>"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["=>?"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["=>@L"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["=>@R"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["@L"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["@R"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["StringLiteral"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["if"]
    //   Alternative = (*) @L Symbol* ("if" <Cond>)? Action? ";" @R ["}"]
    //   Alternative* = Alternative* (*) Alternative ["("]
    //   Alternative* = Alternative* (*) Alternative [";"]
    //   Alternative* = Alternative* (*) Alternative ["<"]
    //   Alternative* = Alternative* (*) Alternative ["=>"]
    //   Alternative* = Alternative* (*) Alternative ["=>?"]
    //   Alternative* = Alternative* (*) Alternative ["=>@L"]
    //   Alternative* = Alternative* (*) Alternative ["=>@R"]
    //   Alternative* = Alternative* (*) Alternative ["@L"]
    //   Alternative* = Alternative* (*) Alternative ["@R"]
    //   Alternative* = Alternative* (*) Alternative ["Escape"]
    //   Alternative* = Alternative* (*) Alternative ["Id"]
    //   Alternative* = Alternative* (*) Alternative ["MacroId"]
    //   Alternative* = Alternative* (*) Alternative ["StringLiteral"]
    //   Alternative* = Alternative* (*) Alternative ["if"]
    //   Alternative* = Alternative* (*) Alternative ["}"]
    //   Alternatives = "{" Alternative* (*) "}" ";" [EOF]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["Escape"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["Id"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["MacroId"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["extern"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["pub"]
    //   Alternatives = "{" Alternative* (*) "}" ";" ["use"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "}" -> Shift(S167)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   ";" -> Reduce(@L =  => Lookahead;)
    //   "=>?" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "=>" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S165
    //   Alternative -> S166
    pub fn __state153<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Alternative>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state167(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state165(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Alternative(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state166(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 154
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" ["{"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L (*) TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   TypeRef = (*) Escape ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //
    //   "Escape" -> Shift(S168)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "(" -> Shift(S172)
    //   "&" -> Shift(S169)
    //   "::" -> Shift(S41)
    //
    //   Escape -> S174
    //   "::"? -> S170
    //   TypeRef -> S173
    //   Path -> S171
    pub fn __state154<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym8 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state168(text, __lookbehind, __lookahead, __tokens, __sym8));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym8 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state172(text, __lookbehind, __lookahead, __tokens, __sym8));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym8 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state169(text, __lookbehind, __lookahead, __tokens, __sym8));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym8 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym8));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym7.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym8 = &mut Some(__nt);
                    __result = try!(__state174(text, __lookbehind, __lookahead, __tokens, __sym8));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym8 = &mut Some(__nt);
                    __result = try!(__state170(text, __lookbehind, __lookahead, __tokens, __sym8));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym8 = &mut Some(__nt);
                    __result = try!(__state173(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym8 = &mut Some(__nt);
                    __result = try!(__state171(text, __lookbehind, __lookahead, __tokens, __sym8));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 155
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["type"]
    //   Id = (*) "Id" ["="]
    //
    //   "Id" -> Shift(S176)
    //
    //   Id -> S175
    pub fn __state155<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state176(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state175(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 156
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) ["="]
    //
    //   "=" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //
    pub fn __state156<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 157
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) ["="]
    //
    //   "=" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //
    pub fn __state157<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 158
    //   ("if" <Cond>) = "if" (*) Cond [";"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>?"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@L"]
    //   ("if" <Cond>) = "if" (*) Cond ["=>@R"]
    //   @L = (*) ["Id"]
    //   Cond = (*) @L NonterminalId CondOp "StringLiteral" @R [";"]
    //   Cond = (*) @L NonterminalId CondOp "StringLiteral" @R ["=>"]
    //   Cond = (*) @L NonterminalId CondOp "StringLiteral" @R ["=>?"]
    //   Cond = (*) @L NonterminalId CondOp "StringLiteral" @R ["=>@L"]
    //   Cond = (*) @L NonterminalId CondOp "StringLiteral" @R ["=>@R"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S178
    //   Cond -> S177
    pub fn __state158<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state178(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Cond(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state177(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 159
    //   Symbol* = Symbol* Symbol (*) ["("]
    //   Symbol* = Symbol* Symbol (*) [";"]
    //   Symbol* = Symbol* Symbol (*) ["<"]
    //   Symbol* = Symbol* Symbol (*) ["=>"]
    //   Symbol* = Symbol* Symbol (*) ["=>?"]
    //   Symbol* = Symbol* Symbol (*) ["=>@L"]
    //   Symbol* = Symbol* Symbol (*) ["=>@R"]
    //   Symbol* = Symbol* Symbol (*) ["@L"]
    //   Symbol* = Symbol* Symbol (*) ["@R"]
    //   Symbol* = Symbol* Symbol (*) ["Escape"]
    //   Symbol* = Symbol* Symbol (*) ["Id"]
    //   Symbol* = Symbol* Symbol (*) ["MacroId"]
    //   Symbol* = Symbol* Symbol (*) ["StringLiteral"]
    //   Symbol* = Symbol* Symbol (*) ["if"]
    //
    //   "Escape" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "<" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "Id" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "=>@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "MacroId" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   ";" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "if" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "StringLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "(" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "=>@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "=>?" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "=>" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //
    pub fn __state159<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 160
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [";"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["=>"]
    //   RepeatOp = (*) "*" ["=>?"]
    //   RepeatOp = (*) "*" ["=>@L"]
    //   RepeatOp = (*) "*" ["=>@R"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "*" ["if"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [";"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["=>"]
    //   RepeatOp = (*) "+" ["=>?"]
    //   RepeatOp = (*) "+" ["=>@L"]
    //   RepeatOp = (*) "+" ["=>@R"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["if"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [";"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["=>"]
    //   RepeatOp = (*) "?" ["=>?"]
    //   RepeatOp = (*) "?" ["=>@L"]
    //   RepeatOp = (*) "?" ["=>@R"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["if"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [";"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["=>"]
    //   Symbol = Symbol0 (*) ["=>?"]
    //   Symbol = Symbol0 (*) ["=>@L"]
    //   Symbol = Symbol0 (*) ["=>@R"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [";"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["=>@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["if"]
    //
    //   "=>?" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "+" -> Shift(S181)
    //   "(" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "if" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "Id" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "?" -> Shift(S180)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "*" -> Shift(S182)
    //   "=>@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "=>@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "Escape" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "<" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   ";" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "=>" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //
    //   RepeatOp -> S179
    pub fn __state160<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state181(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state180(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state182(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state179(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 161
    //   ("if" <Cond>)? = ("if" <Cond>) (*) [";"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>?"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@L"]
    //   ("if" <Cond>)? = ("if" <Cond>) (*) ["=>@R"]
    //
    //   "=>@R" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(95));)
    //   "=>" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(95));)
    //   ";" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(95));)
    //   "=>?" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(95));)
    //   "=>@L" -> Reduce(("if" <Cond>)? = ("if" <Cond>) => Call(ActionFn(95));)
    //
    pub fn __state161<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Condition>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action95(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action95(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action95(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action95(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action95(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 162
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [";"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["=>"]
    //   Symbol0 = Symbol1 (*) ["=>?"]
    //   Symbol0 = Symbol1 (*) ["=>@L"]
    //   Symbol0 = Symbol1 (*) ["=>@R"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //   Symbol0 = Symbol1 (*) ["if"]
    //
    //   "<" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   ";" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "=>@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "(" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "Id" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "if" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "=>?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "=>" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "=>@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //
    pub fn __state162<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 163
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Action? = (*) [";"]
    //   Action? = (*) Action [";"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R [EOF]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["Escape"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["Id"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["MacroId"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["extern"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["pub"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["use"]
    //
    //   "=>@L" -> Shift(S187)
    //   "=>@R" -> Shift(S185)
    //   ";" -> Reduce(Action? =  => Call(ActionFn(94));)
    //   "=>" -> Shift(S188)
    //   "=>?" -> Shift(S183)
    //
    //   Action? -> S184
    //   Action -> S186
    pub fn __state163<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::EqualsGreaterThanLookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state187(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::EqualsGreaterThanLookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state185(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::EqualsGreaterThanCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state188(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state183(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action94(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Action_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Action_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state184(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Action(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state186(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 164
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [";"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["=>"]
    //   Escape = (*) "Escape" ["=>?"]
    //   Escape = (*) "Escape" ["=>@L"]
    //   Escape = (*) "Escape" ["=>@R"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   Escape = (*) "Escape" ["if"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" ["*"]
    //   Id = (*) "Id" ["+"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["=>"]
    //   Id = (*) "Id" ["=>?"]
    //   Id = (*) "Id" ["=>@L"]
    //   Id = (*) "Id" ["=>@R"]
    //   Id = (*) "Id" ["?"]
    //   Id = (*) "Id" ["@L"]
    //   Id = (*) "Id" ["@R"]
    //   Id = (*) "Id" ["Escape"]
    //   Id = (*) "Id" ["Id"]
    //   Id = (*) "Id" ["MacroId"]
    //   Id = (*) "Id" ["StringLiteral"]
    //   Id = (*) "Id" ["if"]
    //   MacroId = (*) "MacroId" ["<"]
    //   NonterminalId = (*) Id ["("]
    //   NonterminalId = (*) Id ["*"]
    //   NonterminalId = (*) Id ["+"]
    //   NonterminalId = (*) Id [";"]
    //   NonterminalId = (*) Id ["<"]
    //   NonterminalId = (*) Id ["=>"]
    //   NonterminalId = (*) Id ["=>?"]
    //   NonterminalId = (*) Id ["=>@L"]
    //   NonterminalId = (*) Id ["=>@R"]
    //   NonterminalId = (*) Id ["?"]
    //   NonterminalId = (*) Id ["@L"]
    //   NonterminalId = (*) Id ["@R"]
    //   NonterminalId = (*) Id ["Escape"]
    //   NonterminalId = (*) Id ["Id"]
    //   NonterminalId = (*) Id ["MacroId"]
    //   NonterminalId = (*) Id ["StringLiteral"]
    //   NonterminalId = (*) Id ["if"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [";"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   StringLiteral = (*) "StringLiteral" ["=>?"]
    //   StringLiteral = (*) "StringLiteral" ["=>@L"]
    //   StringLiteral = (*) "StringLiteral" ["=>@R"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["if"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [";"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [";"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["=>@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["if"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [";"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["=>"]
    //   SymbolKind1 = (*) Escape ["=>?"]
    //   SymbolKind1 = (*) Escape ["=>@L"]
    //   SymbolKind1 = (*) Escape ["=>@R"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["if"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [";"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["if"]
    //   SymbolKind1 = (*) NonterminalId ["("]
    //   SymbolKind1 = (*) NonterminalId ["*"]
    //   SymbolKind1 = (*) NonterminalId ["+"]
    //   SymbolKind1 = (*) NonterminalId [";"]
    //   SymbolKind1 = (*) NonterminalId ["<"]
    //   SymbolKind1 = (*) NonterminalId ["=>"]
    //   SymbolKind1 = (*) NonterminalId ["=>?"]
    //   SymbolKind1 = (*) NonterminalId ["=>@L"]
    //   SymbolKind1 = (*) NonterminalId ["=>@R"]
    //   SymbolKind1 = (*) NonterminalId ["?"]
    //   SymbolKind1 = (*) NonterminalId ["@L"]
    //   SymbolKind1 = (*) NonterminalId ["@R"]
    //   SymbolKind1 = (*) NonterminalId ["Escape"]
    //   SymbolKind1 = (*) NonterminalId ["Id"]
    //   SymbolKind1 = (*) NonterminalId ["MacroId"]
    //   SymbolKind1 = (*) NonterminalId ["StringLiteral"]
    //   SymbolKind1 = (*) NonterminalId ["if"]
    //   SymbolKind1 = (*) Terminal ["("]
    //   SymbolKind1 = (*) Terminal ["*"]
    //   SymbolKind1 = (*) Terminal ["+"]
    //   SymbolKind1 = (*) Terminal [";"]
    //   SymbolKind1 = (*) Terminal ["<"]
    //   SymbolKind1 = (*) Terminal ["=>"]
    //   SymbolKind1 = (*) Terminal ["=>?"]
    //   SymbolKind1 = (*) Terminal ["=>@L"]
    //   SymbolKind1 = (*) Terminal ["=>@R"]
    //   SymbolKind1 = (*) Terminal ["?"]
    //   SymbolKind1 = (*) Terminal ["@L"]
    //   SymbolKind1 = (*) Terminal ["@R"]
    //   SymbolKind1 = (*) Terminal ["Escape"]
    //   SymbolKind1 = (*) Terminal ["Id"]
    //   SymbolKind1 = (*) Terminal ["MacroId"]
    //   SymbolKind1 = (*) Terminal ["StringLiteral"]
    //   SymbolKind1 = (*) Terminal ["if"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["("]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["*"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["+"]
    //   SymbolKind1 = (*) "(" Symbol* ")" [";"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["<"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["=>"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["=>?"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["=>@L"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["=>@R"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["?"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["@L"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["@R"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["Escape"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["Id"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["if"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [";"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["=>"]
    //   SymbolKind1 = (*) "@L" ["=>?"]
    //   SymbolKind1 = (*) "@L" ["=>@L"]
    //   SymbolKind1 = (*) "@L" ["=>@R"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["if"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [";"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["=>"]
    //   SymbolKind1 = (*) "@R" ["=>?"]
    //   SymbolKind1 = (*) "@R" ["=>@L"]
    //   SymbolKind1 = (*) "@R" ["=>@R"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["if"]
    //   Terminal = (*) StringLiteral ["("]
    //   Terminal = (*) StringLiteral ["*"]
    //   Terminal = (*) StringLiteral ["+"]
    //   Terminal = (*) StringLiteral [";"]
    //   Terminal = (*) StringLiteral ["<"]
    //   Terminal = (*) StringLiteral ["=>"]
    //   Terminal = (*) StringLiteral ["=>?"]
    //   Terminal = (*) StringLiteral ["=>@L"]
    //   Terminal = (*) StringLiteral ["=>@R"]
    //   Terminal = (*) StringLiteral ["?"]
    //   Terminal = (*) StringLiteral ["@L"]
    //   Terminal = (*) StringLiteral ["@R"]
    //   Terminal = (*) StringLiteral ["Escape"]
    //   Terminal = (*) StringLiteral ["Id"]
    //   Terminal = (*) StringLiteral ["MacroId"]
    //   Terminal = (*) StringLiteral ["StringLiteral"]
    //   Terminal = (*) StringLiteral ["if"]
    //
    //   "@L" -> Shift(S191)
    //   "(" -> Shift(S189)
    //   "<" -> Shift(S200)
    //   "Escape" -> Shift(S198)
    //   "MacroId" -> Shift(S78)
    //   "@R" -> Shift(S197)
    //   "Id" -> Shift(S193)
    //   "StringLiteral" -> Shift(S199)
    //
    //   SymbolKind1 -> S201
    //   Escape -> S202
    //   StringLiteral -> S190
    //   Id -> S196
    //   Terminal -> S192
    //   NonterminalId -> S194
    //   MacroId -> S195
    pub fn __state164<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state191(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state189(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state200(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state198(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state197(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state193(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state199(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state201(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state202(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state190(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state196(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Terminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state192(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state194(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state195(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 165
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["("]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R [";"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["<"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["=>"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["=>?"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["=>@L"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["=>@R"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["@L"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["@R"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["StringLiteral"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["if"]
    //   Alternative = @L (*) Symbol* ("if" <Cond>)? Action? ";" @R ["}"]
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [";"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["=>"]
    //   Symbol* = (*) ["=>?"]
    //   Symbol* = (*) ["=>@L"]
    //   Symbol* = (*) ["=>@R"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) ["if"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [";"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["=>"]
    //   Symbol* = (*) Symbol* Symbol ["=>?"]
    //   Symbol* = (*) Symbol* Symbol ["=>@L"]
    //   Symbol* = (*) Symbol* Symbol ["=>@R"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["if"]
    //
    //   ";" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "=>" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "=>@R" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "if" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "=>?" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "=>@L" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //
    //   Symbol* -> S203
    pub fn __state165<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state203(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 166
    //   Alternative* = Alternative* Alternative (*) ["("]
    //   Alternative* = Alternative* Alternative (*) [";"]
    //   Alternative* = Alternative* Alternative (*) ["<"]
    //   Alternative* = Alternative* Alternative (*) ["=>"]
    //   Alternative* = Alternative* Alternative (*) ["=>?"]
    //   Alternative* = Alternative* Alternative (*) ["=>@L"]
    //   Alternative* = Alternative* Alternative (*) ["=>@R"]
    //   Alternative* = Alternative* Alternative (*) ["@L"]
    //   Alternative* = Alternative* Alternative (*) ["@R"]
    //   Alternative* = Alternative* Alternative (*) ["Escape"]
    //   Alternative* = Alternative* Alternative (*) ["Id"]
    //   Alternative* = Alternative* Alternative (*) ["MacroId"]
    //   Alternative* = Alternative* Alternative (*) ["StringLiteral"]
    //   Alternative* = Alternative* Alternative (*) ["if"]
    //   Alternative* = Alternative* Alternative (*) ["}"]
    //
    //   "=>?" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "(" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "MacroId" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "=>" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "Escape" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "}" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "=>@L" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "@L" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "@R" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "if" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "<" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "Id" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "=>@R" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   "StringLiteral" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //   ";" -> Reduce(Alternative* = Alternative*, Alternative => Call(ActionFn(101));)
    //
    pub fn __state166<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Alternative>>,
        __sym1: &mut Option<Alternative>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action101(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 167
    //   Alternatives = "{" Alternative* "}" (*) ";" [EOF]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["Escape"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["Id"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["MacroId"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["extern"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["pub"]
    //   Alternatives = "{" Alternative* "}" (*) ";" ["use"]
    //
    //   ";" -> Shift(S204)
    //
    pub fn __state167<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Alternative>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state204(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 168
    //   Escape = "Escape" (*) ["{"]
    //
    //   "{" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state168<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 169
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Escape"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Escape"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Escape"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef ["{"]
    //
    //   "Lifetime" -> Shift(S58)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Escape" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //
    //   Lifetime -> S59
    //   Lifetime? -> S205
    pub fn __state169<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state205(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 170
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //   Path = "::"? (*) (<Id> "::")* Id ["{"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S206
    pub fn __state170<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state206(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 171
    //   TypeRef = Path (*) ["{"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //
    //   "{" -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //   "<" -> Shift(S207)
    //
    pub fn __state171<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state207(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 172
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" ["{"]
    //
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   (<TypeRef> ",")* -> S56
    //   Comma<TypeRef> -> S208
    pub fn __state172<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state208(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 173
    //   @R = (*) ["{"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef (*) @R "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "{" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S209
    pub fn __state173<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
        __sym8: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym8.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym9 = &mut Some(__nt);
                    __result = try!(__state209(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 174
    //   TypeRef = Escape (*) ["{"]
    //
    //   "{" -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //
    pub fn __state174<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 175
    //   @R = (*) ["="]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["type"]
    //
    //   "=" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S210
    pub fn __state175<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state210(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 176
    //   Id = "Id" (*) ["="]
    //
    //   "=" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state176<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 177
    //   ("if" <Cond>) = "if" Cond (*) [";"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>?"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@L"]
    //   ("if" <Cond>) = "if" Cond (*) ["=>@R"]
    //
    //   "=>" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(97));)
    //   "=>?" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(97));)
    //   "=>@R" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(97));)
    //   "=>@L" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(97));)
    //   ";" -> Reduce(("if" <Cond>) = "if", Cond => Call(ActionFn(97));)
    //
    pub fn __state177<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Condition>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action97(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action97(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action97(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action97(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action97(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 178
    //   Cond = @L (*) NonterminalId CondOp "StringLiteral" @R [";"]
    //   Cond = @L (*) NonterminalId CondOp "StringLiteral" @R ["=>"]
    //   Cond = @L (*) NonterminalId CondOp "StringLiteral" @R ["=>?"]
    //   Cond = @L (*) NonterminalId CondOp "StringLiteral" @R ["=>@L"]
    //   Cond = @L (*) NonterminalId CondOp "StringLiteral" @R ["=>@R"]
    //   Id = (*) "Id" ["!="]
    //   Id = (*) "Id" ["!~"]
    //   Id = (*) "Id" ["=="]
    //   Id = (*) "Id" ["~~"]
    //   NonterminalId = (*) Id ["!="]
    //   NonterminalId = (*) Id ["!~"]
    //   NonterminalId = (*) Id ["=="]
    //   NonterminalId = (*) Id ["~~"]
    //
    //   "Id" -> Shift(S213)
    //
    //   NonterminalId -> S212
    //   Id -> S211
    pub fn __state178<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state213(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state212(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state211(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 179
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [";"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["if"]
    //
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S214
    pub fn __state179<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Star(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state214(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 180
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [";"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["=>"]
    //   RepeatOp = "?" (*) ["=>?"]
    //   RepeatOp = "?" (*) ["=>@L"]
    //   RepeatOp = "?" (*) ["=>@R"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //   RepeatOp = "?" (*) ["if"]
    //
    //   "=>?" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   ";" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "Id" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "<" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "=>@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "Escape" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "=>" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "=>@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "MacroId" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "(" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "if" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //
    pub fn __state180<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 181
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [";"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["=>"]
    //   RepeatOp = "+" (*) ["=>?"]
    //   RepeatOp = "+" (*) ["=>@L"]
    //   RepeatOp = "+" (*) ["=>@R"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //   RepeatOp = "+" (*) ["if"]
    //
    //   "(" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "MacroId" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "Id" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "if" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "Escape" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "=>@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "=>?" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "=>" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "<" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "=>@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   ";" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //
    pub fn __state181<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 182
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [";"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["=>"]
    //   RepeatOp = "*" (*) ["=>?"]
    //   RepeatOp = "*" (*) ["=>@L"]
    //   RepeatOp = "*" (*) ["=>@R"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //   RepeatOp = "*" (*) ["if"]
    //
    //   "MacroId" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "Escape" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "<" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "if" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "=>@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "=>?" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "=>@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "(" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "=>" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   ";" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "Id" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //
    pub fn __state182<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 183
    //   Action = "=>?" (*) [";"]
    //
    //   ";" -> Reduce(Action = "=>?" => Call(ActionFn(22));)
    //
    pub fn __state183<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action22(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 184
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R [EOF]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["Escape"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["Id"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["MacroId"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["extern"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["pub"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["use"]
    //
    //   ";" -> Shift(S215)
    //
    pub fn __state184<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state215(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 185
    //   Action = "=>@R" (*) [";"]
    //
    //   ";" -> Reduce(Action = "=>@R" => Call(ActionFn(20));)
    //
    pub fn __state185<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action20(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 186
    //   Action? = Action (*) [";"]
    //
    //   ";" -> Reduce(Action? = Action => Call(ActionFn(93));)
    //
    pub fn __state186<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<ActionKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action93(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 187
    //   Action = "=>@L" (*) [";"]
    //
    //   ";" -> Reduce(Action = "=>@L" => Call(ActionFn(19));)
    //
    pub fn __state187<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action19(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 188
    //   Action = "=>" (*) [";"]
    //
    //   ";" -> Reduce(Action = "=>" => Call(ActionFn(21));)
    //
    pub fn __state188<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action21(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Action(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 189
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["("]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["*"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["+"]
    //   SymbolKind1 = "(" (*) Symbol* ")" [";"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["<"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["=>"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["=>?"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["=>@L"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["=>@R"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["?"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["@L"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["@R"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["Escape"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["Id"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["StringLiteral"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["if"]
    //
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //
    //   Symbol* -> S216
    pub fn __state189<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state216(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 190
    //   Terminal = StringLiteral (*) ["("]
    //   Terminal = StringLiteral (*) ["*"]
    //   Terminal = StringLiteral (*) ["+"]
    //   Terminal = StringLiteral (*) [";"]
    //   Terminal = StringLiteral (*) ["<"]
    //   Terminal = StringLiteral (*) ["=>"]
    //   Terminal = StringLiteral (*) ["=>?"]
    //   Terminal = StringLiteral (*) ["=>@L"]
    //   Terminal = StringLiteral (*) ["=>@R"]
    //   Terminal = StringLiteral (*) ["?"]
    //   Terminal = StringLiteral (*) ["@L"]
    //   Terminal = StringLiteral (*) ["@R"]
    //   Terminal = StringLiteral (*) ["Escape"]
    //   Terminal = StringLiteral (*) ["Id"]
    //   Terminal = StringLiteral (*) ["MacroId"]
    //   Terminal = StringLiteral (*) ["StringLiteral"]
    //   Terminal = StringLiteral (*) ["if"]
    //
    //   "StringLiteral" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "=>?" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "?" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "(" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "<" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "if" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "=>@R" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "Escape" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "=>" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "Id" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "*" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "@L" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   ";" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "=>@L" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "@R" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "+" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "MacroId" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //
    pub fn __state190<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 191
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [";"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["=>"]
    //   SymbolKind1 = "@L" (*) ["=>?"]
    //   SymbolKind1 = "@L" (*) ["=>@L"]
    //   SymbolKind1 = "@L" (*) ["=>@R"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //   SymbolKind1 = "@L" (*) ["if"]
    //
    //   "<" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "=>" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "=>@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "=>@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "=>?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "if" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   ";" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "(" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //
    pub fn __state191<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 192
    //   SymbolKind1 = Terminal (*) ["("]
    //   SymbolKind1 = Terminal (*) ["*"]
    //   SymbolKind1 = Terminal (*) ["+"]
    //   SymbolKind1 = Terminal (*) [";"]
    //   SymbolKind1 = Terminal (*) ["<"]
    //   SymbolKind1 = Terminal (*) ["=>"]
    //   SymbolKind1 = Terminal (*) ["=>?"]
    //   SymbolKind1 = Terminal (*) ["=>@L"]
    //   SymbolKind1 = Terminal (*) ["=>@R"]
    //   SymbolKind1 = Terminal (*) ["?"]
    //   SymbolKind1 = Terminal (*) ["@L"]
    //   SymbolKind1 = Terminal (*) ["@R"]
    //   SymbolKind1 = Terminal (*) ["Escape"]
    //   SymbolKind1 = Terminal (*) ["Id"]
    //   SymbolKind1 = Terminal (*) ["MacroId"]
    //   SymbolKind1 = Terminal (*) ["StringLiteral"]
    //   SymbolKind1 = Terminal (*) ["if"]
    //
    //   "=>" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "=>?" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "=>@R" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "Id" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "+" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "=>@L" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "@L" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "if" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "@R" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "<" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "*" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "MacroId" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "?" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   ";" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "(" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "Escape" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //
    pub fn __state192<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 193
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) ["*"]
    //   Id = "Id" (*) ["+"]
    //   Id = "Id" (*) [";"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["=>"]
    //   Id = "Id" (*) ["=>?"]
    //   Id = "Id" (*) ["=>@L"]
    //   Id = "Id" (*) ["=>@R"]
    //   Id = "Id" (*) ["?"]
    //   Id = "Id" (*) ["@L"]
    //   Id = "Id" (*) ["@R"]
    //   Id = "Id" (*) ["Escape"]
    //   Id = "Id" (*) ["Id"]
    //   Id = "Id" (*) ["MacroId"]
    //   Id = "Id" (*) ["StringLiteral"]
    //   Id = "Id" (*) ["if"]
    //
    //   "Escape" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "@R" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "@L" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "MacroId" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ";" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "if" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "=>@R" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "?" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "Id" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "(" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "*" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "StringLiteral" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "=>" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "=>?" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "+" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "=>@L" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state193<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 194
    //   SymbolKind1 = NonterminalId (*) ["("]
    //   SymbolKind1 = NonterminalId (*) ["*"]
    //   SymbolKind1 = NonterminalId (*) ["+"]
    //   SymbolKind1 = NonterminalId (*) [";"]
    //   SymbolKind1 = NonterminalId (*) ["<"]
    //   SymbolKind1 = NonterminalId (*) ["=>"]
    //   SymbolKind1 = NonterminalId (*) ["=>?"]
    //   SymbolKind1 = NonterminalId (*) ["=>@L"]
    //   SymbolKind1 = NonterminalId (*) ["=>@R"]
    //   SymbolKind1 = NonterminalId (*) ["?"]
    //   SymbolKind1 = NonterminalId (*) ["@L"]
    //   SymbolKind1 = NonterminalId (*) ["@R"]
    //   SymbolKind1 = NonterminalId (*) ["Escape"]
    //   SymbolKind1 = NonterminalId (*) ["Id"]
    //   SymbolKind1 = NonterminalId (*) ["MacroId"]
    //   SymbolKind1 = NonterminalId (*) ["StringLiteral"]
    //   SymbolKind1 = NonterminalId (*) ["if"]
    //
    //   "@L" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "<" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "MacroId" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "*" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "Escape" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "(" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "@R" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "=>@L" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "=>?" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "+" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "?" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "=>@R" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "=>" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "Id" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "if" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   ";" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //
    pub fn __state194<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 195
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [";"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["if"]
    //
    //   "<" -> Shift(S217)
    //
    pub fn __state195<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state217(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 196
    //   NonterminalId = Id (*) ["("]
    //   NonterminalId = Id (*) ["*"]
    //   NonterminalId = Id (*) ["+"]
    //   NonterminalId = Id (*) [";"]
    //   NonterminalId = Id (*) ["<"]
    //   NonterminalId = Id (*) ["=>"]
    //   NonterminalId = Id (*) ["=>?"]
    //   NonterminalId = Id (*) ["=>@L"]
    //   NonterminalId = Id (*) ["=>@R"]
    //   NonterminalId = Id (*) ["?"]
    //   NonterminalId = Id (*) ["@L"]
    //   NonterminalId = Id (*) ["@R"]
    //   NonterminalId = Id (*) ["Escape"]
    //   NonterminalId = Id (*) ["Id"]
    //   NonterminalId = Id (*) ["MacroId"]
    //   NonterminalId = Id (*) ["StringLiteral"]
    //   NonterminalId = Id (*) ["if"]
    //
    //   "Id" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "?" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "=>@L" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "=>" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "MacroId" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "<" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ";" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "=>?" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "*" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "StringLiteral" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "@L" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "Escape" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "+" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "=>@R" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "@R" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "(" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "if" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state196<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 197
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [";"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["=>"]
    //   SymbolKind1 = "@R" (*) ["=>?"]
    //   SymbolKind1 = "@R" (*) ["=>@L"]
    //   SymbolKind1 = "@R" (*) ["=>@R"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //   SymbolKind1 = "@R" (*) ["if"]
    //
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "=>" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "<" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "=>@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "=>@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "(" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "=>?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   ";" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "if" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //
    pub fn __state197<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 198
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [";"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["=>"]
    //   Escape = "Escape" (*) ["=>?"]
    //   Escape = "Escape" (*) ["=>@L"]
    //   Escape = "Escape" (*) ["=>@R"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //   Escape = "Escape" (*) ["if"]
    //
    //   "<" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   ";" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "if" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "@R" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "MacroId" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "@L" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "=>@R" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "Id" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "=>" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "Escape" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "(" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "=>?" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "=>@L" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state198<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 199
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [";"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //   StringLiteral = "StringLiteral" (*) ["=>?"]
    //   StringLiteral = "StringLiteral" (*) ["=>@L"]
    //   StringLiteral = "StringLiteral" (*) ["=>@R"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //   StringLiteral = "StringLiteral" (*) ["if"]
    //
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "=>?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "=>" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "=>@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "if" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   ";" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "=>@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //
    pub fn __state199<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 200
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [";"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol0 -> S218
    //   Symbol1 -> S220
    //   @L -> S219
    pub fn __state200<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state218(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state220(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state219(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 201
    //   @R = (*) ["("]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [";"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["=>@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["if"]
    //
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S221
    pub fn __state201<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state221(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 202
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [";"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["=>"]
    //   SymbolKind1 = Escape (*) ["=>?"]
    //   SymbolKind1 = Escape (*) ["=>@L"]
    //   SymbolKind1 = Escape (*) ["=>@R"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //   SymbolKind1 = Escape (*) ["if"]
    //
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "=>@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "=>?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "Id" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "=>" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "(" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "=>@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "<" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "if" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   ";" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //
    pub fn __state202<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 203
    //   ("if" <Cond>) = (*) "if" Cond [";"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>?"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@L"]
    //   ("if" <Cond>) = (*) "if" Cond ["=>@R"]
    //   ("if" <Cond>)? = (*) [";"]
    //   ("if" <Cond>)? = (*) ["=>"]
    //   ("if" <Cond>)? = (*) ["=>?"]
    //   ("if" <Cond>)? = (*) ["=>@L"]
    //   ("if" <Cond>)? = (*) ["=>@R"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) [";"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>?"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@L"]
    //   ("if" <Cond>)? = (*) ("if" <Cond>) ["=>@R"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["("]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R [";"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["<"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["=>"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["=>?"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["=>@L"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["=>@R"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["@L"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["@R"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["Escape"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["Id"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["MacroId"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["StringLiteral"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["if"]
    //   Alternative = @L Symbol* (*) ("if" <Cond>)? Action? ";" @R ["}"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["if"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [";"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>?"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["=>@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["if"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [";"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["=>"]
    //   Symbol = (*) Symbol0 ["=>?"]
    //   Symbol = (*) Symbol0 ["=>@L"]
    //   Symbol = (*) Symbol0 ["=>@R"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["if"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [";"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["=>"]
    //   Symbol* = Symbol* (*) Symbol ["=>?"]
    //   Symbol* = Symbol* (*) Symbol ["=>@L"]
    //   Symbol* = Symbol* (*) Symbol ["=>@R"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [";"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["=>@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["if"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [";"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["=>"]
    //   Symbol0 = (*) Symbol1 ["=>?"]
    //   Symbol0 = (*) Symbol1 ["=>@L"]
    //   Symbol0 = (*) Symbol1 ["=>@R"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["if"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [";"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["=>@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["if"]
    //
    //   "=>" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "if" -> Shift(S158)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   ";" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "=>@R" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   "=>?" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "=>@L" -> Reduce(("if" <Cond>)? =  => Call(ActionFn(96));)
    //
    //   Symbol0 -> S160
    //   ("if" <Cond>)? -> S222
    //   @L -> S164
    //   ("if" <Cond>) -> S161
    //   Symbol1 -> S162
    //   Symbol -> S159
    pub fn __state203<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::If(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state158(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = super::__action96(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state160(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::_28_22if_22_20_3cCond_3e_29_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state222(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state164(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::_28_22if_22_20_3cCond_3e_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state161(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state162(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state159(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 204
    //   Alternatives = "{" Alternative* "}" ";" (*) [EOF]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["Escape"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["Id"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["MacroId"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["extern"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["pub"]
    //   Alternatives = "{" Alternative* "}" ";" (*) ["use"]
    //
    //   "use" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(17));)
    //   "extern" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(17));)
    //   "pub" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(17));)
    //   EOF -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(17));)
    //   "Id" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(17));)
    //   "MacroId" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(17));)
    //   "Escape" -> Reduce(Alternatives = "{", Alternative*, "}", ";" => Call(ActionFn(17));)
    //
    pub fn __state204<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Alternative>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action17(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action17(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action17(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action17(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action17(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action17(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action17(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternatives(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 205
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Escape"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Escape"]
    //   "mut"? = (*) "mut" ["Id"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef ["{"]
    //
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "mut" -> Shift(S74)
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Escape" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //
    //   "mut"? -> S223
    pub fn __state205<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state223(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 206
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["{"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id ["{"]
    //
    //   "Id" -> Shift(S224)
    //
    //   Id -> S225
    //   (<Id> "::") -> S70
    pub fn __state206<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state224(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state225(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 207
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" ["{"]
    //
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //
    //   (<TypeRefOrLifetime> ",")* -> S65
    //   Comma<TypeRefOrLifetime> -> S226
    pub fn __state207<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state226(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 208
    //   TypeRef = "(" Comma<TypeRef> (*) ")" ["{"]
    //
    //   ")" -> Shift(S227)
    //
    pub fn __state208<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state227(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 209
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R (*) "{" Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "{" -> Shift(S228)
    //
    pub fn __state209<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
        __sym8: &mut Option<TypeRef>,
        __sym9: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym10 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state228(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 210
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["type"]
    //
    //   "=" -> Shift(S229)
    //
    pub fn __state210<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Equals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state229(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 211
    //   NonterminalId = Id (*) ["!="]
    //   NonterminalId = Id (*) ["!~"]
    //   NonterminalId = Id (*) ["=="]
    //   NonterminalId = Id (*) ["~~"]
    //
    //   "~~" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "!=" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "!~" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "==" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state211<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::TildeTilde(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::BangEquals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::BangTilde(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::EqualsEquals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 212
    //   Cond = @L NonterminalId (*) CondOp "StringLiteral" @R [";"]
    //   Cond = @L NonterminalId (*) CondOp "StringLiteral" @R ["=>"]
    //   Cond = @L NonterminalId (*) CondOp "StringLiteral" @R ["=>?"]
    //   Cond = @L NonterminalId (*) CondOp "StringLiteral" @R ["=>@L"]
    //   Cond = @L NonterminalId (*) CondOp "StringLiteral" @R ["=>@R"]
    //   CondOp = (*) "!=" ["StringLiteral"]
    //   CondOp = (*) "!~" ["StringLiteral"]
    //   CondOp = (*) "==" ["StringLiteral"]
    //   CondOp = (*) "~~" ["StringLiteral"]
    //
    //   "!=" -> Shift(S230)
    //   "==" -> Shift(S231)
    //   "~~" -> Shift(S233)
    //   "!~" -> Shift(S232)
    //
    //   CondOp -> S234
    pub fn __state212<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::BangEquals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state230(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::EqualsEquals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state231(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::TildeTilde(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state233(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, __tok @ Tok::BangTilde(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state232(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::CondOp(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state234(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 213
    //   Id = "Id" (*) ["!="]
    //   Id = "Id" (*) ["!~"]
    //   Id = "Id" (*) ["=="]
    //   Id = "Id" (*) ["~~"]
    //
    //   "!=" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "!~" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "==" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "~~" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state213<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::BangEquals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::BangTilde(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::EqualsEquals(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::TildeTilde(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 214
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [";"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["=>@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["if"]
    //
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "=>@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "=>@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   ";" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "=>?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "=>" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "if" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //
    pub fn __state214<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 215
    //   @R = (*) [EOF]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["extern"]
    //   @R = (*) ["pub"]
    //   @R = (*) ["use"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R [EOF]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["Escape"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["Id"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["MacroId"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["extern"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["pub"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["use"]
    //
    //   EOF -> Reduce(@R =  => Lookbehind;)
    //   "pub" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "use" -> Reduce(@R =  => Lookbehind;)
    //   "extern" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S235
    pub fn __state215<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Use(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state235(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 216
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["("]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["*"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["+"]
    //   SymbolKind1 = "(" Symbol* (*) ")" [";"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["<"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["=>"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["=>?"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["=>@L"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["=>@R"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["?"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["@L"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["@R"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["Escape"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["Id"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["StringLiteral"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["if"]
    //
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Shift(S240)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S239
    //   Symbol1 -> S236
    //   Symbol0 -> S238
    //   Symbol -> S237
    pub fn __state216<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state240(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state239(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state236(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state238(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state237(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 217
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [";"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["if"]
    //
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //
    //   (<Symbol> ",")* -> S242
    //   Comma<Symbol> -> S241
    pub fn __state217<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state242(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cSymbol_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state241(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 218
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [";"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   ">" -> Shift(S243)
    //   "*" -> Shift(S246)
    //   "?" -> Shift(S245)
    //   "+" -> Shift(S244)
    //
    //   RepeatOp -> S247
    pub fn __state218<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state243(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state246(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state245(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state244(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state247(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 219
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" ["*"]
    //   Id = (*) "Id" ["+"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "Id" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   NonterminalId = (*) Id ["*"]
    //   NonterminalId = (*) Id ["+"]
    //   NonterminalId = (*) Id [">"]
    //   NonterminalId = (*) Id ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["if"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) NonterminalId ["*"]
    //   SymbolKind1 = (*) NonterminalId ["+"]
    //   SymbolKind1 = (*) NonterminalId [">"]
    //   SymbolKind1 = (*) NonterminalId ["?"]
    //   SymbolKind1 = (*) Terminal ["*"]
    //   SymbolKind1 = (*) Terminal ["+"]
    //   SymbolKind1 = (*) Terminal [">"]
    //   SymbolKind1 = (*) Terminal ["?"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["*"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["+"]
    //   SymbolKind1 = (*) "(" Symbol* ")" [">"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   Terminal = (*) StringLiteral ["*"]
    //   Terminal = (*) StringLiteral ["+"]
    //   Terminal = (*) StringLiteral [">"]
    //   Terminal = (*) StringLiteral ["?"]
    //
    //   "(" -> Shift(S260)
    //   "StringLiteral" -> Shift(S253)
    //   "@R" -> Shift(S255)
    //   "MacroId" -> Shift(S78)
    //   "@L" -> Shift(S252)
    //   "Escape" -> Shift(S258)
    //   "Id" -> Shift(S259)
    //
    //   Terminal -> S248
    //   Id -> S251
    //   MacroId -> S250
    //   NonterminalId -> S254
    //   StringLiteral -> S256
    //   Escape -> S257
    //   SymbolKind1 -> S249
    pub fn __state219<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state260(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state253(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state255(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state252(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state258(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state259(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Terminal(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state248(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state251(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state250(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state254(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state256(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state257(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state249(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 220
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   ">" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //
    pub fn __state220<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 221
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [";"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["=>@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["if"]
    //
    //   ";" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "if" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "=>" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "=>@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "=>@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "=>?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //
    pub fn __state221<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 222
    //   Action = (*) "=>" [";"]
    //   Action = (*) "=>?" [";"]
    //   Action = (*) "=>@L" [";"]
    //   Action = (*) "=>@R" [";"]
    //   Action? = (*) [";"]
    //   Action? = (*) Action [";"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["("]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R [";"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["<"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["=>"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["=>?"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["=>@L"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["=>@R"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["@L"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["@R"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["Escape"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["Id"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["MacroId"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["StringLiteral"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["if"]
    //   Alternative = @L Symbol* ("if" <Cond>)? (*) Action? ";" @R ["}"]
    //
    //   ";" -> Reduce(Action? =  => Call(ActionFn(94));)
    //   "=>@R" -> Shift(S185)
    //   "=>@L" -> Shift(S187)
    //   "=>?" -> Shift(S183)
    //   "=>" -> Shift(S188)
    //
    //   Action? -> S261
    //   Action -> S186
    pub fn __state222<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::EqualsGreaterThanLookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state185(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::EqualsGreaterThanLookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state187(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state183(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::EqualsGreaterThanCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state188(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = super::__action94(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Action_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Action_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state261(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Action(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state186(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 223
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" ["{"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   Path = (*) "::"? (<Id> "::")* Id ["{"]
    //   TypeRef = (*) Escape ["{"]
    //   TypeRef = (*) Path ["{"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" ["{"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef ["{"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef ["{"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" ["{"]
    //
    //   "Escape" -> Shift(S168)
    //   "(" -> Shift(S172)
    //   "&" -> Shift(S169)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "::" -> Shift(S41)
    //
    //   "::"? -> S170
    //   Escape -> S174
    //   TypeRef -> S262
    //   Path -> S171
    pub fn __state223<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state168(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state172(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state169(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state170(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state174(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state262(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state171(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 224
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["{"]
    //
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "{" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state224<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 225
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //   Path = "::"? (<Id> "::")* Id (*) ["{"]
    //
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "{" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S97)
    //
    pub fn __state225<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state97(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 226
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" ["{"]
    //
    //   ">" -> Shift(S263)
    //
    pub fn __state226<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state263(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 227
    //   TypeRef = "(" Comma<TypeRef> ")" (*) ["{"]
    //
    //   "{" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //
    pub fn __state227<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 228
    //   (<Conversion> ",")* = (*) ["StringLiteral"]
    //   (<Conversion> ",")* = (*) ["}"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["StringLiteral"]
    //   (<Conversion> ",")* = (*) (<Conversion> ",")* (<Conversion> ",") ["}"]
    //   Comma<Conversion> = (*) (<Conversion> ",")* Conversion? ["}"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" (*) Comma<Conversion> "}" AssociatedType* "}" ["use"]
    //
    //   "}" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(152));)
    //   "StringLiteral" -> Reduce((<Conversion> ",")* =  => Call(ActionFn(152));)
    //
    //   (<Conversion> ",")* -> S264
    //   Comma<Conversion> -> S265
    pub fn __state228<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
        __sym8: &mut Option<TypeRef>,
        __sym9: &mut Option<usize>,
        __sym10: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action152(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action152(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym10.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym11 = &mut Some(__nt);
                    __result = try!(__state264(text, __lookbehind, __lookahead, __tokens, __sym11));
                }
                __Nonterminal::Comma_3cConversion_3e(__nt) => {
                    let __sym11 = &mut Some(__nt);
                    __result = try!(__state265(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 229
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["enum"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["type"]
    //   Escape = (*) "Escape" [";"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Escape [";"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "(" -> Shift(S271)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "::" -> Shift(S41)
    //   "&" -> Shift(S268)
    //   "Escape" -> Shift(S267)
    //
    //   "::"? -> S272
    //   TypeRef -> S270
    //   Escape -> S269
    //   Path -> S266
    pub fn __state229<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state271(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state268(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state267(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state272(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state270(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state269(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state266(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 230
    //   CondOp = "!=" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "!=" => Call(ActionFn(25));)
    //
    pub fn __state230<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action25(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::CondOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 231
    //   CondOp = "==" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "==" => Call(ActionFn(24));)
    //
    pub fn __state231<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action24(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::CondOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 232
    //   CondOp = "!~" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "!~" => Call(ActionFn(27));)
    //
    pub fn __state232<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action27(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::CondOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 233
    //   CondOp = "~~" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(CondOp = "~~" => Call(ActionFn(26));)
    //
    pub fn __state233<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action26(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::CondOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 234
    //   Cond = @L NonterminalId CondOp (*) "StringLiteral" @R [";"]
    //   Cond = @L NonterminalId CondOp (*) "StringLiteral" @R ["=>"]
    //   Cond = @L NonterminalId CondOp (*) "StringLiteral" @R ["=>?"]
    //   Cond = @L NonterminalId CondOp (*) "StringLiteral" @R ["=>@L"]
    //   Cond = @L NonterminalId CondOp (*) "StringLiteral" @R ["=>@R"]
    //
    //   "StringLiteral" -> Shift(S273)
    //
    pub fn __state234<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<NonterminalString>,
        __sym2: &mut Option<ConditionOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state273(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 235
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) [EOF]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["Escape"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["Id"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["MacroId"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["extern"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["pub"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["use"]
    //
    //   EOF -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "Escape" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "extern" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "Id" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "use" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "MacroId" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "pub" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //
    pub fn __state235<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 236
    //   Symbol0 = Symbol1 (*) ["("]
    //   Symbol0 = Symbol1 (*) [")"]
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) ["<"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //   Symbol0 = Symbol1 (*) ["@L"]
    //   Symbol0 = Symbol1 (*) ["@R"]
    //   Symbol0 = Symbol1 (*) ["Escape"]
    //   Symbol0 = Symbol1 (*) ["Id"]
    //   Symbol0 = Symbol1 (*) ["MacroId"]
    //   Symbol0 = Symbol1 (*) ["StringLiteral"]
    //
    //   "Id" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "@R" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "Escape" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "(" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "<" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "@L" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   ")" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //
    pub fn __state236<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 237
    //   Symbol* = Symbol* Symbol (*) ["("]
    //   Symbol* = Symbol* Symbol (*) [")"]
    //   Symbol* = Symbol* Symbol (*) ["<"]
    //   Symbol* = Symbol* Symbol (*) ["@L"]
    //   Symbol* = Symbol* Symbol (*) ["@R"]
    //   Symbol* = Symbol* Symbol (*) ["Escape"]
    //   Symbol* = Symbol* Symbol (*) ["Id"]
    //   Symbol* = Symbol* Symbol (*) ["MacroId"]
    //   Symbol* = Symbol* Symbol (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "@L" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   ")" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "@R" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "<" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "Escape" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "StringLiteral" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "Id" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //   "MacroId" -> Reduce(Symbol* = Symbol*, Symbol => Call(ActionFn(99));)
    //
    pub fn __state237<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action99(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 238
    //   RepeatOp = (*) "*" ["("]
    //   RepeatOp = (*) "*" [")"]
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" ["<"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "*" ["@L"]
    //   RepeatOp = (*) "*" ["@R"]
    //   RepeatOp = (*) "*" ["Escape"]
    //   RepeatOp = (*) "*" ["Id"]
    //   RepeatOp = (*) "*" ["MacroId"]
    //   RepeatOp = (*) "*" ["StringLiteral"]
    //   RepeatOp = (*) "+" ["("]
    //   RepeatOp = (*) "+" [")"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" ["<"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "+" ["@L"]
    //   RepeatOp = (*) "+" ["@R"]
    //   RepeatOp = (*) "+" ["Escape"]
    //   RepeatOp = (*) "+" ["Id"]
    //   RepeatOp = (*) "+" ["MacroId"]
    //   RepeatOp = (*) "+" ["StringLiteral"]
    //   RepeatOp = (*) "?" ["("]
    //   RepeatOp = (*) "?" [")"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" ["<"]
    //   RepeatOp = (*) "?" ["?"]
    //   RepeatOp = (*) "?" ["@L"]
    //   RepeatOp = (*) "?" ["@R"]
    //   RepeatOp = (*) "?" ["Escape"]
    //   RepeatOp = (*) "?" ["Id"]
    //   RepeatOp = (*) "?" ["MacroId"]
    //   RepeatOp = (*) "?" ["StringLiteral"]
    //   Symbol = Symbol0 (*) ["("]
    //   Symbol = Symbol0 (*) [")"]
    //   Symbol = Symbol0 (*) ["<"]
    //   Symbol = Symbol0 (*) ["@L"]
    //   Symbol = Symbol0 (*) ["@R"]
    //   Symbol = Symbol0 (*) ["Escape"]
    //   Symbol = Symbol0 (*) ["Id"]
    //   Symbol = Symbol0 (*) ["MacroId"]
    //   Symbol = Symbol0 (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["("]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [")"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["<"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@L"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["@R"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Escape"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["Id"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["MacroId"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["StringLiteral"]
    //
    //   "*" -> Shift(S275)
    //   "Escape" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "Id" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "MacroId" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "(" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   ")" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "@L" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "?" -> Shift(S276)
    //   "StringLiteral" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "<" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "+" -> Shift(S277)
    //   "@R" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //
    //   RepeatOp -> S274
    pub fn __state238<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state275(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state276(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state277(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state274(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 239
    //   Escape = (*) "Escape" ["("]
    //   Escape = (*) "Escape" [")"]
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" ["<"]
    //   Escape = (*) "Escape" ["?"]
    //   Escape = (*) "Escape" ["@L"]
    //   Escape = (*) "Escape" ["@R"]
    //   Escape = (*) "Escape" ["Escape"]
    //   Escape = (*) "Escape" ["Id"]
    //   Escape = (*) "Escape" ["MacroId"]
    //   Escape = (*) "Escape" ["StringLiteral"]
    //   Id = (*) "Id" ["("]
    //   Id = (*) "Id" [")"]
    //   Id = (*) "Id" ["*"]
    //   Id = (*) "Id" ["+"]
    //   Id = (*) "Id" ["<"]
    //   Id = (*) "Id" ["?"]
    //   Id = (*) "Id" ["@L"]
    //   Id = (*) "Id" ["@R"]
    //   Id = (*) "Id" ["Escape"]
    //   Id = (*) "Id" ["Id"]
    //   Id = (*) "Id" ["MacroId"]
    //   Id = (*) "Id" ["StringLiteral"]
    //   MacroId = (*) "MacroId" ["<"]
    //   NonterminalId = (*) Id ["("]
    //   NonterminalId = (*) Id [")"]
    //   NonterminalId = (*) Id ["*"]
    //   NonterminalId = (*) Id ["+"]
    //   NonterminalId = (*) Id ["<"]
    //   NonterminalId = (*) Id ["?"]
    //   NonterminalId = (*) Id ["@L"]
    //   NonterminalId = (*) Id ["@R"]
    //   NonterminalId = (*) Id ["Escape"]
    //   NonterminalId = (*) Id ["Id"]
    //   NonterminalId = (*) Id ["MacroId"]
    //   NonterminalId = (*) Id ["StringLiteral"]
    //   StringLiteral = (*) "StringLiteral" ["("]
    //   StringLiteral = (*) "StringLiteral" [")"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" ["<"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   StringLiteral = (*) "StringLiteral" ["@L"]
    //   StringLiteral = (*) "StringLiteral" ["@R"]
    //   StringLiteral = (*) "StringLiteral" ["Escape"]
    //   StringLiteral = (*) "StringLiteral" ["Id"]
    //   StringLiteral = (*) "StringLiteral" ["MacroId"]
    //   StringLiteral = (*) "StringLiteral" ["StringLiteral"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["("]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [")"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["<"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@L"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["@R"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["Id"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["("]
    //   Symbol1 = @L (*) SymbolKind1 @R [")"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["<"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@L"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["@R"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Escape"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["Id"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["MacroId"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = (*) Escape ["("]
    //   SymbolKind1 = (*) Escape [")"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape ["<"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) Escape ["@L"]
    //   SymbolKind1 = (*) Escape ["@R"]
    //   SymbolKind1 = (*) Escape ["Escape"]
    //   SymbolKind1 = (*) Escape ["Id"]
    //   SymbolKind1 = (*) Escape ["MacroId"]
    //   SymbolKind1 = (*) Escape ["StringLiteral"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["StringLiteral"]
    //   SymbolKind1 = (*) NonterminalId ["("]
    //   SymbolKind1 = (*) NonterminalId [")"]
    //   SymbolKind1 = (*) NonterminalId ["*"]
    //   SymbolKind1 = (*) NonterminalId ["+"]
    //   SymbolKind1 = (*) NonterminalId ["<"]
    //   SymbolKind1 = (*) NonterminalId ["?"]
    //   SymbolKind1 = (*) NonterminalId ["@L"]
    //   SymbolKind1 = (*) NonterminalId ["@R"]
    //   SymbolKind1 = (*) NonterminalId ["Escape"]
    //   SymbolKind1 = (*) NonterminalId ["Id"]
    //   SymbolKind1 = (*) NonterminalId ["MacroId"]
    //   SymbolKind1 = (*) NonterminalId ["StringLiteral"]
    //   SymbolKind1 = (*) Terminal ["("]
    //   SymbolKind1 = (*) Terminal [")"]
    //   SymbolKind1 = (*) Terminal ["*"]
    //   SymbolKind1 = (*) Terminal ["+"]
    //   SymbolKind1 = (*) Terminal ["<"]
    //   SymbolKind1 = (*) Terminal ["?"]
    //   SymbolKind1 = (*) Terminal ["@L"]
    //   SymbolKind1 = (*) Terminal ["@R"]
    //   SymbolKind1 = (*) Terminal ["Escape"]
    //   SymbolKind1 = (*) Terminal ["Id"]
    //   SymbolKind1 = (*) Terminal ["MacroId"]
    //   SymbolKind1 = (*) Terminal ["StringLiteral"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["("]
    //   SymbolKind1 = (*) "(" Symbol* ")" [")"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["*"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["+"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["<"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["?"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["@L"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["@R"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["Escape"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["Id"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["MacroId"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["StringLiteral"]
    //   SymbolKind1 = (*) "@L" ["("]
    //   SymbolKind1 = (*) "@L" [")"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" ["<"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@L" ["@L"]
    //   SymbolKind1 = (*) "@L" ["@R"]
    //   SymbolKind1 = (*) "@L" ["Escape"]
    //   SymbolKind1 = (*) "@L" ["Id"]
    //   SymbolKind1 = (*) "@L" ["MacroId"]
    //   SymbolKind1 = (*) "@L" ["StringLiteral"]
    //   SymbolKind1 = (*) "@R" ["("]
    //   SymbolKind1 = (*) "@R" [")"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" ["<"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   SymbolKind1 = (*) "@R" ["@L"]
    //   SymbolKind1 = (*) "@R" ["@R"]
    //   SymbolKind1 = (*) "@R" ["Escape"]
    //   SymbolKind1 = (*) "@R" ["Id"]
    //   SymbolKind1 = (*) "@R" ["MacroId"]
    //   SymbolKind1 = (*) "@R" ["StringLiteral"]
    //   Terminal = (*) StringLiteral ["("]
    //   Terminal = (*) StringLiteral [")"]
    //   Terminal = (*) StringLiteral ["*"]
    //   Terminal = (*) StringLiteral ["+"]
    //   Terminal = (*) StringLiteral ["<"]
    //   Terminal = (*) StringLiteral ["?"]
    //   Terminal = (*) StringLiteral ["@L"]
    //   Terminal = (*) StringLiteral ["@R"]
    //   Terminal = (*) StringLiteral ["Escape"]
    //   Terminal = (*) StringLiteral ["Id"]
    //   Terminal = (*) StringLiteral ["MacroId"]
    //   Terminal = (*) StringLiteral ["StringLiteral"]
    //
    //   "<" -> Shift(S283)
    //   "StringLiteral" -> Shift(S284)
    //   "@L" -> Shift(S286)
    //   "Id" -> Shift(S280)
    //   "@R" -> Shift(S289)
    //   "Escape" -> Shift(S287)
    //   "(" -> Shift(S290)
    //   "MacroId" -> Shift(S78)
    //
    //   Escape -> S285
    //   Terminal -> S279
    //   Id -> S288
    //   StringLiteral -> S282
    //   SymbolKind1 -> S278
    //   NonterminalId -> S281
    //   MacroId -> S291
    pub fn __state239<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state283(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state284(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state286(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state280(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state289(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state287(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state290(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state285(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Terminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state279(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state288(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state282(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state278(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state281(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state291(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 240
    //   SymbolKind1 = "(" Symbol* ")" (*) ["("]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["*"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["+"]
    //   SymbolKind1 = "(" Symbol* ")" (*) [";"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["<"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["=>"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["=>?"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["=>@L"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["=>@R"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["?"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["@L"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["@R"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["Escape"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["Id"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["StringLiteral"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["if"]
    //
    //   "?" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "@L" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   ";" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "*" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "<" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "@R" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "=>?" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "Id" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "+" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "=>@R" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "if" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "=>@L" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "=>" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "Escape" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "(" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //
    pub fn __state240<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 241
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [";"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["if"]
    //
    //   ">" -> Shift(S292)
    //
    pub fn __state241<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state292(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 242
    //   (<Symbol> ",") = (*) Symbol "," ["("]
    //   (<Symbol> ",") = (*) Symbol "," ["<"]
    //   (<Symbol> ",") = (*) Symbol "," [">"]
    //   (<Symbol> ",") = (*) Symbol "," ["@L"]
    //   (<Symbol> ",") = (*) Symbol "," ["@R"]
    //   (<Symbol> ",") = (*) Symbol "," ["Escape"]
    //   (<Symbol> ",") = (*) Symbol "," ["Id"]
    //   (<Symbol> ",") = (*) Symbol "," ["MacroId"]
    //   (<Symbol> ",") = (*) Symbol "," ["StringLiteral"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (*) (<Symbol> ",") ["StringLiteral"]
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Symbol> = (<Symbol> ",")* (*) Symbol? [">"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [","]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [">"]
    //   Symbol = (*) Symbol0 [","]
    //   Symbol = (*) Symbol0 [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [","]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [","]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [","]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol? = (*) [">"]
    //   Symbol? = (*) Symbol [">"]
    //
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   ">" -> Reduce(Symbol? =  => Call(ActionFn(136));)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol1 -> S297
    //   @L -> S298
    //   Symbol0 -> S295
    //   (<Symbol> ",") -> S296
    //   Symbol? -> S294
    //   Symbol -> S293
    pub fn __state242<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action136(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state297(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state298(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state295(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state296(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state294(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state293(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 243
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [";"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["if"]
    //
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S299
    pub fn __state243<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state299(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 244
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   ">" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //
    pub fn __state244<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 245
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //
    //   ">" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //
    pub fn __state245<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 246
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   ">" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //
    pub fn __state246<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 247
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S300
    pub fn __state247<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state300(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 248
    //   SymbolKind1 = Terminal (*) ["*"]
    //   SymbolKind1 = Terminal (*) ["+"]
    //   SymbolKind1 = Terminal (*) [">"]
    //   SymbolKind1 = Terminal (*) ["?"]
    //
    //   "?" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "*" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "+" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   ">" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //
    pub fn __state248<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 249
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S301
    pub fn __state249<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Star(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state301(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 250
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Shift(S302)
    //
    pub fn __state250<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state302(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 251
    //   NonterminalId = Id (*) ["*"]
    //   NonterminalId = Id (*) ["+"]
    //   NonterminalId = Id (*) [">"]
    //   NonterminalId = Id (*) ["?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["if"]
    //
    //   "?" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "+" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "*" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ">" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ":" -> Shift(S303)
    //
    pub fn __state251<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state303(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 252
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   ">" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //
    pub fn __state252<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 253
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //
    pub fn __state253<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 254
    //   SymbolKind1 = NonterminalId (*) ["*"]
    //   SymbolKind1 = NonterminalId (*) ["+"]
    //   SymbolKind1 = NonterminalId (*) [">"]
    //   SymbolKind1 = NonterminalId (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   ">" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "+" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "?" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //
    pub fn __state254<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 255
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //
    //   ">" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //
    pub fn __state255<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 256
    //   Terminal = StringLiteral (*) ["*"]
    //   Terminal = StringLiteral (*) ["+"]
    //   Terminal = StringLiteral (*) [">"]
    //   Terminal = StringLiteral (*) ["?"]
    //
    //   "?" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "*" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "+" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   ">" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //
    pub fn __state256<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 257
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   ">" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //
    pub fn __state257<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 258
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state258<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 259
    //   Id = "Id" (*) ["*"]
    //   Id = "Id" (*) ["+"]
    //   Id = "Id" (*) [":"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["?"]
    //
    //   "?" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "+" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "*" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ":" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state259<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Colon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 260
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["*"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["+"]
    //   SymbolKind1 = "(" (*) Symbol* ")" [">"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["?"]
    //
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //
    //   Symbol* -> S304
    pub fn __state260<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state304(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 261
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["("]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R [";"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["<"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["=>"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["=>?"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["=>@L"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["=>@R"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["@L"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["@R"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["Escape"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["Id"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["MacroId"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["StringLiteral"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["if"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? (*) ";" @R ["}"]
    //
    //   ";" -> Shift(S305)
    //
    pub fn __state261<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state305(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 262
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) ["{"]
    //
    //   "{" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //
    pub fn __state262<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 263
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) ["{"]
    //
    //   "{" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //
    pub fn __state263<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 264
    //   (<Conversion> ",") = (*) Conversion "," ["StringLiteral"]
    //   (<Conversion> ",") = (*) Conversion "," ["}"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["StringLiteral"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (*) (<Conversion> ",") ["}"]
    //   @L = (*) ["StringLiteral"]
    //   Comma<Conversion> = (<Conversion> ",")* (*) Conversion? ["}"]
    //   Conversion = (*) @L Terminal "=>" @R [","]
    //   Conversion = (*) @L Terminal "=>" @R ["}"]
    //   Conversion? = (*) ["}"]
    //   Conversion? = (*) Conversion ["}"]
    //
    //   "}" -> Reduce(Conversion? =  => Call(ActionFn(151));)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S309
    //   Conversion? -> S307
    //   Conversion -> S306
    //   (<Conversion> ",") -> S308
    pub fn __state264<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action151(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Conversion_3f(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state309(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Conversion_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state307(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::Conversion(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state306(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state308(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 265
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> (*) "}" AssociatedType* "}" ["use"]
    //
    //   "}" -> Shift(S310)
    //
    pub fn __state265<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
        __sym8: &mut Option<TypeRef>,
        __sym9: &mut Option<usize>,
        __sym10: &mut Option<Tok<'input>>,
        __sym11: &mut Option<Vec<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym12 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state310(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 266
    //   TypeRef = Path (*) [";"]
    //   TypeRef = Path (*) "<" Comma<TypeRefOrLifetime> ">" [";"]
    //
    //   ";" -> Reduce(TypeRef = Path => Call(ActionFn(48));)
    //   "<" -> Shift(S311)
    //
    pub fn __state266<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state311(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action48(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 267
    //   Escape = "Escape" (*) [";"]
    //
    //   ";" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state267<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 268
    //   Lifetime = (*) "Lifetime" ["&"]
    //   Lifetime = (*) "Lifetime" ["("]
    //   Lifetime = (*) "Lifetime" ["::"]
    //   Lifetime = (*) "Lifetime" ["Escape"]
    //   Lifetime = (*) "Lifetime" ["Id"]
    //   Lifetime = (*) "Lifetime" ["mut"]
    //   Lifetime? = (*) ["&"]
    //   Lifetime? = (*) ["("]
    //   Lifetime? = (*) ["::"]
    //   Lifetime? = (*) ["Escape"]
    //   Lifetime? = (*) ["Id"]
    //   Lifetime? = (*) ["mut"]
    //   Lifetime? = (*) Lifetime ["&"]
    //   Lifetime? = (*) Lifetime ["("]
    //   Lifetime? = (*) Lifetime ["::"]
    //   Lifetime? = (*) Lifetime ["Escape"]
    //   Lifetime? = (*) Lifetime ["Id"]
    //   Lifetime? = (*) Lifetime ["mut"]
    //   TypeRef = "&" (*) Lifetime? "mut"? TypeRef [";"]
    //
    //   "&" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "::" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Lifetime" -> Shift(S58)
    //   "mut" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Id" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "(" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //   "Escape" -> Reduce(Lifetime? =  => Call(ActionFn(90));)
    //
    //   Lifetime -> S59
    //   Lifetime? -> S312
    pub fn __state268<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lifetime(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state58(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Mut(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action90(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Lifetime_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Lifetime(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state59(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Lifetime_3f(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state312(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 269
    //   TypeRef = Escape (*) [";"]
    //
    //   ";" -> Reduce(TypeRef = Escape => TryCall(ActionFn(45));)
    //
    pub fn __state269<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = try!(super::__action45(text, __sym0));
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 270
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["enum"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["type"]
    //
    //   ";" -> Shift(S313)
    //
    pub fn __state270<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state313(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 271
    //   (<TypeRef> ",")* = (*) ["&"]
    //   (<TypeRef> ",")* = (*) ["("]
    //   (<TypeRef> ",")* = (*) [")"]
    //   (<TypeRef> ",")* = (*) ["::"]
    //   (<TypeRef> ",")* = (*) ["Escape"]
    //   (<TypeRef> ",")* = (*) ["Id"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["&"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["("]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") [")"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["::"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Escape"]
    //   (<TypeRef> ",")* = (*) (<TypeRef> ",")* (<TypeRef> ",") ["Id"]
    //   Comma<TypeRef> = (*) (<TypeRef> ",")* TypeRef? [")"]
    //   TypeRef = "(" (*) Comma<TypeRef> ")" [";"]
    //
    //   "&" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Escape" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "(" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   ")" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "::" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //   "Id" -> Reduce((<TypeRef> ",")* =  => Call(ActionFn(142));)
    //
    //   Comma<TypeRef> -> S314
    //   (<TypeRef> ",")* -> S56
    pub fn __state271<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action142(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRef_3e(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state314(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::_28_3cTypeRef_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state56(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 272
    //   (<Id> "::")* = (*) ["Id"]
    //   (<Id> "::")* = (*) (<Id> "::")* (<Id> "::") ["Id"]
    //   Path = "::"? (*) (<Id> "::")* Id [";"]
    //   Path = "::"? (*) (<Id> "::")* Id ["<"]
    //
    //   "Id" -> Reduce((<Id> "::")* =  => Call(ActionFn(81));)
    //
    //   (<Id> "::")* -> S315
    pub fn __state272<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action81(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state315(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 273
    //   @R = (*) [";"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" (*) @R [";"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" (*) @R ["=>"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" (*) @R ["=>?"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" (*) @R ["=>@L"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" (*) @R ["=>@R"]
    //
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S316
    pub fn __state273<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<NonterminalString>,
        __sym2: &mut Option<ConditionOp>,
        __sym3: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state316(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 274
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["("]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [")"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["<"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@L"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["@R"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["Id"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["StringLiteral"]
    //
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S317
    pub fn __state274<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Star(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state317(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 275
    //   RepeatOp = "*" (*) ["("]
    //   RepeatOp = "*" (*) [")"]
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) ["<"]
    //   RepeatOp = "*" (*) ["?"]
    //   RepeatOp = "*" (*) ["@L"]
    //   RepeatOp = "*" (*) ["@R"]
    //   RepeatOp = "*" (*) ["Escape"]
    //   RepeatOp = "*" (*) ["Id"]
    //   RepeatOp = "*" (*) ["MacroId"]
    //   RepeatOp = "*" (*) ["StringLiteral"]
    //
    //   "<" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "(" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "@L" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "Id" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "MacroId" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   ")" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "@R" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "StringLiteral" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "Escape" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //
    pub fn __state275<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 276
    //   RepeatOp = "?" (*) ["("]
    //   RepeatOp = "?" (*) [")"]
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) ["<"]
    //   RepeatOp = "?" (*) ["?"]
    //   RepeatOp = "?" (*) ["@L"]
    //   RepeatOp = "?" (*) ["@R"]
    //   RepeatOp = "?" (*) ["Escape"]
    //   RepeatOp = "?" (*) ["Id"]
    //   RepeatOp = "?" (*) ["MacroId"]
    //   RepeatOp = "?" (*) ["StringLiteral"]
    //
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "(" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "StringLiteral" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "@L" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   ")" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "Id" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "MacroId" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "<" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "Escape" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "@R" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //
    pub fn __state276<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 277
    //   RepeatOp = "+" (*) ["("]
    //   RepeatOp = "+" (*) [")"]
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) ["<"]
    //   RepeatOp = "+" (*) ["?"]
    //   RepeatOp = "+" (*) ["@L"]
    //   RepeatOp = "+" (*) ["@R"]
    //   RepeatOp = "+" (*) ["Escape"]
    //   RepeatOp = "+" (*) ["Id"]
    //   RepeatOp = "+" (*) ["MacroId"]
    //   RepeatOp = "+" (*) ["StringLiteral"]
    //
    //   "Id" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "@L" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "@R" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   ")" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "Escape" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "StringLiteral" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "(" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "MacroId" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "<" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //
    pub fn __state277<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 278
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) ["<"]
    //   @R = (*) ["?"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["("]
    //   Symbol1 = @L SymbolKind1 (*) @R [")"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["<"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@L"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["@R"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Escape"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["Id"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["MacroId"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S318
    pub fn __state278<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Star(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state318(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 279
    //   SymbolKind1 = Terminal (*) ["("]
    //   SymbolKind1 = Terminal (*) [")"]
    //   SymbolKind1 = Terminal (*) ["*"]
    //   SymbolKind1 = Terminal (*) ["+"]
    //   SymbolKind1 = Terminal (*) ["<"]
    //   SymbolKind1 = Terminal (*) ["?"]
    //   SymbolKind1 = Terminal (*) ["@L"]
    //   SymbolKind1 = Terminal (*) ["@R"]
    //   SymbolKind1 = Terminal (*) ["Escape"]
    //   SymbolKind1 = Terminal (*) ["Id"]
    //   SymbolKind1 = Terminal (*) ["MacroId"]
    //   SymbolKind1 = Terminal (*) ["StringLiteral"]
    //
    //   "<" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "?" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "+" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "Id" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "(" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "Escape" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   ")" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "@R" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "@L" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "*" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "MacroId" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //
    pub fn __state279<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 280
    //   Id = "Id" (*) ["("]
    //   Id = "Id" (*) [")"]
    //   Id = "Id" (*) ["*"]
    //   Id = "Id" (*) ["+"]
    //   Id = "Id" (*) ["<"]
    //   Id = "Id" (*) ["?"]
    //   Id = "Id" (*) ["@L"]
    //   Id = "Id" (*) ["@R"]
    //   Id = "Id" (*) ["Escape"]
    //   Id = "Id" (*) ["Id"]
    //   Id = "Id" (*) ["MacroId"]
    //   Id = "Id" (*) ["StringLiteral"]
    //
    //   "@L" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "Escape" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "Id" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "+" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ")" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "*" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "MacroId" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "(" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "@R" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "?" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "StringLiteral" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state280<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 281
    //   SymbolKind1 = NonterminalId (*) ["("]
    //   SymbolKind1 = NonterminalId (*) [")"]
    //   SymbolKind1 = NonterminalId (*) ["*"]
    //   SymbolKind1 = NonterminalId (*) ["+"]
    //   SymbolKind1 = NonterminalId (*) ["<"]
    //   SymbolKind1 = NonterminalId (*) ["?"]
    //   SymbolKind1 = NonterminalId (*) ["@L"]
    //   SymbolKind1 = NonterminalId (*) ["@R"]
    //   SymbolKind1 = NonterminalId (*) ["Escape"]
    //   SymbolKind1 = NonterminalId (*) ["Id"]
    //   SymbolKind1 = NonterminalId (*) ["MacroId"]
    //   SymbolKind1 = NonterminalId (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "@R" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "MacroId" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "<" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "(" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   ")" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "+" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "@L" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "Escape" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "Id" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "*" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "?" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //
    pub fn __state281<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 282
    //   Terminal = StringLiteral (*) ["("]
    //   Terminal = StringLiteral (*) [")"]
    //   Terminal = StringLiteral (*) ["*"]
    //   Terminal = StringLiteral (*) ["+"]
    //   Terminal = StringLiteral (*) ["<"]
    //   Terminal = StringLiteral (*) ["?"]
    //   Terminal = StringLiteral (*) ["@L"]
    //   Terminal = StringLiteral (*) ["@R"]
    //   Terminal = StringLiteral (*) ["Escape"]
    //   Terminal = StringLiteral (*) ["Id"]
    //   Terminal = StringLiteral (*) ["MacroId"]
    //   Terminal = StringLiteral (*) ["StringLiteral"]
    //
    //   "@R" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "Id" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "*" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   ")" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "<" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "Escape" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "(" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "MacroId" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "+" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "@L" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "StringLiteral" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "?" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //
    pub fn __state282<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 283
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S320
    //   Symbol1 -> S220
    //   Symbol0 -> S319
    pub fn __state283<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state320(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state220(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state319(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 284
    //   StringLiteral = "StringLiteral" (*) ["("]
    //   StringLiteral = "StringLiteral" (*) [")"]
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) ["<"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //   StringLiteral = "StringLiteral" (*) ["@L"]
    //   StringLiteral = "StringLiteral" (*) ["@R"]
    //   StringLiteral = "StringLiteral" (*) ["Escape"]
    //   StringLiteral = "StringLiteral" (*) ["Id"]
    //   StringLiteral = "StringLiteral" (*) ["MacroId"]
    //   StringLiteral = "StringLiteral" (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "MacroId" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "StringLiteral" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   ")" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "@R" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "Escape" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "@L" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "Id" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "<" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //
    pub fn __state284<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 285
    //   SymbolKind1 = Escape (*) ["("]
    //   SymbolKind1 = Escape (*) [")"]
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) ["<"]
    //   SymbolKind1 = Escape (*) ["?"]
    //   SymbolKind1 = Escape (*) ["@L"]
    //   SymbolKind1 = Escape (*) ["@R"]
    //   SymbolKind1 = Escape (*) ["Escape"]
    //   SymbolKind1 = Escape (*) ["Id"]
    //   SymbolKind1 = Escape (*) ["MacroId"]
    //   SymbolKind1 = Escape (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "MacroId" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "@R" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "Escape" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "Id" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "@L" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "<" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   ")" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "(" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //
    pub fn __state285<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 286
    //   SymbolKind1 = "@L" (*) ["("]
    //   SymbolKind1 = "@L" (*) [")"]
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) ["<"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //   SymbolKind1 = "@L" (*) ["@L"]
    //   SymbolKind1 = "@L" (*) ["@R"]
    //   SymbolKind1 = "@L" (*) ["Escape"]
    //   SymbolKind1 = "@L" (*) ["Id"]
    //   SymbolKind1 = "@L" (*) ["MacroId"]
    //   SymbolKind1 = "@L" (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   ")" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "Escape" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "@R" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "<" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "@L" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "Id" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "(" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //
    pub fn __state286<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 287
    //   Escape = "Escape" (*) ["("]
    //   Escape = "Escape" (*) [")"]
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) ["<"]
    //   Escape = "Escape" (*) ["?"]
    //   Escape = "Escape" (*) ["@L"]
    //   Escape = "Escape" (*) ["@R"]
    //   Escape = "Escape" (*) ["Escape"]
    //   Escape = "Escape" (*) ["Id"]
    //   Escape = "Escape" (*) ["MacroId"]
    //   Escape = "Escape" (*) ["StringLiteral"]
    //
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "@R" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "<" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "Id" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "MacroId" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   ")" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "StringLiteral" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "(" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "@L" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "Escape" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state287<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 288
    //   NonterminalId = Id (*) ["("]
    //   NonterminalId = Id (*) [")"]
    //   NonterminalId = Id (*) ["*"]
    //   NonterminalId = Id (*) ["+"]
    //   NonterminalId = Id (*) ["<"]
    //   NonterminalId = Id (*) ["?"]
    //   NonterminalId = Id (*) ["@L"]
    //   NonterminalId = Id (*) ["@R"]
    //   NonterminalId = Id (*) ["Escape"]
    //   NonterminalId = Id (*) ["Id"]
    //   NonterminalId = Id (*) ["MacroId"]
    //   NonterminalId = Id (*) ["StringLiteral"]
    //
    //   "<" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "@L" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "?" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "@R" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ")" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "StringLiteral" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "+" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "*" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "Escape" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "Id" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "MacroId" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "(" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state288<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 289
    //   SymbolKind1 = "@R" (*) ["("]
    //   SymbolKind1 = "@R" (*) [")"]
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) ["<"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //   SymbolKind1 = "@R" (*) ["@L"]
    //   SymbolKind1 = "@R" (*) ["@R"]
    //   SymbolKind1 = "@R" (*) ["Escape"]
    //   SymbolKind1 = "@R" (*) ["Id"]
    //   SymbolKind1 = "@R" (*) ["MacroId"]
    //   SymbolKind1 = "@R" (*) ["StringLiteral"]
    //
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "<" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "(" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "Id" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "@L" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   ")" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "Escape" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "@R" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "MacroId" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //
    pub fn __state289<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 290
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["("]
    //   SymbolKind1 = "(" (*) Symbol* ")" [")"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["*"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["+"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["<"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["?"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["@L"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["@R"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["Escape"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["Id"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["MacroId"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //
    //   Symbol* -> S321
    pub fn __state290<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state321(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 291
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["StringLiteral"]
    //
    //   "<" -> Shift(S322)
    //
    pub fn __state291<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state322(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 292
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [";"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["=>@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["if"]
    //
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "=>@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "=>" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "=>@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   ";" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "=>?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "if" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //
    pub fn __state292<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 293
    //   (<Symbol> ",") = Symbol (*) "," ["("]
    //   (<Symbol> ",") = Symbol (*) "," ["<"]
    //   (<Symbol> ",") = Symbol (*) "," [">"]
    //   (<Symbol> ",") = Symbol (*) "," ["@L"]
    //   (<Symbol> ",") = Symbol (*) "," ["@R"]
    //   (<Symbol> ",") = Symbol (*) "," ["Escape"]
    //   (<Symbol> ",") = Symbol (*) "," ["Id"]
    //   (<Symbol> ",") = Symbol (*) "," ["MacroId"]
    //   (<Symbol> ",") = Symbol (*) "," ["StringLiteral"]
    //   Symbol? = Symbol (*) [">"]
    //
    //   "," -> Shift(S323)
    //   ">" -> Reduce(Symbol? = Symbol => Call(ActionFn(135));)
    //
    pub fn __state293<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state323(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action135(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 294
    //   Comma<Symbol> = (<Symbol> ",")* Symbol? (*) [">"]
    //
    //   ">" -> Reduce(Comma<Symbol> = (<Symbol> ",")*, Symbol? => Call(ActionFn(92));)
    //
    pub fn __state294<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<::std::option::Option<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action92(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cSymbol_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 295
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [","]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [","]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [","]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = Symbol0 (*) [","]
    //   Symbol = Symbol0 (*) [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [","]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "+" -> Shift(S324)
    //   "," -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //   "*" -> Shift(S327)
    //   "?" -> Shift(S326)
    //   ">" -> Reduce(Symbol = Symbol0 => Call(ActionFn(30));)
    //
    //   RepeatOp -> S325
    pub fn __state295<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state324(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state327(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state326(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action30(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state325(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 296
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["("]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["<"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) [">"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@L"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["@R"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Escape"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["Id"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["MacroId"]
    //   (<Symbol> ",")* = (<Symbol> ",")* (<Symbol> ",") (*) ["StringLiteral"]
    //
    //   "@L" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //   "(" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //   ">" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //   "Escape" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //   "@R" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //   "Id" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //   "<" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //   "MacroId" -> Reduce((<Symbol> ",")* = (<Symbol> ",")*, (<Symbol> ",") => Call(ActionFn(138));)
    //
    pub fn __state296<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Symbol>>,
        __sym1: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action138(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 297
    //   Symbol0 = Symbol1 (*) ["*"]
    //   Symbol0 = Symbol1 (*) ["+"]
    //   Symbol0 = Symbol1 (*) [","]
    //   Symbol0 = Symbol1 (*) [">"]
    //   Symbol0 = Symbol1 (*) ["?"]
    //
    //   "*" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   ">" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "+" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "?" -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //   "," -> Reduce(Symbol0 = Symbol1 => Call(ActionFn(31));)
    //
    pub fn __state297<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action31(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 298
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [","]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" ["*"]
    //   Id = (*) "Id" ["+"]
    //   Id = (*) "Id" [","]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "Id" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   NonterminalId = (*) Id ["*"]
    //   NonterminalId = (*) Id ["+"]
    //   NonterminalId = (*) Id [","]
    //   NonterminalId = (*) Id [">"]
    //   NonterminalId = (*) Id ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [","]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [","]
    //   Symbol = @L (*) "<" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [","]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [","]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) NonterminalId ["*"]
    //   SymbolKind1 = (*) NonterminalId ["+"]
    //   SymbolKind1 = (*) NonterminalId [","]
    //   SymbolKind1 = (*) NonterminalId [">"]
    //   SymbolKind1 = (*) NonterminalId ["?"]
    //   SymbolKind1 = (*) Terminal ["*"]
    //   SymbolKind1 = (*) Terminal ["+"]
    //   SymbolKind1 = (*) Terminal [","]
    //   SymbolKind1 = (*) Terminal [">"]
    //   SymbolKind1 = (*) Terminal ["?"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["*"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["+"]
    //   SymbolKind1 = (*) "(" Symbol* ")" [","]
    //   SymbolKind1 = (*) "(" Symbol* ")" [">"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [","]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [","]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   Terminal = (*) StringLiteral ["*"]
    //   Terminal = (*) StringLiteral ["+"]
    //   Terminal = (*) StringLiteral [","]
    //   Terminal = (*) StringLiteral [">"]
    //   Terminal = (*) StringLiteral ["?"]
    //
    //   "@L" -> Shift(S335)
    //   "@R" -> Shift(S338)
    //   "MacroId" -> Shift(S78)
    //   "<" -> Shift(S340)
    //   "Escape" -> Shift(S339)
    //   "(" -> Shift(S328)
    //   "StringLiteral" -> Shift(S333)
    //   "Id" -> Shift(S337)
    //
    //   Escape -> S329
    //   Id -> S330
    //   Terminal -> S341
    //   MacroId -> S336
    //   StringLiteral -> S334
    //   SymbolKind1 -> S331
    //   NonterminalId -> S332
    pub fn __state298<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state335(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state338(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state340(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state339(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state328(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state333(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state337(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state329(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state330(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Terminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state341(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state336(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state334(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state331(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state332(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 299
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [";"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["if"]
    //
    //   "=>" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   ";" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "=>?" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "=>@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "=>@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "if" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //
    pub fn __state299<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 300
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //
    pub fn __state300<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 301
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //
    pub fn __state301<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 302
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //
    //   (<Symbol> ",")* -> S242
    //   Comma<Symbol> -> S342
    pub fn __state302<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state242(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Comma_3cSymbol_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state342(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 303
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [";"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["if"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol1 -> S220
    //   Symbol0 -> S344
    //   @L -> S343
    pub fn __state303<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol1(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state220(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state344(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state343(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 304
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["*"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["+"]
    //   SymbolKind1 = "(" Symbol* (*) ")" [">"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["?"]
    //
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Shift(S345)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol1 -> S236
    //   @L -> S239
    //   Symbol0 -> S238
    //   Symbol -> S237
    pub fn __state304<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state345(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state236(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state239(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state238(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state237(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 305
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   @R = (*) ["}"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["("]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R [";"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["<"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["=>"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["=>?"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["=>@L"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["=>@R"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["@L"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["@R"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["Escape"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["Id"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["MacroId"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["StringLiteral"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["if"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" (*) @R ["}"]
    //
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S346
    pub fn __state305<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state346(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 306
    //   (<Conversion> ",") = Conversion (*) "," ["StringLiteral"]
    //   (<Conversion> ",") = Conversion (*) "," ["}"]
    //   Conversion? = Conversion (*) ["}"]
    //
    //   "," -> Shift(S347)
    //   "}" -> Reduce(Conversion? = Conversion => Call(ActionFn(150));)
    //
    pub fn __state306<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Conversion>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Comma(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state347(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action150(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Conversion_3f(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 307
    //   Comma<Conversion> = (<Conversion> ",")* Conversion? (*) ["}"]
    //
    //   "}" -> Reduce(Comma<Conversion> = (<Conversion> ",")*, Conversion? => Call(ActionFn(78));)
    //
    pub fn __state307<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Conversion>>,
        __sym1: &mut Option<::std::option::Option<Conversion>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action78(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Comma_3cConversion_3e(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 308
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["StringLiteral"]
    //   (<Conversion> ",")* = (<Conversion> ",")* (<Conversion> ",") (*) ["}"]
    //
    //   "}" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(153));)
    //   "StringLiteral" -> Reduce((<Conversion> ",")* = (<Conversion> ",")*, (<Conversion> ",") => Call(ActionFn(153));)
    //
    pub fn __state308<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<Conversion>>,
        __sym1: &mut Option<Conversion>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action153(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action153(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 309
    //   Conversion = @L (*) Terminal "=>" @R [","]
    //   Conversion = @L (*) Terminal "=>" @R ["}"]
    //   StringLiteral = (*) "StringLiteral" ["=>"]
    //   Terminal = (*) StringLiteral ["=>"]
    //
    //   "StringLiteral" -> Shift(S349)
    //
    //   StringLiteral -> S350
    //   Terminal -> S348
    pub fn __state309<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state349(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state350(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Terminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state348(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 310
    //   AssociatedType* = (*) ["type"]
    //   AssociatedType* = (*) ["}"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["type"]
    //   AssociatedType* = (*) AssociatedType* AssociatedType ["}"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" (*) AssociatedType* "}" ["use"]
    //
    //   "type" -> Reduce(AssociatedType* =  => Call(ActionFn(79));)
    //   "}" -> Reduce(AssociatedType* =  => Call(ActionFn(79));)
    //
    //   AssociatedType* -> S351
    pub fn __state310<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
        __sym8: &mut Option<TypeRef>,
        __sym9: &mut Option<usize>,
        __sym10: &mut Option<Tok<'input>>,
        __sym11: &mut Option<Vec<Conversion>>,
        __sym12: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Type(..), _)) => {
                let __nt = super::__action79(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = super::__action79(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym12.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AssociatedType_2a(__nt) => {
                    let __sym13 = &mut Some(__nt);
                    __result = try!(__state351(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 311
    //   (<TypeRefOrLifetime> ",")* = (*) ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) ["Lifetime"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["&"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["("]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["::"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") [">"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Escape"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Id"]
    //   (<TypeRefOrLifetime> ",")* = (*) (<TypeRefOrLifetime> ",")* (<TypeRefOrLifetime> ",") ["Lifetime"]
    //   Comma<TypeRefOrLifetime> = (*) (<TypeRefOrLifetime> ",")* TypeRefOrLifetime? [">"]
    //   TypeRef = Path "<" (*) Comma<TypeRefOrLifetime> ">" [";"]
    //
    //   "&" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Id" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Escape" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "Lifetime" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   ">" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "(" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //   "::" -> Reduce((<TypeRefOrLifetime> ",")* =  => Call(ActionFn(147));)
    //
    //   Comma<TypeRefOrLifetime> -> S352
    //   (<TypeRefOrLifetime> ",")* -> S65
    pub fn __state311<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lifetime(_), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action147(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cTypeRefOrLifetime_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state352(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cTypeRefOrLifetime_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state65(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 312
    //   "mut"? = (*) ["&"]
    //   "mut"? = (*) ["("]
    //   "mut"? = (*) ["::"]
    //   "mut"? = (*) ["Escape"]
    //   "mut"? = (*) ["Id"]
    //   "mut"? = (*) "mut" ["&"]
    //   "mut"? = (*) "mut" ["("]
    //   "mut"? = (*) "mut" ["::"]
    //   "mut"? = (*) "mut" ["Escape"]
    //   "mut"? = (*) "mut" ["Id"]
    //   TypeRef = "&" Lifetime? (*) "mut"? TypeRef [";"]
    //
    //   "&" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "mut" -> Shift(S74)
    //   "(" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Escape" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "Id" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //   "::" -> Reduce("mut"? =  => Call(ActionFn(88));)
    //
    //   "mut"? -> S353
    pub fn __state312<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Mut(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state74(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            Some((_, Tok::Ampersand(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __nt = super::__action88(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22mut_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_22mut_22_3f(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state353(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 313
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["enum"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["type"]
    //
    //   "enum" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(53));)
    //   "type" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(53));)
    //
    pub fn __state313<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<TypeRef>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Enum(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action53(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType(__nt)));
            }
            Some((_, Tok::Type(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action53(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 314
    //   TypeRef = "(" Comma<TypeRef> (*) ")" [";"]
    //
    //   ")" -> Shift(S354)
    //
    pub fn __state314<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state354(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 315
    //   (<Id> "::") = (*) Id "::" ["Id"]
    //   (<Id> "::")* = (<Id> "::")* (*) (<Id> "::") ["Id"]
    //   Id = (*) "Id" ["::"]
    //   Id = (*) "Id" [";"]
    //   Id = (*) "Id" ["<"]
    //   Path = "::"? (<Id> "::")* (*) Id [";"]
    //   Path = "::"? (<Id> "::")* (*) Id ["<"]
    //
    //   "Id" -> Shift(S356)
    //
    //   (<Id> "::") -> S70
    //   Id -> S355
    pub fn __state315<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state356(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_28_3cId_3e_20_22_3a_3a_22_29(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state70(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state355(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 316
    //   Cond = @L NonterminalId CondOp "StringLiteral" @R (*) [";"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" @R (*) ["=>"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" @R (*) ["=>?"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" @R (*) ["=>@L"]
    //   Cond = @L NonterminalId CondOp "StringLiteral" @R (*) ["=>@R"]
    //
    //   ";" -> Reduce(Cond = @L, NonterminalId, CondOp, "StringLiteral", @R => Call(ActionFn(23));)
    //   "=>" -> Reduce(Cond = @L, NonterminalId, CondOp, "StringLiteral", @R => Call(ActionFn(23));)
    //   "=>?" -> Reduce(Cond = @L, NonterminalId, CondOp, "StringLiteral", @R => Call(ActionFn(23));)
    //   "=>@L" -> Reduce(Cond = @L, NonterminalId, CondOp, "StringLiteral", @R => Call(ActionFn(23));)
    //   "=>@R" -> Reduce(Cond = @L, NonterminalId, CondOp, "StringLiteral", @R => Call(ActionFn(23));)
    //
    pub fn __state316<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<NonterminalString>,
        __sym2: &mut Option<ConditionOp>,
        __sym3: &mut Option<&'input str>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action23(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Cond(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action23(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Cond(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action23(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Cond(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action23(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Cond(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action23(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Cond(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 317
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["("]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [")"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["<"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@L"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["@R"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Escape"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["Id"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["MacroId"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   ")" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "@R" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "MacroId" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "Escape" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "(" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "@L" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "Id" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "<" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //
    pub fn __state317<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 318
    //   Symbol1 = @L SymbolKind1 @R (*) ["("]
    //   Symbol1 = @L SymbolKind1 @R (*) [")"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["<"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@L"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["@R"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Escape"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["Id"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["MacroId"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["StringLiteral"]
    //
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "@L" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "StringLiteral" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "Escape" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "MacroId" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   ")" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "<" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "@R" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "(" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "Id" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //
    pub fn __state318<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 319
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "?" -> Shift(S245)
    //   "*" -> Shift(S246)
    //   ">" -> Shift(S357)
    //   "+" -> Shift(S244)
    //
    //   RepeatOp -> S247
    pub fn __state319<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state245(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state246(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state357(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state244(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state247(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 320
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" ["*"]
    //   Id = (*) "Id" ["+"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "Id" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   NonterminalId = (*) Id ["*"]
    //   NonterminalId = (*) Id ["+"]
    //   NonterminalId = (*) Id [">"]
    //   NonterminalId = (*) Id ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) NonterminalId ["*"]
    //   SymbolKind1 = (*) NonterminalId ["+"]
    //   SymbolKind1 = (*) NonterminalId [">"]
    //   SymbolKind1 = (*) NonterminalId ["?"]
    //   SymbolKind1 = (*) Terminal ["*"]
    //   SymbolKind1 = (*) Terminal ["+"]
    //   SymbolKind1 = (*) Terminal [">"]
    //   SymbolKind1 = (*) Terminal ["?"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["*"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["+"]
    //   SymbolKind1 = (*) "(" Symbol* ")" [">"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   Terminal = (*) StringLiteral ["*"]
    //   Terminal = (*) StringLiteral ["+"]
    //   Terminal = (*) StringLiteral [">"]
    //   Terminal = (*) StringLiteral ["?"]
    //
    //   "@R" -> Shift(S255)
    //   "Escape" -> Shift(S258)
    //   "Id" -> Shift(S259)
    //   "(" -> Shift(S260)
    //   "StringLiteral" -> Shift(S253)
    //   "@L" -> Shift(S252)
    //   "MacroId" -> Shift(S78)
    //
    //   MacroId -> S250
    //   Terminal -> S248
    //   Id -> S358
    //   SymbolKind1 -> S249
    //   NonterminalId -> S254
    //   Escape -> S257
    //   StringLiteral -> S256
    pub fn __state320<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state255(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state258(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state259(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state260(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state253(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state252(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::MacroId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state250(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Terminal(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state248(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state358(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state249(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state254(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state257(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state256(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 321
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["("]
    //   SymbolKind1 = "(" Symbol* (*) ")" [")"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["*"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["+"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["<"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["?"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["@L"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["@R"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["Escape"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["Id"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["MacroId"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["StringLiteral"]
    //
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Shift(S359)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S239
    //   Symbol0 -> S238
    //   Symbol -> S237
    //   Symbol1 -> S236
    pub fn __state321<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state359(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state239(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state238(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state237(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state236(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 322
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["("]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [")"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["<"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@L"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["@R"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["Id"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["StringLiteral"]
    //
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //
    //   Comma<Symbol> -> S360
    //   (<Symbol> ",")* -> S242
    pub fn __state322<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cSymbol_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state360(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state242(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 323
    //   (<Symbol> ",") = Symbol "," (*) ["("]
    //   (<Symbol> ",") = Symbol "," (*) ["<"]
    //   (<Symbol> ",") = Symbol "," (*) [">"]
    //   (<Symbol> ",") = Symbol "," (*) ["@L"]
    //   (<Symbol> ",") = Symbol "," (*) ["@R"]
    //   (<Symbol> ",") = Symbol "," (*) ["Escape"]
    //   (<Symbol> ",") = Symbol "," (*) ["Id"]
    //   (<Symbol> ",") = Symbol "," (*) ["MacroId"]
    //   (<Symbol> ",") = Symbol "," (*) ["StringLiteral"]
    //
    //   "MacroId" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //   "(" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //   ">" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //   "@L" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //   "StringLiteral" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //   "Id" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //   "<" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //   "Escape" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //   "@R" -> Reduce((<Symbol> ",") = Symbol, "," => Call(ActionFn(139));)
    //
    pub fn __state323<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action139(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 324
    //   RepeatOp = "+" (*) ["*"]
    //   RepeatOp = "+" (*) ["+"]
    //   RepeatOp = "+" (*) [","]
    //   RepeatOp = "+" (*) [">"]
    //   RepeatOp = "+" (*) ["?"]
    //
    //   "*" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "?" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "+" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   ">" -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //   "," -> Reduce(RepeatOp = "+" => Call(ActionFn(33));)
    //
    pub fn __state324<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action33(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 325
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["*"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["+"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [","]
    //   Symbol0 = Symbol0 RepeatOp (*) @R [">"]
    //   Symbol0 = Symbol0 RepeatOp (*) @R ["?"]
    //
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S361
    pub fn __state325<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Star(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state361(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 326
    //   RepeatOp = "?" (*) ["*"]
    //   RepeatOp = "?" (*) ["+"]
    //   RepeatOp = "?" (*) [","]
    //   RepeatOp = "?" (*) [">"]
    //   RepeatOp = "?" (*) ["?"]
    //
    //   "*" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "?" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "+" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   "," -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //   ">" -> Reduce(RepeatOp = "?" => Call(ActionFn(35));)
    //
    pub fn __state326<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action35(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 327
    //   RepeatOp = "*" (*) ["*"]
    //   RepeatOp = "*" (*) ["+"]
    //   RepeatOp = "*" (*) [","]
    //   RepeatOp = "*" (*) [">"]
    //   RepeatOp = "*" (*) ["?"]
    //
    //   ">" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "*" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "?" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "+" -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //   "," -> Reduce(RepeatOp = "*" => Call(ActionFn(34));)
    //
    pub fn __state327<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action34(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::RepeatOp(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 328
    //   Symbol* = (*) ["("]
    //   Symbol* = (*) [")"]
    //   Symbol* = (*) ["<"]
    //   Symbol* = (*) ["@L"]
    //   Symbol* = (*) ["@R"]
    //   Symbol* = (*) ["Escape"]
    //   Symbol* = (*) ["Id"]
    //   Symbol* = (*) ["MacroId"]
    //   Symbol* = (*) ["StringLiteral"]
    //   Symbol* = (*) Symbol* Symbol ["("]
    //   Symbol* = (*) Symbol* Symbol [")"]
    //   Symbol* = (*) Symbol* Symbol ["<"]
    //   Symbol* = (*) Symbol* Symbol ["@L"]
    //   Symbol* = (*) Symbol* Symbol ["@R"]
    //   Symbol* = (*) Symbol* Symbol ["Escape"]
    //   Symbol* = (*) Symbol* Symbol ["Id"]
    //   Symbol* = (*) Symbol* Symbol ["MacroId"]
    //   Symbol* = (*) Symbol* Symbol ["StringLiteral"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["*"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["+"]
    //   SymbolKind1 = "(" (*) Symbol* ")" [","]
    //   SymbolKind1 = "(" (*) Symbol* ")" [">"]
    //   SymbolKind1 = "(" (*) Symbol* ")" ["?"]
    //
    //   "MacroId" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "StringLiteral" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   ")" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@L" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Escape" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "<" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "Id" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "(" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //   "@R" -> Reduce(Symbol* =  => Call(ActionFn(98));)
    //
    //   Symbol* -> S362
    pub fn __state328<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action98(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::Symbol_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol_2a(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state362(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 329
    //   SymbolKind1 = Escape (*) ["*"]
    //   SymbolKind1 = Escape (*) ["+"]
    //   SymbolKind1 = Escape (*) [","]
    //   SymbolKind1 = Escape (*) [">"]
    //   SymbolKind1 = Escape (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "+" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   ">" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "," -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //   "?" -> Reduce(SymbolKind1 = Escape => Call(ActionFn(40));)
    //
    pub fn __state329<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action40(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 330
    //   NonterminalId = Id (*) ["*"]
    //   NonterminalId = Id (*) ["+"]
    //   NonterminalId = Id (*) [","]
    //   NonterminalId = Id (*) [">"]
    //   NonterminalId = Id (*) ["?"]
    //
    //   "*" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "," -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ">" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "+" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "?" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state330<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 331
    //   @R = (*) ["*"]
    //   @R = (*) ["+"]
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   @R = (*) ["?"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["*"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["+"]
    //   Symbol1 = @L SymbolKind1 (*) @R [","]
    //   Symbol1 = @L SymbolKind1 (*) @R [">"]
    //   Symbol1 = @L SymbolKind1 (*) @R ["?"]
    //
    //   "?" -> Reduce(@R =  => Lookbehind;)
    //   "*" -> Reduce(@R =  => Lookbehind;)
    //   "+" -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S363
    pub fn __state331<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Star(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state363(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 332
    //   SymbolKind1 = NonterminalId (*) ["*"]
    //   SymbolKind1 = NonterminalId (*) ["+"]
    //   SymbolKind1 = NonterminalId (*) [","]
    //   SymbolKind1 = NonterminalId (*) [">"]
    //   SymbolKind1 = NonterminalId (*) ["?"]
    //
    //   "+" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "?" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "*" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   "," -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //   ">" -> Reduce(SymbolKind1 = NonterminalId => Call(ActionFn(39));)
    //
    pub fn __state332<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action39(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 333
    //   StringLiteral = "StringLiteral" (*) ["*"]
    //   StringLiteral = "StringLiteral" (*) ["+"]
    //   StringLiteral = "StringLiteral" (*) [","]
    //   StringLiteral = "StringLiteral" (*) [">"]
    //   StringLiteral = "StringLiteral" (*) ["?"]
    //
    //   "*" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   ">" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "?" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "," -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //   "+" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //
    pub fn __state333<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 334
    //   Terminal = StringLiteral (*) ["*"]
    //   Terminal = StringLiteral (*) ["+"]
    //   Terminal = StringLiteral (*) [","]
    //   Terminal = StringLiteral (*) [">"]
    //   Terminal = StringLiteral (*) ["?"]
    //
    //   "+" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "," -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "?" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   "*" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //   ">" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //
    pub fn __state334<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 335
    //   SymbolKind1 = "@L" (*) ["*"]
    //   SymbolKind1 = "@L" (*) ["+"]
    //   SymbolKind1 = "@L" (*) [","]
    //   SymbolKind1 = "@L" (*) [">"]
    //   SymbolKind1 = "@L" (*) ["?"]
    //
    //   ">" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "*" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "+" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "?" -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //   "," -> Reduce(SymbolKind1 = "@L" => Call(ActionFn(42));)
    //
    pub fn __state335<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action42(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 336
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId (*) "<" Comma<Symbol> ">" ["?"]
    //
    //   "<" -> Shift(S364)
    //
    pub fn __state336<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::LessThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state364(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 337
    //   Id = "Id" (*) ["*"]
    //   Id = "Id" (*) ["+"]
    //   Id = "Id" (*) [","]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["?"]
    //
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "," -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "?" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "*" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "+" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state337<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 338
    //   SymbolKind1 = "@R" (*) ["*"]
    //   SymbolKind1 = "@R" (*) ["+"]
    //   SymbolKind1 = "@R" (*) [","]
    //   SymbolKind1 = "@R" (*) [">"]
    //   SymbolKind1 = "@R" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "," -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   ">" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "?" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //   "+" -> Reduce(SymbolKind1 = "@R" => Call(ActionFn(43));)
    //
    pub fn __state338<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action43(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 339
    //   Escape = "Escape" (*) ["*"]
    //   Escape = "Escape" (*) ["+"]
    //   Escape = "Escape" (*) [","]
    //   Escape = "Escape" (*) [">"]
    //   Escape = "Escape" (*) ["?"]
    //
    //   ">" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "*" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "?" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "," -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //   "+" -> Reduce(Escape = "Escape" => Call(ActionFn(68));)
    //
    pub fn __state339<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action68(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Escape(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 340
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) @L Id ":" Symbol0 ">" @R [">"]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol0 -> S365
    //   @L -> S366
    //   Symbol1 -> S220
    pub fn __state340<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state365(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state366(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state220(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 341
    //   SymbolKind1 = Terminal (*) ["*"]
    //   SymbolKind1 = Terminal (*) ["+"]
    //   SymbolKind1 = Terminal (*) [","]
    //   SymbolKind1 = Terminal (*) [">"]
    //   SymbolKind1 = Terminal (*) ["?"]
    //
    //   "," -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "?" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   ">" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "*" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //   "+" -> Reduce(SymbolKind1 = Terminal => Call(ActionFn(38));)
    //
    pub fn __state341<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action38(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 342
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //
    //   ">" -> Shift(S367)
    //
    pub fn __state342<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state367(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 343
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" ["*"]
    //   Id = (*) "Id" ["+"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "Id" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   NonterminalId = (*) Id ["*"]
    //   NonterminalId = (*) Id ["+"]
    //   NonterminalId = (*) Id [">"]
    //   NonterminalId = (*) Id ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) NonterminalId ["*"]
    //   SymbolKind1 = (*) NonterminalId ["+"]
    //   SymbolKind1 = (*) NonterminalId [">"]
    //   SymbolKind1 = (*) NonterminalId ["?"]
    //   SymbolKind1 = (*) Terminal ["*"]
    //   SymbolKind1 = (*) Terminal ["+"]
    //   SymbolKind1 = (*) Terminal [">"]
    //   SymbolKind1 = (*) Terminal ["?"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["*"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["+"]
    //   SymbolKind1 = (*) "(" Symbol* ")" [">"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   Terminal = (*) StringLiteral ["*"]
    //   Terminal = (*) StringLiteral ["+"]
    //   Terminal = (*) StringLiteral [">"]
    //   Terminal = (*) StringLiteral ["?"]
    //
    //   "MacroId" -> Shift(S78)
    //   "Id" -> Shift(S369)
    //   "@L" -> Shift(S252)
    //   "@R" -> Shift(S255)
    //   "StringLiteral" -> Shift(S253)
    //   "Escape" -> Shift(S258)
    //   "(" -> Shift(S260)
    //
    //   SymbolKind1 -> S249
    //   StringLiteral -> S256
    //   Escape -> S257
    //   Terminal -> S248
    //   MacroId -> S250
    //   NonterminalId -> S254
    //   Id -> S368
    pub fn __state343<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state369(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state252(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state255(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state253(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state258(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym1 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state260(text, __lookbehind, __lookahead, __tokens, __sym1));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state249(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state256(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state257(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Terminal(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state248(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::MacroId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state250(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state254(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state368(text, __lookbehind, __lookahead, __tokens, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 344
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["if"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "?" -> Shift(S245)
    //   ">" -> Shift(S370)
    //   "+" -> Shift(S244)
    //   "*" -> Shift(S246)
    //
    //   RepeatOp -> S247
    pub fn __state344<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state245(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state370(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state244(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state246(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state247(text, __lookbehind, __lookahead, __tokens, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 345
    //   SymbolKind1 = "(" Symbol* ")" (*) ["*"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["+"]
    //   SymbolKind1 = "(" Symbol* ")" (*) [">"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["?"]
    //
    //   "*" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   ">" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "+" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "?" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //
    pub fn __state345<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 346
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["("]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) [";"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["<"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["=>"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["=>?"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["=>@L"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["=>@R"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["@L"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["@R"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["Escape"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["Id"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["MacroId"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["StringLiteral"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["if"]
    //   Alternative = @L Symbol* ("if" <Cond>)? Action? ";" @R (*) ["}"]
    //
    //   "@R" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "(" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "@L" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "Escape" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "=>@L" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "=>?" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "=>" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "if" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   ";" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "=>@R" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "MacroId" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "<" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "StringLiteral" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "}" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //   "Id" -> Reduce(Alternative = @L, Symbol*, ("if" <Cond>)?, Action?, ";", @R => Call(ActionFn(18));)
    //
    pub fn __state346<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<::std::option::Option<Condition>>,
        __sym3: &mut Option<::std::option::Option<ActionKind>>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __nt = super::__action18(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Alternative(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 347
    //   (<Conversion> ",") = Conversion "," (*) ["StringLiteral"]
    //   (<Conversion> ",") = Conversion "," (*) ["}"]
    //
    //   "}" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(154));)
    //   "StringLiteral" -> Reduce((<Conversion> ",") = Conversion, "," => Call(ActionFn(154));)
    //
    pub fn __state347<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Conversion>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action154(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action154(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::_28_3cConversion_3e_20_22_2c_22_29(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 348
    //   Conversion = @L Terminal (*) "=>" @R [","]
    //   Conversion = @L Terminal (*) "=>" @R ["}"]
    //
    //   "=>" -> Shift(S371)
    //
    pub fn __state348<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<TerminalString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state371(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 349
    //   StringLiteral = "StringLiteral" (*) ["=>"]
    //
    //   "=>" -> Reduce(StringLiteral = "StringLiteral" => Call(ActionFn(71));)
    //
    pub fn __state349<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action71(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::StringLiteral(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 350
    //   Terminal = StringLiteral (*) ["=>"]
    //
    //   "=>" -> Reduce(Terminal = StringLiteral => Call(ActionFn(70));)
    //
    pub fn __state350<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action70(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Terminal(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 351
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = (*) "type" @L Id @R "=" TypeRef ";" ["}"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["type"]
    //   AssociatedType* = AssociatedType* (*) AssociatedType ["}"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* (*) "}" ["use"]
    //
    //   "type" -> Shift(S372)
    //   "}" -> Shift(S373)
    //
    //   AssociatedType -> S374
    pub fn __state351<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
        __sym8: &mut Option<TypeRef>,
        __sym9: &mut Option<usize>,
        __sym10: &mut Option<Tok<'input>>,
        __sym11: &mut Option<Vec<Conversion>>,
        __sym12: &mut Option<Tok<'input>>,
        __sym13: &mut Option<::std::vec::Vec<AssociatedType>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Type(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym14 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state372(text, __lookbehind, __lookahead, __tokens, __sym14));
            }
            Some((_, __tok @ Tok::RightBrace(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym14 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state373(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym13.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::AssociatedType(__nt) => {
                    let __sym14 = &mut Some(__nt);
                    __result = try!(__state374(text, __lookbehind, __lookahead, __tokens, __sym13, __sym14));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 352
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> (*) ">" [";"]
    //
    //   ">" -> Shift(S375)
    //
    pub fn __state352<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state375(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 353
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   Escape = (*) "Escape" [";"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Escape [";"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = "&" Lifetime? "mut"? (*) TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //   "Escape" -> Shift(S267)
    //   "&" -> Shift(S268)
    //   "(" -> Shift(S271)
    //   "::" -> Shift(S41)
    //
    //   TypeRef -> S376
    //   "::"? -> S272
    //   Escape -> S269
    //   Path -> S266
    pub fn __state353<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state267(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state268(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state271(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::TypeRef(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state376(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state272(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state269(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Path(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state266(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 354
    //   TypeRef = "(" Comma<TypeRef> ")" (*) [";"]
    //
    //   ";" -> Reduce(TypeRef = "(", Comma<TypeRef>, ")" => Call(ActionFn(44));)
    //
    pub fn __state354<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<Vec<TypeRef>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action44(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 355
    //   (<Id> "::") = Id (*) "::" ["Id"]
    //   Path = "::"? (<Id> "::")* Id (*) [";"]
    //   Path = "::"? (<Id> "::")* Id (*) ["<"]
    //
    //   "<" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //   "::" -> Shift(S97)
    //   ";" -> Reduce(Path = "::"?, (<Id> "::")*, Id => Call(ActionFn(51));)
    //
    pub fn __state355<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym1: &mut Option<::std::vec::Vec<InternedString>>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state97(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action51(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Path(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 356
    //   Id = "Id" (*) ["::"]
    //   Id = "Id" (*) [";"]
    //   Id = "Id" (*) ["<"]
    //
    //   "<" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ";" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "::" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state356<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::ColonColon(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 357
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R ["StringLiteral"]
    //
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S377
    pub fn __state357<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state377(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 358
    //   NonterminalId = Id (*) ["*"]
    //   NonterminalId = Id (*) ["+"]
    //   NonterminalId = Id (*) [">"]
    //   NonterminalId = Id (*) ["?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R ["StringLiteral"]
    //
    //   "*" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ">" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "?" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ":" -> Shift(S378)
    //   "+" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state358<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state378(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 359
    //   SymbolKind1 = "(" Symbol* ")" (*) ["("]
    //   SymbolKind1 = "(" Symbol* ")" (*) [")"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["*"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["+"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["<"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["?"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["@L"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["@R"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["Escape"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["Id"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["MacroId"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["StringLiteral"]
    //
    //   "*" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "+" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   ")" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "@R" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "Id" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "<" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "MacroId" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "Escape" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "?" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "@L" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "(" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //
    pub fn __state359<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 360
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["StringLiteral"]
    //
    //   ">" -> Shift(S379)
    //
    pub fn __state360<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state379(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 361
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["*"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["+"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [","]
    //   Symbol0 = Symbol0 RepeatOp @R (*) [">"]
    //   Symbol0 = Symbol0 RepeatOp @R (*) ["?"]
    //
    //   "+" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "," -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "?" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   "*" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //   ">" -> Reduce(Symbol0 = Symbol0, RepeatOp, @R => Call(ActionFn(32));)
    //
    pub fn __state361<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Symbol>,
        __sym1: &mut Option<RepeatOp>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action32(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol0(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 362
    //   @L = (*) ["("]
    //   @L = (*) ["<"]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" @L Id ":" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["("]
    //   Symbol = (*) @L "<" Symbol0 ">" @R [")"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["<"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@L"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["@R"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Escape"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["Id"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["MacroId"]
    //   Symbol = (*) @L "<" Symbol0 ">" @R ["StringLiteral"]
    //   Symbol = (*) Symbol0 ["("]
    //   Symbol = (*) Symbol0 [")"]
    //   Symbol = (*) Symbol0 ["<"]
    //   Symbol = (*) Symbol0 ["@L"]
    //   Symbol = (*) Symbol0 ["@R"]
    //   Symbol = (*) Symbol0 ["Escape"]
    //   Symbol = (*) Symbol0 ["Id"]
    //   Symbol = (*) Symbol0 ["MacroId"]
    //   Symbol = (*) Symbol0 ["StringLiteral"]
    //   Symbol* = Symbol* (*) Symbol ["("]
    //   Symbol* = Symbol* (*) Symbol [")"]
    //   Symbol* = Symbol* (*) Symbol ["<"]
    //   Symbol* = Symbol* (*) Symbol ["@L"]
    //   Symbol* = Symbol* (*) Symbol ["@R"]
    //   Symbol* = Symbol* (*) Symbol ["Escape"]
    //   Symbol* = Symbol* (*) Symbol ["Id"]
    //   Symbol* = Symbol* (*) Symbol ["MacroId"]
    //   Symbol* = Symbol* (*) Symbol ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["("]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [")"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["<"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@L"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["@R"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Escape"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["Id"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["MacroId"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol1 ["("]
    //   Symbol0 = (*) Symbol1 [")"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 ["<"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol0 = (*) Symbol1 ["@L"]
    //   Symbol0 = (*) Symbol1 ["@R"]
    //   Symbol0 = (*) Symbol1 ["Escape"]
    //   Symbol0 = (*) Symbol1 ["Id"]
    //   Symbol0 = (*) Symbol1 ["MacroId"]
    //   Symbol0 = (*) Symbol1 ["StringLiteral"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["("]
    //   Symbol1 = (*) @L SymbolKind1 @R [")"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["<"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@L"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["@R"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Escape"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["Id"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["MacroId"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["StringLiteral"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["*"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["+"]
    //   SymbolKind1 = "(" Symbol* (*) ")" [","]
    //   SymbolKind1 = "(" Symbol* (*) ")" [">"]
    //   SymbolKind1 = "(" Symbol* (*) ")" ["?"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   ")" -> Shift(S380)
    //   "<" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol1 -> S236
    //   @L -> S239
    //   Symbol -> S237
    //   Symbol0 -> S238
    pub fn __state362<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::RightParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state380(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol1(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state236(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state239(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                __Nonterminal::Symbol(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state237(text, __lookbehind, __lookahead, __tokens, __sym1, __sym2));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state238(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 363
    //   Symbol1 = @L SymbolKind1 @R (*) ["*"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["+"]
    //   Symbol1 = @L SymbolKind1 @R (*) [","]
    //   Symbol1 = @L SymbolKind1 @R (*) [">"]
    //   Symbol1 = @L SymbolKind1 @R (*) ["?"]
    //
    //   "?" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "," -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "*" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   ">" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //   "+" -> Reduce(Symbol1 = @L, SymbolKind1, @R => Call(ActionFn(36));)
    //
    pub fn __state363<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<SymbolKind>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action36(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 364
    //   (<Symbol> ",")* = (*) ["("]
    //   (<Symbol> ",")* = (*) ["<"]
    //   (<Symbol> ",")* = (*) [">"]
    //   (<Symbol> ",")* = (*) ["@L"]
    //   (<Symbol> ",")* = (*) ["@R"]
    //   (<Symbol> ",")* = (*) ["Escape"]
    //   (<Symbol> ",")* = (*) ["Id"]
    //   (<Symbol> ",")* = (*) ["MacroId"]
    //   (<Symbol> ",")* = (*) ["StringLiteral"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["("]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["<"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") [">"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@L"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["@R"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Escape"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["Id"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["MacroId"]
    //   (<Symbol> ",")* = (*) (<Symbol> ",")* (<Symbol> ",") ["StringLiteral"]
    //   Comma<Symbol> = (*) (<Symbol> ",")* Symbol? [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [","]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" [">"]
    //   SymbolKind1 = MacroId "<" (*) Comma<Symbol> ">" ["?"]
    //
    //   "(" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "StringLiteral" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   ">" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "@R" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "Id" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "MacroId" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "<" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "@L" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //   "Escape" -> Reduce((<Symbol> ",")* =  => Call(ActionFn(137));)
    //
    //   Comma<Symbol> -> S381
    //   (<Symbol> ",")* -> S242
    pub fn __state364<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = super::__action137(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Comma_3cSymbol_3e(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state381(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                __Nonterminal::_28_3cSymbol_3e_20_22_2c_22_29_2a(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state242(text, __lookbehind, __lookahead, __tokens, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 365
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "+" -> Shift(S244)
    //   "?" -> Shift(S245)
    //   ">" -> Shift(S382)
    //   "*" -> Shift(S246)
    //
    //   RepeatOp -> S247
    pub fn __state365<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state244(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state245(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state382(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state246(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state247(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 366
    //   Escape = (*) "Escape" ["*"]
    //   Escape = (*) "Escape" ["+"]
    //   Escape = (*) "Escape" [">"]
    //   Escape = (*) "Escape" ["?"]
    //   Id = (*) "Id" ["*"]
    //   Id = (*) "Id" ["+"]
    //   Id = (*) "Id" [":"]
    //   Id = (*) "Id" [">"]
    //   Id = (*) "Id" ["?"]
    //   MacroId = (*) "MacroId" ["<"]
    //   NonterminalId = (*) Id ["*"]
    //   NonterminalId = (*) Id ["+"]
    //   NonterminalId = (*) Id [">"]
    //   NonterminalId = (*) Id ["?"]
    //   StringLiteral = (*) "StringLiteral" ["*"]
    //   StringLiteral = (*) "StringLiteral" ["+"]
    //   StringLiteral = (*) "StringLiteral" [">"]
    //   StringLiteral = (*) "StringLiteral" ["?"]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L (*) Id ":" Symbol0 ">" @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["*"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["+"]
    //   Symbol1 = @L (*) SymbolKind1 @R [">"]
    //   Symbol1 = @L (*) SymbolKind1 @R ["?"]
    //   SymbolKind1 = (*) Escape ["*"]
    //   SymbolKind1 = (*) Escape ["+"]
    //   SymbolKind1 = (*) Escape [">"]
    //   SymbolKind1 = (*) Escape ["?"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["*"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["+"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" [">"]
    //   SymbolKind1 = (*) MacroId "<" Comma<Symbol> ">" ["?"]
    //   SymbolKind1 = (*) NonterminalId ["*"]
    //   SymbolKind1 = (*) NonterminalId ["+"]
    //   SymbolKind1 = (*) NonterminalId [">"]
    //   SymbolKind1 = (*) NonterminalId ["?"]
    //   SymbolKind1 = (*) Terminal ["*"]
    //   SymbolKind1 = (*) Terminal ["+"]
    //   SymbolKind1 = (*) Terminal [">"]
    //   SymbolKind1 = (*) Terminal ["?"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["*"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["+"]
    //   SymbolKind1 = (*) "(" Symbol* ")" [">"]
    //   SymbolKind1 = (*) "(" Symbol* ")" ["?"]
    //   SymbolKind1 = (*) "@L" ["*"]
    //   SymbolKind1 = (*) "@L" ["+"]
    //   SymbolKind1 = (*) "@L" [">"]
    //   SymbolKind1 = (*) "@L" ["?"]
    //   SymbolKind1 = (*) "@R" ["*"]
    //   SymbolKind1 = (*) "@R" ["+"]
    //   SymbolKind1 = (*) "@R" [">"]
    //   SymbolKind1 = (*) "@R" ["?"]
    //   Terminal = (*) StringLiteral ["*"]
    //   Terminal = (*) StringLiteral ["+"]
    //   Terminal = (*) StringLiteral [">"]
    //   Terminal = (*) StringLiteral ["?"]
    //
    //   "@L" -> Shift(S252)
    //   "@R" -> Shift(S255)
    //   "Escape" -> Shift(S258)
    //   "Id" -> Shift(S259)
    //   "(" -> Shift(S260)
    //   "MacroId" -> Shift(S78)
    //   "StringLiteral" -> Shift(S253)
    //
    //   MacroId -> S250
    //   StringLiteral -> S256
    //   NonterminalId -> S254
    //   SymbolKind1 -> S249
    //   Id -> S383
    //   Terminal -> S248
    //   Escape -> S257
    pub fn __state366<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Lookahead(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state252(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::Lookbehind(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state255(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state258(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state259(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state260(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::MacroId(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state78(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            Some((_, Tok::StringLiteral(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state253(text, __lookbehind, __lookahead, __tokens, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::MacroId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state250(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::StringLiteral(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state256(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::NonterminalId(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state254(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::SymbolKind1(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state249(text, __lookbehind, __lookahead, __tokens, __sym2, __sym3));
                }
                __Nonterminal::Id(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state383(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                __Nonterminal::Terminal(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state248(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state257(text, __lookbehind, __lookahead, __tokens, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 367
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //
    pub fn __state367<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 368
    //   NonterminalId = Id (*) ["*"]
    //   NonterminalId = Id (*) ["+"]
    //   NonterminalId = Id (*) [">"]
    //   NonterminalId = Id (*) ["?"]
    //
    //   ">" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "*" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "+" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "?" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state368<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action66(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 369
    //   Id = "Id" (*) ["*"]
    //   Id = "Id" (*) ["+"]
    //   Id = "Id" (*) [">"]
    //   Id = "Id" (*) ["?"]
    //
    //   "+" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "?" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   "*" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //   ">" -> Reduce(Id = "Id" => Call(ActionFn(67));)
    //
    pub fn __state369<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __nt = super::__action67(text, __sym0);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Id(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 370
    //   @R = (*) ["("]
    //   @R = (*) [";"]
    //   @R = (*) ["<"]
    //   @R = (*) ["=>"]
    //   @R = (*) ["=>?"]
    //   @R = (*) ["=>@L"]
    //   @R = (*) ["=>@R"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   @R = (*) ["if"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["if"]
    //
    //   ";" -> Reduce(@R =  => Lookbehind;)
    //   "=>?" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "=>" -> Reduce(@R =  => Lookbehind;)
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   "if" -> Reduce(@R =  => Lookbehind;)
    //   "=>@R" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "=>@L" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S384
    pub fn __state370<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::If(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state384(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 371
    //   @R = (*) [","]
    //   @R = (*) ["}"]
    //   Conversion = @L Terminal "=>" (*) @R [","]
    //   Conversion = @L Terminal "=>" (*) @R ["}"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   "}" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S385
    pub fn __state371<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<TerminalString>,
        __sym2: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state385(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 372
    //   @L = (*) ["Id"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" (*) @L Id @R "=" TypeRef ";" ["}"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //
    //   @L -> S386
    pub fn __state372<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym0.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40L(__nt) => {
                    let __sym1 = &mut Some(__nt);
                    __result = try!(__state386(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 373
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) [EOF]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["Escape"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["Id"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["MacroId"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["extern"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["pub"]
    //   ExternToken = @L "extern" "token" @R "{" AssociatedType* "enum" @L TypeRef @R "{" Comma<Conversion> "}" AssociatedType* "}" (*) ["use"]
    //
    //   "extern" -> Reduce(ExternToken = @L, "extern", "token", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(52));)
    //   "pub" -> Reduce(ExternToken = @L, "extern", "token", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(52));)
    //   "MacroId" -> Reduce(ExternToken = @L, "extern", "token", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(52));)
    //   EOF -> Reduce(ExternToken = @L, "extern", "token", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(52));)
    //   "use" -> Reduce(ExternToken = @L, "extern", "token", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(52));)
    //   "Escape" -> Reduce(ExternToken = @L, "extern", "token", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(52));)
    //   "Id" -> Reduce(ExternToken = @L, "extern", "token", @R, "{", AssociatedType*, "enum", @L, TypeRef, @R, "{", Comma<Conversion>, "}", AssociatedType*, "}" => Call(ActionFn(52));)
    //
    pub fn __state373<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Tok<'input>>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
        __sym8: &mut Option<TypeRef>,
        __sym9: &mut Option<usize>,
        __sym10: &mut Option<Tok<'input>>,
        __sym11: &mut Option<Vec<Conversion>>,
        __sym12: &mut Option<Tok<'input>>,
        __sym13: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym14: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Extern(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __sym10 = __sym10.take().unwrap();
                let __sym11 = __sym11.take().unwrap();
                let __sym12 = __sym12.take().unwrap();
                let __sym13 = __sym13.take().unwrap();
                let __sym14 = __sym14.take().unwrap();
                let __nt = super::__action52(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExternToken(__nt)));
            }
            Some((_, Tok::Pub(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __sym10 = __sym10.take().unwrap();
                let __sym11 = __sym11.take().unwrap();
                let __sym12 = __sym12.take().unwrap();
                let __sym13 = __sym13.take().unwrap();
                let __sym14 = __sym14.take().unwrap();
                let __nt = super::__action52(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExternToken(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __sym10 = __sym10.take().unwrap();
                let __sym11 = __sym11.take().unwrap();
                let __sym12 = __sym12.take().unwrap();
                let __sym13 = __sym13.take().unwrap();
                let __sym14 = __sym14.take().unwrap();
                let __nt = super::__action52(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExternToken(__nt)));
            }
            None => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __sym10 = __sym10.take().unwrap();
                let __sym11 = __sym11.take().unwrap();
                let __sym12 = __sym12.take().unwrap();
                let __sym13 = __sym13.take().unwrap();
                let __sym14 = __sym14.take().unwrap();
                let __nt = super::__action52(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExternToken(__nt)));
            }
            Some((_, Tok::Use(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __sym10 = __sym10.take().unwrap();
                let __sym11 = __sym11.take().unwrap();
                let __sym12 = __sym12.take().unwrap();
                let __sym13 = __sym13.take().unwrap();
                let __sym14 = __sym14.take().unwrap();
                let __nt = super::__action52(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExternToken(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __sym10 = __sym10.take().unwrap();
                let __sym11 = __sym11.take().unwrap();
                let __sym12 = __sym12.take().unwrap();
                let __sym13 = __sym13.take().unwrap();
                let __sym14 = __sym14.take().unwrap();
                let __nt = super::__action52(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExternToken(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __sym8 = __sym8.take().unwrap();
                let __sym9 = __sym9.take().unwrap();
                let __sym10 = __sym10.take().unwrap();
                let __sym11 = __sym11.take().unwrap();
                let __sym12 = __sym12.take().unwrap();
                let __sym13 = __sym13.take().unwrap();
                let __sym14 = __sym14.take().unwrap();
                let __nt = super::__action52(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11, __sym12, __sym13, __sym14);
                return Ok((__lookbehind, __lookahead, __Nonterminal::ExternToken(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 374
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["type"]
    //   AssociatedType* = AssociatedType* AssociatedType (*) ["}"]
    //
    //   "}" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(80));)
    //   "type" -> Reduce(AssociatedType* = AssociatedType*, AssociatedType => Call(ActionFn(80));)
    //
    pub fn __state374<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<::std::vec::Vec<AssociatedType>>,
        __sym1: &mut Option<AssociatedType>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action80(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt)));
            }
            Some((_, Tok::Type(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __nt = super::__action80(text, __sym0, __sym1);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType_2a(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 375
    //   TypeRef = Path "<" Comma<TypeRefOrLifetime> ">" (*) [";"]
    //
    //   ";" -> Reduce(TypeRef = Path, "<", Comma<TypeRefOrLifetime>, ">" => Call(ActionFn(47));)
    //
    pub fn __state375<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Path>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<TypeRef>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action47(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 376
    //   TypeRef = "&" Lifetime? "mut"? TypeRef (*) [";"]
    //
    //   ";" -> Reduce(TypeRef = "&", Lifetime?, "mut"?, TypeRef => Call(ActionFn(46));)
    //
    pub fn __state376<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::option::Option<InternedString>>,
        __sym2: &mut Option<::std::option::Option<Tok<'input>>>,
        __sym3: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action46(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::TypeRef(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 377
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" Symbol0 ">" @R (*) ["StringLiteral"]
    //
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   ")" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "Id" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "@R" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "<" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "@L" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "Escape" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "(" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //
    pub fn __state377<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 378
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R ["StringLiteral"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol1 -> S220
    //   @L -> S343
    //   Symbol0 -> S387
    pub fn __state378<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol1(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state220(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state343(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state387(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 379
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["("]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [")"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["<"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@L"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["@R"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Escape"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["Id"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["MacroId"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["StringLiteral"]
    //
    //   "Id" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "MacroId" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "@L" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "Escape" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "(" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "StringLiteral" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   ")" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "@R" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "<" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //
    pub fn __state379<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 380
    //   SymbolKind1 = "(" Symbol* ")" (*) ["*"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["+"]
    //   SymbolKind1 = "(" Symbol* ")" (*) [","]
    //   SymbolKind1 = "(" Symbol* ")" (*) [">"]
    //   SymbolKind1 = "(" Symbol* ")" (*) ["?"]
    //
    //   "+" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "," -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   ">" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "*" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //   "?" -> Reduce(SymbolKind1 = "(", Symbol*, ")" => Call(ActionFn(41));)
    //
    pub fn __state380<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<::std::vec::Vec<Symbol>>,
        __sym2: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action41(text, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 381
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> (*) ">" ["?"]
    //
    //   ">" -> Shift(S388)
    //
    pub fn __state381<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym3 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state388(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 382
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" Symbol0 ">" (*) @R [">"]
    //
    //   "," -> Reduce(@R =  => Lookbehind;)
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S389
    pub fn __state382<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym3.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym4 = &mut Some(__nt);
                    __result = try!(__state389(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 383
    //   NonterminalId = Id (*) ["*"]
    //   NonterminalId = Id (*) ["+"]
    //   NonterminalId = Id (*) [">"]
    //   NonterminalId = Id (*) ["?"]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id (*) ":" Symbol0 ">" @R [">"]
    //
    //   "*" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ":" -> Shift(S390)
    //   "+" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   ">" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //   "?" -> Reduce(NonterminalId = Id => Call(ActionFn(66));)
    //
    pub fn __state383<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Colon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state390(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            Some((_, Tok::Question(..), _)) => {
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action66(text, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::NonterminalId(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 384
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [";"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["=>@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["if"]
    //
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "=>@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   ";" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "if" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "=>" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "=>?" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "=>@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //
    pub fn __state384<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Semi(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::If(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanQuestionCode(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::EqualsGreaterThanLookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 385
    //   Conversion = @L Terminal "=>" @R (*) [","]
    //   Conversion = @L Terminal "=>" @R (*) ["}"]
    //
    //   "," -> Reduce(Conversion = @L, Terminal, "=>", @R => TryCall(ActionFn(54));)
    //   "}" -> Reduce(Conversion = @L, Terminal, "=>", @R => TryCall(ActionFn(54));)
    //
    pub fn __state385<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<TerminalString>,
        __sym2: &mut Option<&'input str>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = try!(super::__action54(text, __sym0, __sym1, __sym2, __sym3));
                return Ok((__lookbehind, __lookahead, __Nonterminal::Conversion(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = try!(super::__action54(text, __sym0, __sym1, __sym2, __sym3));
                return Ok((__lookbehind, __lookahead, __Nonterminal::Conversion(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 386
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L (*) Id @R "=" TypeRef ";" ["}"]
    //   Id = (*) "Id" ["="]
    //
    //   "Id" -> Shift(S176)
    //
    //   Id -> S391
    pub fn __state386<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym2 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state176(text, __lookbehind, __lookahead, __tokens, __sym2));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym1.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Id(__nt) => {
                    let __sym2 = &mut Some(__nt);
                    __result = try!(__state391(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 387
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R ["StringLiteral"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "*" -> Shift(S246)
    //   "?" -> Shift(S245)
    //   "+" -> Shift(S244)
    //   ">" -> Shift(S392)
    //
    //   RepeatOp -> S247
    pub fn __state387<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state246(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state245(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state244(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state392(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state247(text, __lookbehind, __lookahead, __tokens, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 388
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["*"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["+"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [","]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) [">"]
    //   SymbolKind1 = MacroId "<" Comma<Symbol> ">" (*) ["?"]
    //
    //   "?" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   ">" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "," -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "*" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //   "+" -> Reduce(SymbolKind1 = MacroId, "<", Comma<Symbol>, ">" => Call(ActionFn(37));)
    //
    pub fn __state388<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<NonterminalString>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Vec<Symbol>>,
        __sym3: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Question(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Star(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            Some((_, Tok::Plus(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __nt = super::__action37(text, __sym0, __sym1, __sym2, __sym3);
                return Ok((__lookbehind, __lookahead, __Nonterminal::SymbolKind1(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 389
    //   Symbol = @L "<" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" Symbol0 ">" @R (*) [">"]
    //
    //   ">" -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //   "," -> Reduce(Symbol = @L, "<", Symbol0, ">", @R => Call(ActionFn(29));)
    //
    pub fn __state389<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<Symbol>,
        __sym3: &mut Option<Tok<'input>>,
        __sym4: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __nt = super::__action29(text, __sym0, __sym1, __sym2, __sym3, __sym4);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 390
    //   @L = (*) ["("]
    //   @L = (*) ["@L"]
    //   @L = (*) ["@R"]
    //   @L = (*) ["Escape"]
    //   @L = (*) ["Id"]
    //   @L = (*) ["MacroId"]
    //   @L = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [","]
    //   Symbol = @L "<" @L Id ":" (*) Symbol0 ">" @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["*"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["+"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R [">"]
    //   Symbol0 = (*) Symbol0 RepeatOp @R ["?"]
    //   Symbol0 = (*) Symbol1 ["*"]
    //   Symbol0 = (*) Symbol1 ["+"]
    //   Symbol0 = (*) Symbol1 [">"]
    //   Symbol0 = (*) Symbol1 ["?"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["*"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["+"]
    //   Symbol1 = (*) @L SymbolKind1 @R [">"]
    //   Symbol1 = (*) @L SymbolKind1 @R ["?"]
    //
    //   "Id" -> Reduce(@L =  => Lookahead;)
    //   "(" -> Reduce(@L =  => Lookahead;)
    //   "@R" -> Reduce(@L =  => Lookahead;)
    //   "Escape" -> Reduce(@L =  => Lookahead;)
    //   "MacroId" -> Reduce(@L =  => Lookahead;)
    //   "StringLiteral" -> Reduce(@L =  => Lookahead;)
    //   "@L" -> Reduce(@L =  => Lookahead;)
    //
    //   Symbol1 -> S220
    //   @L -> S343
    //   Symbol0 -> S393
    pub fn __state390<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Id(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = __lookahead.as_ref().map(|o| ::std::clone::Clone::clone(&o.0)).or_else(|| ::std::clone::Clone::clone(&__lookbehind)).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40L(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Symbol1(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state220(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::_40L(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state343(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::Symbol0(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state393(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 391
    //   @R = (*) ["="]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id (*) @R "=" TypeRef ";" ["}"]
    //
    //   "=" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S394
    pub fn __state391<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Equals(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym2.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym3 = &mut Some(__nt);
                    __result = try!(__state394(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 392
    //   @R = (*) ["("]
    //   @R = (*) [")"]
    //   @R = (*) ["<"]
    //   @R = (*) ["@L"]
    //   @R = (*) ["@R"]
    //   @R = (*) ["Escape"]
    //   @R = (*) ["Id"]
    //   @R = (*) ["MacroId"]
    //   @R = (*) ["StringLiteral"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R ["StringLiteral"]
    //
    //   "@R" -> Reduce(@R =  => Lookbehind;)
    //   "Id" -> Reduce(@R =  => Lookbehind;)
    //   "Escape" -> Reduce(@R =  => Lookbehind;)
    //   "<" -> Reduce(@R =  => Lookbehind;)
    //   "StringLiteral" -> Reduce(@R =  => Lookbehind;)
    //   "@L" -> Reduce(@R =  => Lookbehind;)
    //   "(" -> Reduce(@R =  => Lookbehind;)
    //   ")" -> Reduce(@R =  => Lookbehind;)
    //   "MacroId" -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S395
    pub fn __state392<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Lookbehind(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::LeftParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state395(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 393
    //   RepeatOp = (*) "*" ["*"]
    //   RepeatOp = (*) "*" ["+"]
    //   RepeatOp = (*) "*" [">"]
    //   RepeatOp = (*) "*" ["?"]
    //   RepeatOp = (*) "+" ["*"]
    //   RepeatOp = (*) "+" ["+"]
    //   RepeatOp = (*) "+" [">"]
    //   RepeatOp = (*) "+" ["?"]
    //   RepeatOp = (*) "?" ["*"]
    //   RepeatOp = (*) "?" ["+"]
    //   RepeatOp = (*) "?" [">"]
    //   RepeatOp = (*) "?" ["?"]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 (*) ">" @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["*"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["+"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R [">"]
    //   Symbol0 = Symbol0 (*) RepeatOp @R ["?"]
    //
    //   "?" -> Shift(S245)
    //   ">" -> Shift(S396)
    //   "+" -> Shift(S244)
    //   "*" -> Shift(S246)
    //
    //   RepeatOp -> S247
    pub fn __state393<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Question(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state245(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::GreaterThan(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state396(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            Some((_, __tok @ Tok::Plus(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state244(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            Some((_, __tok @ Tok::Star(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state246(text, __lookbehind, __lookahead, __tokens, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym5.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::RepeatOp(__nt) => {
                    let __sym6 = &mut Some(__nt);
                    __result = try!(__state247(text, __lookbehind, __lookahead, __tokens, __sym5, __sym6));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 394
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R (*) "=" TypeRef ";" ["}"]
    //
    //   "=" -> Shift(S397)
    //
    pub fn __state394<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Equals(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym4 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state397(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 395
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["("]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [")"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["<"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@L"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["@R"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Escape"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["Id"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["MacroId"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) ["StringLiteral"]
    //
    //   "(" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "MacroId" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "StringLiteral" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "@L" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "Escape" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "@R" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "<" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "Id" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   ")" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //
    pub fn __state395<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::LeftParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::MacroId(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::StringLiteral(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookahead(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Escape(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Lookbehind(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::LessThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Id(_), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::RightParen(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 396
    //   @R = (*) [","]
    //   @R = (*) [">"]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" (*) @R [">"]
    //
    //   ">" -> Reduce(@R =  => Lookbehind;)
    //   "," -> Reduce(@R =  => Lookbehind;)
    //
    //   @R -> S398
    pub fn __state396<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __nt = ::std::clone::Clone::clone(&__lookbehind).unwrap_or_default();
                __result = (__lookbehind, __lookahead, __Nonterminal::_40R(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym6.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::_40R(__nt) => {
                    let __sym7 = &mut Some(__nt);
                    __result = try!(__state398(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 397
    //   "::"? = (*) ["Id"]
    //   "::"? = (*) "::" ["Id"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" (*) TypeRef ";" ["}"]
    //   Escape = (*) "Escape" [";"]
    //   Path = (*) "::"? (<Id> "::")* Id [";"]
    //   Path = (*) "::"? (<Id> "::")* Id ["<"]
    //   TypeRef = (*) Escape [";"]
    //   TypeRef = (*) Path [";"]
    //   TypeRef = (*) Path "<" Comma<TypeRefOrLifetime> ">" [";"]
    //   TypeRef = (*) "&" Lifetime? "mut"? TypeRef [";"]
    //   TypeRef = (*) "(" Comma<TypeRef> ")" [";"]
    //
    //   "::" -> Shift(S41)
    //   "(" -> Shift(S271)
    //   "Escape" -> Shift(S267)
    //   "&" -> Shift(S268)
    //   "Id" -> Reduce("::"? =  => Call(ActionFn(85));)
    //
    //   Path -> S266
    //   TypeRef -> S399
    //   Escape -> S269
    //   "::"? -> S272
    pub fn __state397<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::ColonColon(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state41(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, __tok @ Tok::LeftParen(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state271(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, Tok::Escape(__tok0), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok0));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state267(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, __tok @ Tok::Ampersand(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym5 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state268(text, __lookbehind, __lookahead, __tokens, __sym5));
            }
            Some((_, Tok::Id(_), _)) => {
                let __nt = super::__action85(text, );
                __result = (__lookbehind, __lookahead, __Nonterminal::_22_3a_3a_22_3f(__nt));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        while __sym4.is_some() {
            let (__lookbehind, __lookahead, __nt) = __result;
            match __nt {
                __Nonterminal::Path(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state266(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::TypeRef(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state399(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5));
                }
                __Nonterminal::Escape(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state269(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                __Nonterminal::_22_3a_3a_22_3f(__nt) => {
                    let __sym5 = &mut Some(__nt);
                    __result = try!(__state272(text, __lookbehind, __lookahead, __tokens, __sym5));
                }
                _ => {
                    return Ok((__lookbehind, __lookahead, __nt));
                }
            }
        }
        return Ok(__result);
    }

    // State 398
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [","]
    //   Symbol = @L "<" @L Id ":" Symbol0 ">" @R (*) [">"]
    //
    //   ">" -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //   "," -> Reduce(Symbol = @L, "<", @L, Id, ":", Symbol0, ">", @R => Call(ActionFn(28));)
    //
    pub fn __state398<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<usize>,
        __sym1: &mut Option<Tok<'input>>,
        __sym2: &mut Option<usize>,
        __sym3: &mut Option<InternedString>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<Symbol>,
        __sym6: &mut Option<Tok<'input>>,
        __sym7: &mut Option<usize>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::GreaterThan(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            Some((_, Tok::Comma(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __sym7 = __sym7.take().unwrap();
                let __nt = super::__action28(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Symbol(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }

    // State 399
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef (*) ";" ["}"]
    //
    //   ";" -> Shift(S400)
    //
    pub fn __state399<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<TypeRef>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, __tok @ Tok::Semi(..), __loc)) => {
                let mut __lookbehind = Some(__loc);
                let mut __sym6 = &mut Some((__tok));
                let __lookahead = match __tokens.next() { Some(Ok(v)) => Some(v), None => None, Some(Err(e)) => return Err(__ParseError::User { error: e }) };
                __result = try!(__state400(text, __lookbehind, __lookahead, __tokens, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
        return Ok(__result);
    }

    // State 400
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["type"]
    //   AssociatedType = "type" @L Id @R "=" TypeRef ";" (*) ["}"]
    //
    //   "type" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(53));)
    //   "}" -> Reduce(AssociatedType = "type", @L, Id, @R, "=", TypeRef, ";" => Call(ActionFn(53));)
    //
    pub fn __state400<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, Tok<'input>, usize),tok::Error>>,
    >(
        text: &'input str,
        __lookbehind: Option<usize>,
        __lookahead: Option<(usize, Tok<'input>, usize)>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<Tok<'input>>,
        __sym1: &mut Option<usize>,
        __sym2: &mut Option<InternedString>,
        __sym3: &mut Option<usize>,
        __sym4: &mut Option<Tok<'input>>,
        __sym5: &mut Option<TypeRef>,
        __sym6: &mut Option<Tok<'input>>,
    ) -> Result<(Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >), __ParseError<usize,Tok<'input>,tok::Error>>
    {
        let mut __result: (Option<usize>, Option<(usize, Tok<'input>, usize)>, __Nonterminal<'input, >);
        match __lookahead {
            Some((_, Tok::Type(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action53(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType(__nt)));
            }
            Some((_, Tok::RightBrace(..), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __sym3 = __sym3.take().unwrap();
                let __sym4 = __sym4.take().unwrap();
                let __sym5 = __sym5.take().unwrap();
                let __sym6 = __sym6.take().unwrap();
                let __nt = super::__action53(text, __sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                return Ok((__lookbehind, __lookahead, __Nonterminal::AssociatedType(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }
}

pub fn __action0<
    'input,
>(
    text: &'input str,
    __0: Grammar,
) -> Grammar
{
    (__0)
}

pub fn __action1<
    'input,
>(
    text: &'input str,
    __0: Pattern,
) -> Pattern
{
    (__0)
}

pub fn __action2<
    'input,
>(
    text: &'input str,
    uses: ::std::vec::Vec<GrammarItem>,
    lo: usize,
    _: Tok<'input>,
    hi: usize,
    tps: ::std::option::Option<Vec<TypeParameter>>,
    parameters: ::std::option::Option<Vec<Parameter>>,
    where_clauses: ::std::option::Option<Tok<'input>>,
    _: Tok<'input>,
    items: ::std::vec::Vec<GrammarItem>,
) -> Grammar
{
    {
        Grammar { span: Span(lo, hi),
                  type_parameters: tps.unwrap_or(vec![]),
                  parameters: parameters.unwrap_or(vec![]),
                  where_clauses: where_clauses.unwrap_or(vec![]),
                  items: uses.into_iter().chain(i).collect() }
    }
}

pub fn __action3<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Vec<TypeParameter>,
    _: Tok<'input>,
) -> Vec<TypeParameter>
{
    (__0)
}

pub fn __action4<
    'input,
>(
    text: &'input str,
    l: &'input str,
) -> TypeParameter
{
    TypeParameter::Lifetime(l)
}

pub fn __action5<
    'input,
>(
    text: &'input str,
    l: &'input str,
) -> TypeParameter
{
    TypeParameter::Id(l)
}

pub fn __action6<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Vec<Parameter>,
    _: Tok<'input>,
) -> Vec<Parameter>
{
    (__0)
}

pub fn __action7<
    'input,
>(
    text: &'input str,
    id: InternedString,
    _: Tok<'input>,
    ty: TypeRef,
) -> Parameter
{
    Parameter { name: id, ty: ty }
}

pub fn __action8<
    'input,
>(
    text: &'input str,
    __0: GrammarItem,
) -> GrammarItem
{
    (__0)
}

pub fn __action9<
    'input,
>(
    text: &'input str,
    __0: GrammarItem,
) -> GrammarItem
{
    (__0)
}

pub fn __action10<
    'input,
>(
    text: &'input str,
    __0: GrammarItem,
) -> GrammarItem
{
    (__0)
}

pub fn __action11<
    'input,
>(
    text: &'input str,
    u: Tok<'input>,
    _: Tok<'input>,
) -> GrammarItem
{
    GrammarItem::Use(u)
}

pub fn __action12<
    'input,
>(
    text: &'input str,
    p: ::std::option::Option<Tok<'input>>,
    lo: usize,
    n: (NonterminalString, Vec<NonterminalString>),
    hi: usize,
    t: ::std::option::Option<TypeRef>,
    _: Tok<'input>,
    a: Vec<Alternative>,
) -> GrammarItem
{
    {
        GrammarItem::Nonterminal(NonterminalData { public: p.is_some(),
                                                   span: Span(lo, hi),
                                                   name: n.0,
                                                   args: n.1,
                                                   type_decl: t,
                                                   alternatives: a })
    }
}

pub fn __action13<
    'input,
>(
    text: &'input str,
    __0: NonterminalString,
    _: Tok<'input>,
    __1: Vec<NonterminalString>,
    _: Tok<'input>,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (__0, __1)
}

pub fn __action14<
    'input,
>(
    text: &'input str,
    __0: NonterminalString,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (__0)
}

pub fn __action15<
    'input,
>(
    text: &'input str,
    __0: &'input str,
) -> (NonterminalString, Vec<NonterminalString>)
{
    (NonterminalString(intern(__0)), vec![])
}

pub fn __action16<
    'input,
>(
    text: &'input str,
    a: Alternative,
) -> Vec<Alternative>
{
    vec![a]
}

pub fn __action17<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: ::std::vec::Vec<Alternative>,
    _: Tok<'input>,
    _: Tok<'input>,
) -> Vec<Alternative>
{
    (__0)
}

pub fn __action18<
    'input,
>(
    text: &'input str,
    lo: usize,
    s: ::std::vec::Vec<Symbol>,
    c: ::std::option::Option<Condition>,
    a: ::std::option::Option<ActionKind>,
    _: Tok<'input>,
    hi: usize,
) -> Alternative
{
    {
        Alternative {
            span: Span(lo, hi),
            expr: s,
            condition: c,
            action: a
        }
    }
}

pub fn __action19<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ActionKind
{
    ActionKind::Lookahead
}

pub fn __action20<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ActionKind
{
    ActionKind::Lookbehind
}

pub fn __action21<
    'input,
>(
    text: &'input str,
    c: &'input str,
) -> ActionKind
{
    ActionKind::Code(c.to_string())
}

pub fn __action22<
    'input,
>(
    text: &'input str,
    c: &'input str,
) -> ActionKind
{
    ActionKind::Fallible(c.to_string())
}

pub fn __action23<
    'input,
>(
    text: &'input str,
    lo: usize,
    a: NonterminalString,
    op: ConditionOp,
    b: &'input str,
    hi: usize,
) -> Condition
{
    {
        Condition { span:Span(lo, hi), lhs:a, rhs:b, op:op }
    }
}

pub fn __action24<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::Equals
}

pub fn __action25<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::NotEquals
}

pub fn __action26<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::Match
}

pub fn __action27<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ConditionOp
{
    ConditionOp::NotMatch
}

pub fn __action28<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    _: usize,
    l: InternedString,
    _: Tok<'input>,
    s: Symbol,
    _: Tok<'input>,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), SymbolKind::Name(l, Box::new(s)))
}

pub fn __action29<
    'input,
>(
    text: &'input str,
    lo: usize,
    _: Tok<'input>,
    s: Symbol,
    _: Tok<'input>,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), SymbolKind::Choose(Box::new(s)))
}

pub fn __action30<
    'input,
>(
    text: &'input str,
    __0: Symbol,
) -> Symbol
{
    (__0)
}

pub fn __action31<
    'input,
>(
    text: &'input str,
    __0: Symbol,
) -> Symbol
{
    (__0)
}

pub fn __action32<
    'input,
>(
    text: &'input str,
    lhs: Symbol,
    op: RepeatOp,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lhs.span.0, hi),
                    SymbolKind::Repeat(Box::new(RepeatSymbol { symbol: lhs, op: op })))
}

pub fn __action33<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Plus
}

pub fn __action34<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Star
}

pub fn __action35<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> RepeatOp
{
    RepeatOp::Question
}

pub fn __action36<
    'input,
>(
    text: &'input str,
    lo: usize,
    sk: SymbolKind,
    hi: usize,
) -> Symbol
{
    Symbol::new(Span(lo, hi), sk)
}

pub fn __action37<
    'input,
>(
    text: &'input str,
    name: NonterminalString,
    _: Tok<'input>,
    args: Vec<Symbol>,
    _: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Macro(MacroSymbol { name: name, args: args })
}

pub fn __action38<
    'input,
>(
    text: &'input str,
    __0: TerminalString,
) -> SymbolKind
{
    SymbolKind::Terminal(__0)
}

pub fn __action39<
    'input,
>(
    text: &'input str,
    __0: NonterminalString,
) -> SymbolKind
{
    SymbolKind::Nonterminal(__0)
}

pub fn __action40<
    'input,
>(
    text: &'input str,
    __0: InternedString,
) -> SymbolKind
{
    SymbolKind::Nonterminal(NonterminalString(__0))
}

pub fn __action41<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: ::std::vec::Vec<Symbol>,
    _: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Expr(__0)
}

pub fn __action42<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Lookahead
}

pub fn __action43<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> SymbolKind
{
    SymbolKind::Lookbehind
}

pub fn __action44<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Vec<TypeRef>,
    _: Tok<'input>,
) -> TypeRef
{
    TypeRef::Tuple(__0)
}

pub fn __action45<
    'input,
>(
    text: &'input str,
    e: InternedString,
) -> Result<TypeRef,__ParseError<usize,Tok<'input>,tok::Error>>
{
    {
        panic!("parse escape symbol")
    }
}

pub fn __action46<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    l: ::std::option::Option<InternedString>,
    m: ::std::option::Option<Tok<'input>>,
    t: TypeRef,
) -> TypeRef
{
    TypeRef::Ref { lifetime: l,
                       mutable: m.is_some(),
                       referent: Box::new(t) }
}

pub fn __action47<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a: Vec<TypeRef>,
    _: Tok<'input>,
) -> TypeRef
{
    TypeRef::Nominal { path: p, types: a }
}

pub fn __action48<
    'input,
>(
    text: &'input str,
    p: Path,
) -> TypeRef
{
    match p.as_id() {
            Some(id) => TypeRef::Id(id),
            None => TypeRef::Nominal { path: p, types: vec![] }
        }
}

pub fn __action49<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> TypeRef
{
    (__0)
}

pub fn __action50<
    'input,
>(
    text: &'input str,
    __0: InternedString,
) -> TypeRef
{
    TypeRef1::Lifetime(__0)
}

pub fn __action51<
    'input,
>(
    text: &'input str,
    a: ::std::option::Option<Tok<'input>>,
    h: ::std::vec::Vec<InternedString>,
    t: InternedString,
) -> Path
{
    {
        Path { absolute: a.is_some(),
               ids: h.into_iter().chain(once(t)).collect() }
    }
}

pub fn __action52<
    'input,
>(
    text: &'input str,
    lo0: usize,
    _: Tok<'input>,
    _: Tok<'input>,
    hi0: usize,
    _: Tok<'input>,
    a0: ::std::vec::Vec<AssociatedType>,
    _: Tok<'input>,
    lo: usize,
    t: TypeRef,
    hi: usize,
    _: Tok<'input>,
    c: Vec<Conversion>,
    _: Tok<'input>,
    a1: ::std::vec::Vec<AssociatedType>,
    _: Tok<'input>,
) -> GrammarItem
{
    {
        GrammarItem::ExternToken(ExternToken {
            span: Span(lo0, hi0),
            associated_types: a0.into_iter().chain(a1).collect(),
            enum_token: EnumToken {
                type_name: t,
                type_span: Span(lo, hi),
                conversions: c,
            }
        })
    }
}

pub fn __action53<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    lo: usize,
    n: InternedString,
    hi: usize,
    _: Tok<'input>,
    t: TypeRef,
    _: Tok<'input>,
) -> AssociatedType
{
    {
        AssociatedType { type_span: Span(lo, hi),
                         type_name: n,
                         type_ref: t }
    }
}

pub fn __action54<
    'input,
>(
    text: &'input str,
    lo: usize,
    from: TerminalString,
    p: &'input str,
    hi: usize,
) -> Result<Conversion,__ParseError<usize,Tok<'input>,tok::Error>>
{
    {
        let pattern = try!(parse_pattern(p));
        Conversion { span: Span(lo, hi), from: from, to: pattern }
    }
}

pub fn __action55<
    'input,
>(
    text: &'input str,
    lo: usize,
    k: PatternKind<TypeRef>,
    hi: usize,
) -> Pattern
{
    Pattern { span: Span(lo, hi), kind: k }
}

pub fn __action56<
    'input,
>(
    text: &'input str,
    __0: Path,
    _: Tok<'input>,
    __1: Vec<Pattern>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Enum(__0, __1)
}

pub fn __action57<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    a1: ::std::option::Option<FieldPattern<TypeRef>>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Struct(p, a0.into_iter().chain(a1).collect(), false)
}

pub fn __action58<
    'input,
>(
    text: &'input str,
    p: Path,
    _: Tok<'input>,
    a0: ::std::vec::Vec<FieldPattern<TypeRef>>,
    _: Tok<'input>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Struct(p, a0, true)
}

pub fn __action59<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Underscore
}

pub fn __action60<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::DotDot
}

pub fn __action61<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: TypeRef,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Choose(__0)
}

pub fn __action62<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Vec<TypeRef>,
    _: Tok<'input>,
) -> PatternKind<TypeRef>
{
    PatternKind::Tuple(__0)
}

pub fn __action63<
    'input,
>(
    text: &'input str,
    __0: Path,
) -> PatternKind<TypeRef>
{
    PatternKind::Path(__0)
}

pub fn __action64<
    'input,
>(
    text: &'input str,
    lo: usize,
    id: InternedString,
    hi: usize,
    _: Tok<'input>,
    pat: Pattern,
) -> FieldPattern<TypeRef>
{
    {
        FieldPattern { field_span: Span(lo, hi),
                       field_name: id,
                       pattern: pat }
    }
}

pub fn __action65<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> NonterminalString
{
    NonterminalString(intern(i))
}

pub fn __action66<
    'input,
>(
    text: &'input str,
    i: InternedString,
) -> NonterminalString
{
    NonterminalString(i)
}

pub fn __action67<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn __action68<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn __action69<
    'input,
>(
    text: &'input str,
    i: &'input str,
) -> InternedString
{
    intern(i)
}

pub fn __action70<
    'input,
>(
    text: &'input str,
    s: InternedString,
) -> TerminalString
{
    TerminalString(s)
}

pub fn __action71<
    'input,
>(
    text: &'input str,
    s: &'input str,
) -> InternedString
{
    intern(s)
}

pub fn __action72<
    'input,
>(
    text: &'input str,
    __0: FieldPattern<TypeRef>,
) -> ::std::option::Option<FieldPattern<TypeRef>>
{
    Some(__0)
}

pub fn __action73<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<FieldPattern<TypeRef>>
{
    None
}

pub fn __action74<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    vec![]
}

pub fn __action75<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<FieldPattern<TypeRef>>,
    e: FieldPattern<TypeRef>,
) -> ::std::vec::Vec<FieldPattern<TypeRef>>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action76<
    'input,
>(
    text: &'input str,
    __0: FieldPattern<TypeRef>,
    _: Tok<'input>,
) -> FieldPattern<TypeRef>
{
    (__0)
}

pub fn __action77<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Pattern>,
    e1: ::std::option::Option<Pattern>,
) -> Vec<Pattern>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action78<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Conversion>,
    e1: ::std::option::Option<Conversion>,
) -> Vec<Conversion>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action79<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<AssociatedType>
{
    vec![]
}

pub fn __action80<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<AssociatedType>,
    e: AssociatedType,
) -> ::std::vec::Vec<AssociatedType>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action81<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<InternedString>
{
    vec![]
}

pub fn __action82<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<InternedString>,
    e: InternedString,
) -> ::std::vec::Vec<InternedString>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action83<
    'input,
>(
    text: &'input str,
    __0: InternedString,
    _: Tok<'input>,
) -> InternedString
{
    (__0)
}

pub fn __action84<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

pub fn __action85<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn __action86<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeRef>,
    e1: ::std::option::Option<TypeRef>,
) -> Vec<TypeRef>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action87<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

pub fn __action88<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn __action89<
    'input,
>(
    text: &'input str,
    __0: InternedString,
) -> ::std::option::Option<InternedString>
{
    Some(__0)
}

pub fn __action90<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<InternedString>
{
    None
}

pub fn __action91<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeRef>,
    e1: ::std::option::Option<TypeRef>,
) -> Vec<TypeRef>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action92<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Symbol>,
    e1: ::std::option::Option<Symbol>,
) -> Vec<Symbol>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action93<
    'input,
>(
    text: &'input str,
    __0: ActionKind,
) -> ::std::option::Option<ActionKind>
{
    Some(__0)
}

pub fn __action94<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<ActionKind>
{
    None
}

pub fn __action95<
    'input,
>(
    text: &'input str,
    __0: Condition,
) -> ::std::option::Option<Condition>
{
    Some(__0)
}

pub fn __action96<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Condition>
{
    None
}

pub fn __action97<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: Condition,
) -> Condition
{
    (__0)
}

pub fn __action98<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Symbol>
{
    vec![]
}

pub fn __action99<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action100<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Alternative>
{
    vec![]
}

pub fn __action101<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Alternative>,
    e: Alternative,
) -> ::std::vec::Vec<Alternative>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action102<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<NonterminalString>,
    e1: ::std::option::Option<NonterminalString>,
) -> Vec<NonterminalString>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action103<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(__0)
}

pub fn __action104<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn __action105<
    'input,
>(
    text: &'input str,
    _: Tok<'input>,
    __0: TypeRef,
) -> TypeRef
{
    (__0)
}

pub fn __action106<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

pub fn __action107<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn __action108<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<Parameter>,
    e1: ::std::option::Option<Parameter>,
) -> Vec<Parameter>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action109<
    'input,
>(
    text: &'input str,
    v0: ::std::vec::Vec<TypeParameter>,
    e1: ::std::option::Option<TypeParameter>,
) -> Vec<TypeParameter>
{
    v0.into_iter().chain(e1).collect()
}

pub fn __action110<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![]
}

pub fn __action111<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    e: GrammarItem,
) -> ::std::vec::Vec<GrammarItem>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action112<
    'input,
>(
    text: &'input str,
    __0: Tok<'input>,
) -> ::std::option::Option<Tok<'input>>
{
    Some(__0)
}

pub fn __action113<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Tok<'input>>
{
    None
}

pub fn __action114<
    'input,
>(
    text: &'input str,
    __0: Vec<Parameter>,
) -> ::std::option::Option<Vec<Parameter>>
{
    Some(__0)
}

pub fn __action115<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Vec<Parameter>>
{
    None
}

pub fn __action116<
    'input,
>(
    text: &'input str,
    __0: Vec<TypeParameter>,
) -> ::std::option::Option<Vec<TypeParameter>>
{
    Some(__0)
}

pub fn __action117<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Vec<TypeParameter>>
{
    None
}

pub fn __action118<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<GrammarItem>
{
    vec![]
}

pub fn __action119<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<GrammarItem>,
    e: GrammarItem,
) -> ::std::vec::Vec<GrammarItem>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action120<
    'input,
>(
    text: &'input str,
    __0: TypeParameter,
) -> ::std::option::Option<TypeParameter>
{
    Some(__0)
}

pub fn __action121<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeParameter>
{
    None
}

pub fn __action122<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeParameter>
{
    vec![]
}

pub fn __action123<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeParameter>,
    e: TypeParameter,
) -> ::std::vec::Vec<TypeParameter>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action124<
    'input,
>(
    text: &'input str,
    __0: TypeParameter,
    _: Tok<'input>,
) -> TypeParameter
{
    (__0)
}

pub fn __action125<
    'input,
>(
    text: &'input str,
    __0: Parameter,
) -> ::std::option::Option<Parameter>
{
    Some(__0)
}

pub fn __action126<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Parameter>
{
    None
}

pub fn __action127<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Parameter>
{
    vec![]
}

pub fn __action128<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Parameter>,
    e: Parameter,
) -> ::std::vec::Vec<Parameter>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action129<
    'input,
>(
    text: &'input str,
    __0: Parameter,
    _: Tok<'input>,
) -> Parameter
{
    (__0)
}

pub fn __action130<
    'input,
>(
    text: &'input str,
    __0: NonterminalString,
) -> ::std::option::Option<NonterminalString>
{
    Some(__0)
}

pub fn __action131<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<NonterminalString>
{
    None
}

pub fn __action132<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<NonterminalString>
{
    vec![]
}

pub fn __action133<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<NonterminalString>,
    e: NonterminalString,
) -> ::std::vec::Vec<NonterminalString>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action134<
    'input,
>(
    text: &'input str,
    __0: NonterminalString,
    _: Tok<'input>,
) -> NonterminalString
{
    (__0)
}

pub fn __action135<
    'input,
>(
    text: &'input str,
    __0: Symbol,
) -> ::std::option::Option<Symbol>
{
    Some(__0)
}

pub fn __action136<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Symbol>
{
    None
}

pub fn __action137<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Symbol>
{
    vec![]
}

pub fn __action138<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Symbol>,
    e: Symbol,
) -> ::std::vec::Vec<Symbol>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action139<
    'input,
>(
    text: &'input str,
    __0: Symbol,
    _: Tok<'input>,
) -> Symbol
{
    (__0)
}

pub fn __action140<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(__0)
}

pub fn __action141<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn __action142<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeRef>
{
    vec![]
}

pub fn __action143<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    e: TypeRef,
) -> ::std::vec::Vec<TypeRef>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action144<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
    _: Tok<'input>,
) -> TypeRef
{
    (__0)
}

pub fn __action145<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
) -> ::std::option::Option<TypeRef>
{
    Some(__0)
}

pub fn __action146<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<TypeRef>
{
    None
}

pub fn __action147<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<TypeRef>
{
    vec![]
}

pub fn __action148<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<TypeRef>,
    e: TypeRef,
) -> ::std::vec::Vec<TypeRef>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action149<
    'input,
>(
    text: &'input str,
    __0: TypeRef,
    _: Tok<'input>,
) -> TypeRef
{
    (__0)
}

pub fn __action150<
    'input,
>(
    text: &'input str,
    __0: Conversion,
) -> ::std::option::Option<Conversion>
{
    Some(__0)
}

pub fn __action151<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Conversion>
{
    None
}

pub fn __action152<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Conversion>
{
    vec![]
}

pub fn __action153<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Conversion>,
    e: Conversion,
) -> ::std::vec::Vec<Conversion>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action154<
    'input,
>(
    text: &'input str,
    __0: Conversion,
    _: Tok<'input>,
) -> Conversion
{
    (__0)
}

pub fn __action155<
    'input,
>(
    text: &'input str,
    __0: Pattern,
) -> ::std::option::Option<Pattern>
{
    Some(__0)
}

pub fn __action156<
    'input,
>(
    text: &'input str,
) -> ::std::option::Option<Pattern>
{
    None
}

pub fn __action157<
    'input,
>(
    text: &'input str,
) -> ::std::vec::Vec<Pattern>
{
    vec![]
}

pub fn __action158<
    'input,
>(
    text: &'input str,
    v: ::std::vec::Vec<Pattern>,
    e: Pattern,
) -> ::std::vec::Vec<Pattern>
{
    { let mut v = v; v.push(e); v }
}

pub fn __action159<
    'input,
>(
    text: &'input str,
    __0: Pattern,
    _: Tok<'input>,
) -> Pattern
{
    (__0)
}

pub trait __ToTriple {
    type Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),Self::Error>;
}

impl __ToTriple for (usize, Tok<'input>, usize) {
    type Error = tok::Error;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),tok::Error> {
        Ok(value)
    }
}
impl<ERROR> __ToTriple for Result<(usize, Tok<'input>, usize),ERROR> {
    type Error = ERROR;
    fn to_triple(value: Self) -> Result<(usize,Tok<'input>,usize),ERROR> {
        value
    }
}
